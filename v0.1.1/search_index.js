var documenterSearchIndex = {"docs":
[{"location":"guide/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# this is placed here to pre-install matplotlib so the documentation doesn't get cluttered with the installation print statements.\nusing Plots\npyplot()","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"In this guide we introduce you to the basic functionality of this package in a step by step manner.  This is a good starting point for learning about how to use this package.  For more details about how to use a particular function the Public API is likely a better resource.  For more examples of how to use this package see the examples.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"If you haven't yet, now would be a good time to install GXBeam.  GXBeam can be installed from the Julia REPL by typing ] (to enter the package manager) and then running the following command.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"pkg> add GXBeam","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Now, that the package is installed we need to load it so that we can use it.  It's also often helpful to load the LinearAlgebra package.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using GXBeam, LinearAlgebra\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The geometry we will be working with is a rotating beam with a swept tip as pictured.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"This geometry has a fixed boundary condition on the left side of the beam and rotates around a point 2.5 inches to the left of the beam.  We will investigating the steady behavior of this system for a variety of RPM settings at a constant sweep of 45°.","category":"page"},{"location":"guide/#Creating-an-Assembly","page":"Getting Started","title":"Creating an Assembly","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The first step for any analysis is to create an object of type Assembly.  This object stores the properties of each of the points and beam elements in our model.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To create an object of type Assembly we need the following:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"An array of points\nThe starting point for each beam element\nThe ending point for each beam element\nThe stiffness or compliance matrix for each beam element\nThe mass or inverse mass matrix for each beam element (for dynamic simulations)\nRotation matrices for each beam element which transform from the global frame to the undeformed local beam frame.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"In case the beam elements are curved we can also manually provide the length and midpoint of each beam element.  This is not necessary for straight beam elements.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We will first focus on the geometry.  We start by defining the straight section of the beam.  This section extends from (2.5, 0, 0) to (34, 0, 0).  Its local undeformed coordinate frame is the same as the global coordinate frame.  We will discretize this section into 10 elements.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To aid with constructing the geometry we can use the discretize_beam function.  Here we will pass in the length, starting point, and number of elements.  The function returns the lengths, endpoints, midpoints, and frame of each beam element.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# straight section of the beam\nL_b1 = 31.5 # length of straight section of the beam in inches\nr_b1 = [2.5, 0, 0] # starting point of straight section of the beam\nnelem_b1 = 10 # number of elements in the straight section of the beam\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The lengths of each beam element is equal since we used the number of elements to define the discretization.  Alternatively we can manually specify the discretization of the section. The following is equivalent to the previous function call.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"disc_b1 = range(0, 1, length=nelem_b1+1) # normalized discretization in straight section of the beam\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, disc_b1)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We will now create the geometry for the swept portion of the wing.  To do so we use the same discretize_beam function, with an additional argument that allows us to specify a rotation matrix which transforms from the global frame to the undeformed frame of the starting point of this beam section.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"sweep = 45 * pi/180\n\n# swept section of the beam\nL_b2 = 6 # length of swept section of the beam\nr_b2 = [34, 0, 0] # starting point of swept section of the beam\nnelem_b2 = 5 # number of elements in swept section of the beam\ncs, ss = cos(sweep), sin(sweep)\nframe_b2 = [cs ss 0; -ss cs 0; 0 0 1] # transformation matrix from global to local frame\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, frame=frame_b2)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"If either of these beam sections were curved we would have also had to pass in a curvature vector to discretize_beam.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We will now manually combine the results of our two calls to discretize_beam.  Since the last endpoint from the straight section is the same as the first endpoint of the swept section we drop one of the endpoints when combining our results.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2 # total number of elements\npoints = vcat(xp_b1, xp_b2[2:end]) # all points in our assembly\nstart = 1:nelem_b1 + nelem_b2 # starting point of each beam element in our assembly\nstop = 2:nelem_b1 + nelem_b2 + 1 # ending point of each beam element in our assembly\nlengths = vcat(lengths_b1, lengths_b2) # length of each beam element in our assembly\nmidpoints = vcat(xm_b1, xm_b2) # midpoint of each beam element in our assembly\nCab = vcat(Cab_b1, Cab_b2) # transformation matrix from global to local frame for each beam element in our assembly\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Next we need to define the stiffness (or compliance) and mass (or inverse mass) matrices for each beam element.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The compliance matrix is defined according to the following equation","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"beginbmatrix\ngamma_11 \n2gamma_12 \n2gamma_13 \nkappa_1 \nkappa_2 \nkappa_3\nendbmatrix\n=\nbeginbmatrix\n   S_11  S_12  S_13  S_14  S_15  S_16 \n   S_12  S_22  S_23  S_24  S_25  S_26 \n   S_13  S_23  S_33  S_34  S_35  S_36 \n   S_14  S_24  S_43  S_44  S_45  S_46 \n   S_15  S_25  S_35  S_45  S_55  S_56 \n   S_16  S_26  S_36  S_46  S_56  S_66\nendbmatrix\nbeginbmatrix\n   F_1 \n   F_2 \n   F_3 \n   M_1 \n   M_2 \n   M_3\nendbmatrix","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"with the variables defined as follows:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"gamma_11: beam axial strain\n2gamma_12 engineering transverse strain along axis 2\n2gamma_13 engineering transverse strain along axis 3\nkappa_1: twist\nkappa_2: curvature about axis 2\nkappa_3: curvature about axis 3\nF_i: resultant force about axis i\nM_i: resultant moment about axis i","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The elements of the mass matrix are defined as:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"beginbmatrix\n   mu  0  0  0  mu x_m3  -mu x_m2 \n   0  mu  0  -mu x_m3  0  0 \n   0  0  mu  mu x_m2  0  0 \n   0  -mu x_m3  mu x_m2  i_22 + i_33  0  0 \n   mu x_m3   0  0  0  i_22  -i_23 \n   -mu x_m2  0  0  0  -i_23  i_33\nendbmatrix","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"with the variables defined as follows:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"mu: mass per unit length\n(x_m2 x_m3): location of mass center\ni_22: mass moment of inertia about axis 2\ni_33: mass moment of inertia about axis 3\ni_23: product of inertia","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We assume that our beam has a constant cross section with the following properties:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"1 inch width\n0.063 inch height\n1.06 x 10^7 lb/in^2 elastic modulus\n0.325 Poisson's ratio\n2.51 x 10^-4 lb sec^2/in^4 density","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We also assume the following shear and torsion correction factors:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"k_y = 12000001839588001\nk_z = 14625127919304001\nk_t = 6585255016982444","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# cross section\nw = 1 # inch\nh = 0.063 # inch\n\n# material properties\nE = 1.06e7 # lb/in^2\nν = 0.325\nρ = 2.51e-4 # lb sec^2/in^4\n\n# shear and torsion correction factors\nky = 1.2000001839588001\nkz = 14.625127919304001\nkt = 65.85255016982444\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\n# apply corrections\nAy = A/ky\nAz = A/kz\nJx = J/kt\n\nG = E/(2*(1+ν))\n\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\nmass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Our case is simple enough that we can analytically calculate most values for the compliance and mass matrices, but this is not generally the case.  For more complex geometries/structures it may be necessary to use a cross-sectional property solver such as PreComp or VABS.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Also note that any row/column of the stiffness and/or compliance matrix which is zero will be interpreted as infinitely stiff in that degree of freedom.  This corresponds to a row/column of zeros in the compliance matrix.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We are now ready to put together our assembly.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"assembly = Assembly(points, start, stop, compliance=compliance, mass=mass, frames=Cab, lengths=lengths, midpoints=midpoints)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"At this point this is probably a good time to check that the geometry of our assembly is correct.  We can do this by visualizing the geometry in ParaView.  We can use the write_vtk function to do this.  Note that in order to visualize the generated file yourself you will need to install ParaView separately.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"write_vtk(\"swept-tip\", assembly)","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/#Defining-Distributed-Loads","page":"Getting Started","title":"Defining Distributed Loads","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We won't be applying distributed loads to our model, but will demonstrate how to do so.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Distributed loads are defined by using the constructor DistributedLoads.  One instance of DistributedLoads must be created for every beam element on which the distributed load is applied.  These instances of DistributedLoads are then stored in a dictionary in which they are accessed by their beam element index.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To define a DistributedLoad the assembly, element number, and distributed load functions must be passed to distributed_loads.  Possible distributed load functions are:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"fx: Distributed non-follower force on beam element in x-direction\nfy: Distributed non-follower force on beam element in y-direction\nfz: Distributed non-follower force on beam element in z-direction\nmx: Distributed non-follower moment on beam element in x-direction\nmy: Distributed non-follower moment on beam element in y-direction\nmz: Distributed non-follower moment on beam element in z-direction\nfx_follower: Distributed follower force on beam element in x-direction\nfy_follower: Distributed follower force on beam element in y-direction\nfz_follower: Distributed follower force on beam element in z-direction\nmx_follower: Distributed follower moment on beam element in x-direction\nmy_follower: Distributed follower moment on beam element in y-direction\nmz_follower: Distributed follower moment on beam element in z-direction","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"By default these functions are specified as functions of the arbitrary coordinate s (f(s)), however, if more than one time step is used in the simulation these functions are specified as a function of the arbitrary coordinate s and time t (f(st)).","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"One can specify the s-coordinate at the start and end of the beam element using the keyword arguments s1 and s2.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For example, the following code applies a uniform 10 pound distributed load in the global z-direction on all beam elements:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"distributed_loads = Dict()\nfor ielem in 1:nelem\n    distributed_loads[ielem] = DistributedLoads(assembly, ielem; fz = (s) -> 10)\nend\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To instead make this a follower force (a force that rotates with the structure) we would use the following code:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"distributed_loads = Dict()\nfor ielem in 1:nelem\n    distributed_loads[ielem] = DistributedLoads(assembly, ielem; fz_follower = (s) -> 10)\nend\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The units are arbitrary, but must be consistent with the units used when constructing assembly.  Also note that both non-follower and follower forces may exist simultaneously.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"If we wanted to define the same follower force for a simulation with multiple time steps we would also need to provide temporal data.  Assuming a step size of 0.01 seconds and 101 steps in the simulation (including the step to find the solution at time t=0.0) this would be done as follows:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"dt = 0.01\nnstep = 101\ndistributed_loads_multistep = Dict()\nfor ielem in 1:nelem\n    distributed_loads_multistep[ielem] = DistributedLoads(assembly, ielem, dt; nstep=101, fz = (s,t) -> 10)\nend\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"It is worth noting that the distributed loads are integrated over each element when they are created using 4-point Gauss-Legendre quadrature.  If more control over the integration is desired one may specify a custom integration method as described in the documentation for DistributedLoads.","category":"page"},{"location":"guide/#Defining-Prescribed-Conditions","page":"Getting Started","title":"Defining Prescribed Conditions","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Whereas distributed loads are applied to beam elements, prescribed conditions are forces and/or displacement boundary conditions applied to points. One instance of PrescribedConditions must be created for every point on which prescribed conditions are applied.  These instances of PrescribedConditions are then stored in a dictionary in which they are accessed by their point index.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"PrescribedConditions may be either specified as a constant or as a function of time.  Possible prescribed conditions include:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"ux: Prescribed x-direction displacement of the point\nuy: Prescribed y-direction displacement of the point\nuz: Prescribed z-direction displacement of the point\ntheta_x: Prescribed first Wiener-Milenkovic parameter of the point\ntheta_y: Prescribed second Wiener-Milenkovic parameter of the point\ntheta_z: Prescribed third Wiener-Milenkovic parameter of the point\nFx: Prescribed force in x-direction applied on the point\nFy: Prescribed force in y-direction applied on the point\nFz: Prescribed force in z-direction applied on the point\nMx: Prescribed moment about x-axis applied on the point\nMy: Prescribed moment about y-axis applied on the point\nMz: Prescribed moment about z-axis applied on the point\nFx_follower: Prescribed follower force in x-direction applied on the point\nFy_follower: Prescribed follower force in y-direction applied on the point\nFz_follower: Prescribed follower force in z-direction applied on the point\nMx_follower: Prescribed follower moment about x-axis applied on the point\nMy_follower: Prescribed follower moment about y-axis applied on the point\nMz_follower: Prescribed follower moment about z-axis applied on the point","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"One can apply both force and displacement boundary conditions to the same point, but one cannot specify a force and displacement condition at the same point corresponding to the same degree of freedom.  If this is requested an error will result.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Here we create a fixed boundary condition on the left side of the beam.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # root section is fixed\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n    )\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To do the same for a simulation with multiple time steps:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# create dictionary of prescribed conditions\ndt = 0.01\nnstep = 101\nprescribed_conditions_multistep = Dict(\n    # root section is fixed\n    1 => PrescribedConditions(dt; nstep=nstep, ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n    )\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We could have also specified ux, uy, uz, theta_x, theta_y, and theta_z as functions of time.","category":"page"},{"location":"guide/#Pre-Initializing-Memory-for-an-Analysis","page":"Getting Started","title":"Pre-Initializing Memory for an Analysis","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"At this point we have everything we need to perform an analysis.  However, since we will be performing multiple analyses using the same assembly we can save computational time be preallocating memory for the analysis.  This can be done by constructing an object of type System.  The constructor for this object requires that we provide the assembly, a list of points upon which point conditions are applied, and a flag indicating whether the system is static.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"prescribed_points = [1, nelem+1]\nstatic = false\nsystem = System(assembly, prescribed_points, static)\nnothing #hide","category":"page"},{"location":"guide/#Performing-a-Steady-State-Analysis","page":"Getting Started","title":"Performing a Steady State Analysis","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We're now ready to perform our steady state analyses.  This can be done by calling steady_state_analysis with the pre-allocated system storage, assembly, angular velocity, and the prescribed point conditions.  We can also perform a linear analysis instead of a nonlinear analysis by using the linear keyword argument.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"After each analysis we'll also construct an object of type AssemblyState so that we can save the results of each analysis prior to re-using the pre-allocated memory for the next analysis.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"\nrpm = 0:25:750\n\nlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nfor i = 1:length(rpm)\n\n    # global frame rotation\n    w0 = [0, 0, rpm[i]*(2*pi)/60]\n\n    # perform linear steady state analysis\n    _, converged = steady_state_analysis!(system, assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions,\n        linear = true)\n\n    linear_states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nend\n\nreset_state!(system)\n\nnonlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nfor i = 1:length(rpm)\n\n   # global frame rotation\n   w0 = [0, 0, rpm[i]*(2*pi)/60]\n\n    # perform nonlinear steady state analysis\n    _, converged = steady_state_analysis!(system, assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions)\n\n     nonlinear_states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"guide/#Post-Processing-Results","page":"Getting Started","title":"Post Processing Results","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We can access the fields in each instance of AssemblyState in order to plot various quantities of interest.  This object stores an array of objects of type PointState in the field points and an array of objects of type ElementState in the field elements.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The fields of PointState are the following:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"u: displacement\ntheta: angular displacement\nF: externally applied forces\nM: externally applied moments","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The fields of ElementState are the following:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"u: displacement\ntheta: angular displacement\nF: resultant forces\nM: resultant moments\nP: linear momenta\nH: angular momenta","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To demonstrate how these fields can be accessed we will now plot the root moment and tip deflections.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\n# root moment\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    yticks = 0.0:2:12,\n    ylabel = \"\\$M_z\\$ at the root (lb-in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nMz_nl = [-nonlinear_states[i].points[1].M[3] for i = 1:length(rpm)]\nMz_l = [-linear_states[i].points[1].M[3] for i = 1:length(rpm)]\nplot!(rpm, Mz_nl, label=\"Nonlinear\")\nplot!(rpm, Mz_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-Mz.svg\"); nothing #hide\n\n# x tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.002, 0.074),\n    yticks = 0.0:0.01:0.07,\n    ylabel = \"\\$u_x\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nux_nl = [nonlinear_states[i].points[end].u[1] for i = 1:length(rpm)]\nux_l = [linear_states[i].points[end].u[1] for i = 1:length(rpm)]\nplot!(rpm, ux_nl, label=\"Nonlinear\")\nplot!(rpm, ux_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-ux.svg\"); nothing #hide\n\n# y tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.01, 0.27),\n    yticks = 0.0:0.05:0.25,\n    ylabel = \"\\$u_y\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nuy_nl = [nonlinear_states[i].points[end].u[2] for i = 1:length(rpm)]\nuy_l = [linear_states[i].points[end].u[2] for i = 1:length(rpm)]\nplot!(rpm, uy_nl, label=\"Nonlinear\")\nplot!(rpm, uy_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-uy.svg\"); nothing #hide\n\n# rotation of the tip\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylabel = \"\\$θ_z\\$ at the tip\",\n    grid = false,\n    overwrite_figure=false\n    )\ntheta_z_nl = [4*atan(nonlinear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]\ntheta_z_l = [4*atan(linear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]\n\nplot!(rpm, theta_z_nl, label=\"Nonlinear\")\nplot!(rpm, theta_z_l, label=\"Linear\")\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"guide/#Other-Capabilities","page":"Getting Started","title":"Other Capabilities","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For information on how to use the other capabilities of this package see the examples and/or the the Public API.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/#Creating-an-Assembly","page":"Library","title":"Creating an Assembly","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"curve_length\ndiscretize_beam\nAssembly(points, start, stop)","category":"page"},{"location":"library/#GXBeam.curve_length","page":"Library","title":"GXBeam.curve_length","text":"curve_length(start, stop, curvature)\n\nCalculate the length of a curve given its endpoints and its curvature vector\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.discretize_beam","page":"Library","title":"GXBeam.discretize_beam","text":"discretize_beam(L, start, discretization; frame = Matrix(I,3,3)), curvature = zeros(3))\n\nDiscretize a beam according to the discretization provided in discretization given the beam length (L), and starting point (start).\n\nReturn the lengths, endpoints, midpoints, and rotation matrices of the beam elements.\n\nArguments\n\nL: Beam length\nstart: Beam starting point\ndiscretization: May be either an integer, representing the number of      elements that the beam should be discretized into, or a vector containing      the normalized endpoints of each beam element, where 0 is the beginning      of the beam and 1 is the end of the beam.\nframe: 3x3 beam rotation matrix which transforms from the local beam      coordinate frame at the start of the beam to the global coordinate frame.\ncurvature: curvature vector\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.Assembly-Tuple{Any,Any,Any}","page":"Library","title":"GXBeam.Assembly","text":"Assembly(points, start, stop; kwargs...)\n\nConstruct an assembly of connected nonlinear beam elements for analysis.  Beam lengths and midpoints may be manually specified in case beam elements are curved rather than straight.\n\nArguments\n\npoints: Array of all beam element endpoints\nstart: Array containing point indices where each beam element starts\nstop: Array containing point indices where each beam element stops\n\nKeyword Arguments\n\nstiffness: Array of (6 x 6) stiffness matrices for each beam element, alternative to providing compliance\ncompliance: Array of (6 x 6) compliance matrices for each beam element, defaults to zeros(6,6) for each beam element\nmass: Array of (6 x 6) mass matrices for each beam element, alternative to providing minv\nminv: Array of (6 x 6) mass matrices for each beam element, defaults to the identity matrix for each beam element\nframes: Array of (3 x 3) rotation matrices for each beam element (to transform      to the global frame), defaults to the identity matrix for each beam element\nlengths: Array containing the length of each beam, defaults to the distance between beam endpoints\nmidpoints: Array containing the midpoint of each beam element, defaults to the average of the beam element endpoints\n\n\n\n\n\n","category":"method"},{"location":"library/#Defining-Distributed-Loads","page":"Library","title":"Defining Distributed Loads","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"DistributedLoads(assembly, ibeam)","category":"page"},{"location":"library/#GXBeam.DistributedLoads-Tuple{Any,Any}","page":"Library","title":"GXBeam.DistributedLoads","text":"DistributedLoads(assembly, ibeam[, dt]; kwargs...)\n\nIntegrates the specified distributed loads over the element for each time step.\n\nArguments\n\nassembly: The beam element assembly\nibeam: The index of the beam element which the distributed load is assigned to\ndt: Time step size.  If omitted a single time step is assumed and specified   functions become a function of s only.\ns1 = 0.0: Start of beam element (used for integrating the distributed loads)\ns2 = 1.0: End of beam element (used for integrating the distributed loads)\nnstep: The total length of the time vector\nmethod = (f, a, b) -> gauss_quadrature(f, a, b): Method which integrates function  f from a to b. Defaults to the Gauss-Legendre quadrature with 4 points on each element.\nfx = (s, t) -> 0.0: Distributed non-follower force on beam element in x-direction\nfy = (s, t) -> 0.0: Distributed non-follower force on beam element in y-direction\nfz = (s, t) -> 0.0: Distributed non-follower force on beam element in z-direction\nmx = (s, t) -> 0.0: Distributed non-follower moment on beam element in x-direction\nmy = (s, t) -> 0.0: Distributed non-follower moment on beam element in y-direction\nmz = (s, t) -> 0.0: Distributed non-follower moment on beam element in z-direction\nfx_follower = (s, t) -> 0.0: Distributed follower force on beam element in x-direction\nfy_follower = (s, t) -> 0.0: Distributed follower force on beam element in y-direction\nfz_follower = (s, t) -> 0.0: Distributed follower force on beam element in z-direction\nmx_follower = (s, t) -> 0.0: Distributed follower moment on beam element in x-direction\nmy_follower = (s, t) -> 0.0: Distributed follower moment on beam element in y-direction\nmz_follower = (s, t) -> 0.0: Distributed follower moment on beam element in z-direction\n\n\n\n\n\n","category":"method"},{"location":"library/#Defining-Prescribed-Conditions","page":"Library","title":"Defining Prescribed Conditions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"PrescribedConditions()","category":"page"},{"location":"library/#GXBeam.PrescribedConditions-Tuple{}","page":"Library","title":"GXBeam.PrescribedConditions","text":"PrescribedConditions(dt=0.0; kwargs...)\n\nConstruct an object of type PrescribedConditions which stores the prescribed conditions for a point at each time step.\n\nPrescribed conditions may be assigned as either a scalar parameter or as a function of time.\n\nPrescribed Wiener-Milenkovic parameters must satisfy the following inequality: sqrt(thetax^2 + thetay^2 + theta_z^2) <= 4.  Note that this restriction still allows all possible rotations to be represented.\n\nArguments\n\ndt: Time step size.\nnstep: The total length of the time vector\nux: Prescribed x-direction displacement of the point\nuy: Prescribed y-direction displacement of the point\nuz: Prescribed z-direction displacement of the point\ntheta_x: Prescribed first Wiener-Milenkovic parameter of the point\ntheta_y: Prescribed second Wiener-Milenkovic parameter of the point\ntheta_z: Prescribed third Wiener-Milenkovic parameter of the point\nFx: Prescribed force in x-direction applied on the point\nFy: Prescribed force in y-direction applied on the point\nFz: Prescribed force in z-direction applied on the point\nMx: Prescribed moment about x-axis applied on the point\nMy: Prescribed moment about y-axis applied on the point\nMz: Prescribed moment about z-axis applied on the point\nFx_follower: Prescribed follower force in x-direction applied on the point\nFy_follower: Prescribed follower force in y-direction applied on the point\nFz_follower: Prescribed follower force in z-direction applied on the point\nMx_follower: Prescribed follower moment about x-axis applied on the point\nMy_follower: Prescribed follower moment about y-axis applied on the point\nMz_follower: Prescribed follower moment about z-axis applied on the point\n\n\n\n\n\n","category":"method"},{"location":"library/#Pre-Initializing-Memory-for-an-Analysis","page":"Library","title":"Pre-Initializing Memory for an Analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"System(assembly, points, static)\nreset_state!","category":"page"},{"location":"library/#GXBeam.System-Tuple{Any,Any,Any}","page":"Library","title":"GXBeam.System","text":"System([TF=eltype(assembly),] assembly, points, static)\n\nInitialize an object of type System which stores the system state, residual vector, current time function values,and jacobian matrices as well as pointers to be able to access their contents.\n\nArguments:\n\nTF: (optional) Used to specify floating point type used by resulting System object\nassembly: Assembly of rigidly connected nonlinear beam elements\npoints: Point indices which should be preserved in the system of equations.      All points with prescribed conditions should be included.\nstatic: Flag indicating whether system matrices will be used for static simulations\n\n\n\n\n\n","category":"method"},{"location":"library/#GXBeam.reset_state!","page":"Library","title":"GXBeam.reset_state!","text":"reset_state!(system)\n\nReset the state variables in system (stored in system.x) to zero.\n\n\n\n\n\n","category":"function"},{"location":"library/#Performing-an-Analysis","page":"Library","title":"Performing an Analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"static_analysis\nstatic_analysis!\nsteady_state_analysis\nsteady_state_analysis!\neigenvalue_analysis\neigenvalue_analysis!\ntime_domain_analysis\ntime_domain_analysis!","category":"page"},{"location":"library/#GXBeam.static_analysis","page":"Library","title":"GXBeam.static_analysis","text":"static_analysis(assembly; kwargs...)\n\nPerform a static analysis of the system of nonlinear beams contained in assembly. Return the resulting system and a flag indicating whether the iteration procedure converged.\n\nKeyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}(): Dictionary   holding PrescribedConditions composite types for the points in keys(prescribed_conditions)\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): Dictionary holding   DistributedLoads composite types for the beam elements in keys(distributed_loads)\nlinear = false: Set to true for a linear analysis\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.BackTracking(): Line search used to solve nonlinear system of equations\nftol = 1e-9: tolerance for solving nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\nnstep = 1: Number of time steps. May be used in conjunction with time varying   prescribed conditions and distributed loads to gradually increase  displacements/loads.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.static_analysis!","page":"Library","title":"GXBeam.static_analysis!","text":"static_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of static_analysis.  Uses the state variables stored in system as an initial guess for iterating.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.steady_state_analysis","page":"Library","title":"GXBeam.steady_state_analysis","text":"steady_state_analysis(assembly; kwargs...)\n\nPerform a steady-state analysis for the system of nonlinear beams contained in assembly.  Return the resulting system and a flag indicating whether the iteration procedure converged.\n\nKeyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}(): Dictionary   holding PrescribedConditions composite types for the points in keys(prescribed_conditions)\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): Dictionary holding   DistributedLoads composite types for the beam elements in keys(distributed_loads)\nlinear = false: Set to true for a linear analysis\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.BackTracking(): Line search used to solve nonlinear system of equations\nftol = 1e-9: tolerance for solving nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\nnstep = 1: Number of time steps. May be used in conjunction with time varying   prescribed conditions, distributed loads, and global motion to gradually   increase displacements/loads.\norigin = zeros(3): Global frame origin\nlinear_velocity = fill(zeros(3), nstep): Global frame linear velocity for each time step.\nangular_velocity = fill(zeros(3), nstep): Global frame angular velocity for each time step\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.steady_state_analysis!","page":"Library","title":"GXBeam.steady_state_analysis!","text":"steady_state_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of steady_state_analysis.  Uses the state variables stored in system as an initial guess for iterating.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.eigenvalue_analysis","page":"Library","title":"GXBeam.eigenvalue_analysis","text":"eigenvalue_analysis(assembly; kwargs...)\n\nCompute the eigenvalues and eigenvectors of the system of nonlinear beams contained in assembly.  Return the modified system, eigenvalues, eigenvectors, and a convergence flag indicating whether the corresponding steady-state analysis converged.\n\nKeyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}(): Dictionary   holding PrescribedConditions composite types for the points in keys(prescribed_conditions)\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): Dictionary holding   DistributedLoads composite types for the beam elements in keys(distributed_loads)\nlinear = false: Set to true for a linear analysis\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.BackTracking(): Line search used to solve nonlinear system of equations\nftol = 1e-9: tolerance for solving nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\nnstep = 1: Number of time steps. May be used in conjunction with time varying   prescribed conditions, distributed loads, and global motion to gradually   increase displacements/loads.\norigin = zeros(3): Global frame origin\nlinear_velocity = fill(zeros(3), nstep): Global frame linear velocity for each time step.\nangular_velocity = fill(zeros(3), nstep): Global frame angular velocity for each time step\nnev = 6: Number of eigenvalues to compute\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.eigenvalue_analysis!","page":"Library","title":"GXBeam.eigenvalue_analysis!","text":"eigenvalue_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of eigenvalue_analysis.  Uses the state variables stored in system as an initial guess for iterating to find the steady state solution.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.time_domain_analysis","page":"Library","title":"GXBeam.time_domain_analysis","text":"time_domain_analysis(assembly, dt; kwargs...)\n\nPerform a time-domain analysis for the system of nonlinear beams contained in assembly.  Return the final system, a post-processed solution history, and a convergence flag indicating whether the iterations converged for each time step.\n\nKeyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}(): Dictionary   holding PrescribedConditions composite types for the points in keys(prescribed_conditions)\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): Dictionary holding   DistributedLoads composite types for the beam elements in keys(distributed_loads)\nlinear = false: Set to true for a linear analysis\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.BackTracking(): Line search used to solve nonlinear system of equations\nftol = 1e-9: tolerance for solving nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\nnstep = 1: The total length of the time vector\norigin = zeros(3): Global frame origin\nlinear_velocity = fill(zeros(3), nstep): Global frame linear velocity for each time step.\nangular_velocity = fill(zeros(3), nstep): Global frame angular velocity for each time step.\nu0=fill(zeros(3), length(assembly.elements)): initial displacment of each beam element,\ntheta0=fill(zeros(3), length(assembly.elements)): initial angular displacement of each beam element,\nudot0=fill(zeros(3), length(assembly.elements)): initial time derivative with respect to u\nthetadot0=fill(zeros(3), length(assembly.elements)): initial time derivative with respect to theta\nsave=1:nstep: Steps at which to save the time history\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.time_domain_analysis!","page":"Library","title":"GXBeam.time_domain_analysis!","text":"time_domain_analysis!(system, assembly, dt; kwargs...)\n\nPre-allocated version of time_domain_analysis.  Uses the state variables stored in system as an initial guess for iterating.\n\n\n\n\n\n","category":"function"},{"location":"library/#Post-Processing","page":"Library","title":"Post-Processing","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AssemblyState(system, assembly)\nAssemblyState\nleft_eigenvectors\ncorrelate_eigenmodes\nwiener_milenkovic\nwrite_vtk","category":"page"},{"location":"library/#GXBeam.AssemblyState-Tuple{Any,Any}","page":"Library","title":"GXBeam.AssemblyState","text":"AssemblyState(system, assembly, x = system.x;\n    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nPost-process the system state given the solution vector x.  Return an object of type AssemblyState that defines the state of the assembly for the time step.\n\nIf prescribed_conditions is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.\n\n\n\n\n\n","category":"method"},{"location":"library/#GXBeam.AssemblyState","page":"Library","title":"GXBeam.AssemblyState","text":"AssemblyState{TF, TP<:AbstractVector{PointState{TF}}, TE<:AbstractVector{ElementState{TF}}}\n\nStruct for storing state variables for the points and elements in an assembly.\n\nFields:\n\npoints::TP: Array of PointStates for each point in the assembly\nelements::TE: Array of ElementStates for each element in the assembly\n\n\n\n\n\n","category":"type"},{"location":"library/#GXBeam.left_eigenvectors","page":"Library","title":"GXBeam.left_eigenvectors","text":"left_eigenvectors(system, λ, V)\nleft_eigenvectors(K, M, λ, V)\n\nCompute the left eigenvector matrix U for the system using inverse power iteration given the eigenvalues λ and the corresponding right eigenvector matrix V.\n\nThe complex conjugate of each left eigenvector is stored in each row of the matrix U\n\nLeft and right eigenvectors satisfy the following M-orthogonality condition:\n\nu'Mv = 1 if u and v correspond to the same eigenvalue\nu'Mv = 0 if u and v correspond to different eigenvalues\n\nThis means that UMV = I\n\nThis function assumes that system has not been modified since the eigenvalues and right eigenvectors were computed.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.correlate_eigenmodes","page":"Library","title":"GXBeam.correlate_eigenmodes","text":"correlate_eigenmodes(C)\n\nReturn the permutation and the associated corruption index vector which associates eigenmodes from the current iteration with those of the previous iteration given the correlation matrix C.\n\nThe correlation matrix can take one of the following forms (in order of preference):\n\nC = U_p*M*V\nC = U*M_p*V_p\nC = V_p'*V\nC = V'*V_p\n\nwhere U is a matrix of conjugated left eigenvectors, M is the system mass matrix, V is a matrix of right eigenvectors, and ()_p indicates a variable from the previous iteration.\n\nNote that the following two forms of the correlation matrix seem to be significantly inferior to their counterparts listed above: C = U*M*V_p and C = U_p*M_p*V. This is likely due to the way in which the left eigenvector matrix is calculated.\n\nThe corruption index is the largest magnitude in a given row of C that was not chosen divided by the magnitude of the chosen eigenmode.  It is most meaningful when using one of the forms of the correlation matrix that uses left eigenvectors since correct eigenmodes will have magnitudes close to 1 and incorrect eigenmodes will have magnitudes close to 0.\n\nIf the new mode number is already assigned, the next highest unassigned mode number is used.  In this case a corruption index higher than 1 will be returned, otherwise the values of the corruption index will always be bounded by 0 and 1.\n\nSee \"New Mode Tracking Methods in Aeroelastic Analysis\" by Eldred, Vankayya, and Anderson.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.wiener_milenkovic","page":"Library","title":"GXBeam.wiener_milenkovic","text":"wiener_milenkovic(c)\n\nConstruct a Wiener-Milenkovic rotation matrix, given the three Wiener-Milenkovic parameters in c.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.write_vtk","page":"Library","title":"GXBeam.write_vtk","text":"write_vtk(name, assembly::Assembly; kwargs...)\nwrite_vtk(name, assembly::Assembly, state::AssemblyState; kwargs...)\nwrite_vtk(name, assembly::Assembly, history::Vector{<:AssemblyState}], dt; kwargs...)\n\nWrite the deformed geometry (and associated data) to a VTK file for visualization using ParaView.\n\nThe state parameter may be omitted to write the original geometry to a VTK file without any associated data.\n\nIf the solution time history is provided, the time step must also be provided\n\nKeyword Arguments\n\nscaling=1.0: Parameter to scale the deflections (only valid if state is provided)\nmetadata=Dict(): Dictionary of metadata for the file(s)\n\n\n\n\n\nwrite_vtk(name, assembly::Assembly, [state::AssemblyState, ]λ::Number, eigenstate::AssemblyState;\nscaling=1.0, mode_scaling=1.0, cycles=1, steps=100)\n\nWrite a series of files corresponding to the elastic motion of the assembly about the deformed state encoded in state defined by the eigenvalue λ and the eigenvector encoded in eigenstate over the time period specified by time.\n\nThe steady-state deflections can be scaled with scaling and the eigenmode deflections can be scaled using mode_scaling.\n\nThe current time is encoded in the metadata tag \"time\"\n\n\n\n\n\n","category":"function"},{"location":"library/#Private-API","page":"Library","title":"Private API","text":"","category":"section"},{"location":"library/#Math","page":"Library","title":"Math","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GXBeam.tilde\nGXBeam.rotation_parameter_scaling\nGXBeam.get_C\nGXBeam.get_C_t\nGXBeam.get_C_θ\nGXBeam.get_C_θdot\nGXBeam.get_Q\nGXBeam.get_Q_θ\nGXBeam.get_Qinv\nGXBeam.get_Qinv_θ\nGXBeam.mul3\nGXBeam.gauss_quadrature","category":"page"},{"location":"library/#GXBeam.tilde","page":"Library","title":"GXBeam.tilde","text":"tilde(x)\n\nConstruct the cross product operator matrix\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.rotation_parameter_scaling","page":"Library","title":"GXBeam.rotation_parameter_scaling","text":"rotation_parameter_scaling(θ)\n\nExtract a scaling parameter which may be multiplied by the angular parameters to yield the Wiener-Milenkovic rotation parameters.  Use of this scaling parameter allows deflections greater than 360 degrees.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_C","page":"Library","title":"GXBeam.get_C","text":"get_C(θ)\n\nReturns the rotation matrix C given the three angular parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_C_t","page":"Library","title":"GXBeam.get_C_t","text":"get_C_t([C, ] θ, θ_t)\n\nCalculate the derivative of the Wiener-Milenkovic rotation matrix C with respect to the scalar parameter t. θ_t is the derivative of the angular parameter θ with respect to t.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_C_θ","page":"Library","title":"GXBeam.get_C_θ","text":"get_C_θ([C, ] θ)\n\nCalculate the derivative of the Wiener-Milenkovic rotation matrix C with respect to each of the rotation parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_C_θdot","page":"Library","title":"GXBeam.get_C_θdot","text":"get_C_θdot([C, ] θ)\n\nCalculate the derivative of the time derivative of the Wiener-Milenkovic rotation matrix C with respect to each of the time derivatives of θ. Used for constructing the \"mass\" matrix for eigenvalue computations.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_Q","page":"Library","title":"GXBeam.get_Q","text":"get_Q(θ)\n\nCalculate the matrix Q as defined in the paper \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu given the rotational parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_Q_θ","page":"Library","title":"GXBeam.get_Q_θ","text":"get_Q_θ(θ)\nget_Q_θ(Q, θ)\n\nCalculate the derivative of the matrix Q with respect to each of the rotation parameters in c.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_Qinv","page":"Library","title":"GXBeam.get_Qinv","text":"get_Qinv(θ)\n\nCalculate the matrix inverse Qinv as defined in the paper \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu given the rotational parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_Qinv_θ","page":"Library","title":"GXBeam.get_Qinv_θ","text":"get_Qinv_θ(θ)\n\nCalculate the derivative of the matrix inverse Qinv with respect to each of the rotation parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.mul3","page":"Library","title":"GXBeam.mul3","text":"mul3(A_1, A_2, A_3, b)\n\nReturn the product of a 3x3x3 tensor represented by A_1, A_2, and A_3 with the vector b.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.gauss_quadrature","page":"Library","title":"GXBeam.gauss_quadrature","text":"gauss_quadrature(f, a, b)\n\nDefault gauss-quadrature function used for integrating distributed loads.\n\n\n\n\n\n","category":"function"},{"location":"library/#Points","page":"Library","title":"Points","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GXBeam.point_variables\nGXBeam.insert_point_residual!\nGXBeam.point_residual!\nGXBeam.point_follower_jacobians\nGXBeam.insert_point_jacobian!\nGXBeam.point_jacobian!\nGXBeam.PointState","category":"page"},{"location":"library/#GXBeam.point_variables","page":"Library","title":"GXBeam.point_variables","text":"point_variables(x, icol)\npoint_variables(x, icol, prescribed_conditions, istep)\n\nExtract u, θ, F, M for the point described by the point state variables at icol in x after incorporating the prescribed conditions in prescribed_conditions\n\nNote that the degrees of freedom that are not specified in prescribed_conditions are used as state variables (e.g. prescribing F[2] would mean u[2] = x[icol+1])\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.insert_point_residual!","page":"Library","title":"GXBeam.insert_point_residual!","text":"insert_point_residual!(resid, irow_b, irow_p, u, θ, F, M, side)\n\nModify the equilibrium and constitutive equations to account for the point variables given by u, θ, F, M\n\nIf irowb != irowp, assume that the equilibrium equations have already been modified\n\nArguments\n\nresid: Residual vector\nirow_b: Row index of the first equilibrium/compatability equation for one side of the beam element\nirow_p: Row index of the first equilibrium equation for the point\nu: Displacement of the point\nθ: Rotation of the point\nF: External forces imposed on the point\nM: External moments imposed on the point\nside: Side of beam (-1 (left) or 1 (right))\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.point_residual!","page":"Library","title":"GXBeam.point_residual!","text":"point_residual!(resid, x, ipoint, assembly, prescribed_conditions, icol,\n    irow_p, irow_beam1, irow_beam2)\n\nAdds a points contributions to the residual vector\n\nArguments\n\nresid: residual vector\nx: current state vector\nipoint: index of point\nassembly: assembly of interconnected beam elements\nprescribed_conditions: dictionary of prescribed conditions\nicol: starting index for the point's state variables\nirow_p: Row index of the first equilibrium equation for the point\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.point_follower_jacobians","page":"Library","title":"GXBeam.point_follower_jacobians","text":"point_follower_jacobians(x, icol, prescribed_conditions)\n\nCalculate the jacobians of the follower forces/moments with respect to θ\n\nArguments\n\nx: Current state variable vector\nicol: Row/Column index of the first state variable for the point\nprescribed_conditions: Prescribed conditions for the point\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.insert_point_jacobian!","page":"Library","title":"GXBeam.insert_point_jacobian!","text":"insert_point_jacobian!(jacob, irow_b, irow_p, icol, prescribed_conditions, side, F_θ, M_θ)\n\nModify the jacobian entries for the equilibrium and constitutive equations to account for the point variables at icol\n\nIf irowb != irowp, assume that the equilibrium equations have already been modified\n\nArguments\n\njacob: Jacobian of residual vector with respect to state vectors\nirow_b: Row index of the first equilibrium/compatability equation for one side of the beam element\nirow_p: Row index of the first equilibrium equation for the point\nicol: Row/Column index of the first state variable for the point\nprescribed_conditions: Prescribed force/displacement and moment/rotation on point\nside: Side of beam (-1 (left) or 1 (right))\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.point_jacobian!","page":"Library","title":"GXBeam.point_jacobian!","text":"point_jacobian!(jacob, x, ipoint, assembly, prescribed_conditions, icol,\n    irow_p, irow_beam1, irow_beam2)\n\nAdds a points contributions to the residual vector\n\nArguments\n\njacob: residual vector\nx: current state vector\nipoint: index of point\nassembly: assembly of interconnected beam elements\nprescribed_conditions: dictionary of prescribed conditions\nistep: current time step\nicol: starting index for the point's state variables\nirow_p: Row index of the first equilibrium equation for the point\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.PointState","page":"Library","title":"GXBeam.PointState","text":"PointState\n\nHolds the state variables for a point\n\nFields:\n\nu: Displacement variables for the point (in the global coordinate frame)\ntheta: Wiener-Milenkovic rotational displacement variables for the point\nF: Externally applied forces on the point (in the global coordinate frame)\nM: Externally applied moments on the point (in the global coordinate frame)\n\n\n\n\n\n","category":"type"},{"location":"library/#Elements","page":"Library","title":"Elements","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GXBeam.Element\nGXBeam.element_strain\nGXBeam.element_curvature\nGXBeam.element_linear_velocity\nGXBeam.element_angular_velocity\nGXBeam.element_properties\nGXBeam.dynamic_element_properties\nGXBeam.element_equations\nGXBeam.insert_element_residual!\nGXBeam.element_residual!\nGXBeam.element_jacobian_equations\nGXBeam.insert_element_jacobian!\nGXBeam.element_jacobian!\nGXBeam.element_mass_matrix_properties\nGXBeam.element_mass_matrix_equations\nGXBeam.insert_element_mass_matrix!\nGXBeam.element_mass_matrix!\nGXBeam.ElementState","category":"page"},{"location":"library/#GXBeam.Element","page":"Library","title":"GXBeam.Element","text":"Element{TF}\n\nComposite type that defines a beam element's properties\n\nFields\n\nL: Length of the beam element\nx: Location of the beam element (the midpoint of the beam element)\nC11: Upper left portion of the beam element's compliance matrix\nC12: Upper right portion of the beam element's compliance matrix\nC22: Lower right portion of the beam element's compliance matrix\nminv11: Upper left portion of the inverse of the beam element's mass matrix\nminv12: Upper right portion of the inverse of the beam element's mass matrix\nminv22: Lower right portion of the inverse of the beam element's mass matrix\nCab: Rotation matrix from the global frame to beam element's frame\n\n\n\n\n\n","category":"type"},{"location":"library/#GXBeam.element_strain","page":"Library","title":"GXBeam.element_strain","text":"element_strain(element, F, M)\n\nCalculate the strain of a beam element given the resultant force and moments\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_curvature","page":"Library","title":"GXBeam.element_curvature","text":"element_curvature(element, F, M)\n\nCalculate the curvature of a beam element given the resultant force and moments\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_linear_velocity","page":"Library","title":"GXBeam.element_linear_velocity","text":"element_linear_velocity(element, P, H)\n\nCalculate the linear velocity of a beam element given the linear and angular momenta\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_angular_velocity","page":"Library","title":"GXBeam.element_angular_velocity","text":"element_angular_velocity(element, P, H)\n\nCalculate the angular velocity of a beam element given the linear and angular momenta\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_properties","page":"Library","title":"GXBeam.element_properties","text":"element_properties(x, icol, beam)\nelement_properties(x, icol, beam, x0, v0, ω0)\nelement_properties(x, icol, ibeam, beam, x0, v0, ω0, u, θ, udot, θdot)\nelement_properties(x, icol, ibeam, beam, x0, v0, ω0, udot, θdot_init, CtCabPdot, CtCabHdot, dt)\n\nExtract/calculate the properties of a specific beam element.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\nx: current state vector\nicol: starting index for the beam's state variables\nibeam: beam element index\nbeam: beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu: deflection variables for each beam element\nθ: rotation variables for each beam element\nudot: time derivative of u for each beam element\nθdot: time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot_init: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.dynamic_element_properties","page":"Library","title":"GXBeam.dynamic_element_properties","text":"dynamic_element_properties(x, icol, beam, x0, v0, ω0)\n\nExtract/Compute v, ω, P, H, V, and Ω.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_equations","page":"Library","title":"GXBeam.element_equations","text":"element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ)\nelement_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, v, ω, P, H, V, Ω)\nelement_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, v, ω, P, H, V, Ω,\n    udot, θdot, CtCabPdot, CtCabHdot)\n\nEvaluate the nonlinear equations for a beam element.\n\nThere are three implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step or Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments:\n\nΔL: Length of the beam element\nCt: Rotation tensor of the beam deformation in the \"a\" frame, transposed\nCab: Direction cosine matrix from \"a\" to \"b\" frame for the element\nCtCab: C'*Cab, precomputed for efficiency\nu: Displacement variables for the element [u1, u2, u3]\nθ: Rotation variables for the element [θ1, θ2, θ3]\nF: Force variables for the element [F1, F2, F3]\nM: Moment variables for the element [M1, M2, M3]\nγ: Engineering strains in the element [γ11, 2γ12, 2γ13]\nκ: Curvatures in the element [κ1, κ2, κ3]\n\nAdditional Arguments for Dynamic Analyses\n\nv: Linear velocity of element in global frame \"a\" [v1, v2, v3]\nω: Angular velocity of element in global frame \"a\" [ω1, ω2, ω3]\nP: Linear momenta for the element [P1, P2, P3]\nH: Angular momenta for the element [H1, H2, H3]\nV: Velocity of the element\nΩ: Rotational velocity of the element\n\nAdditional Arguments for Initial Step Analysis\n\nudot: user-specified time derivative of u\nθdot: user-specified time derivative of θ\nCtCabPdot: C'CabPdot state variable\nCtCabHdot: C'CabHdot state variable\n\nAdditional Arguments for Time Marching Analysis\n\nudot: 2/dt*(u-u_p) - udot_p for this beam element where _p denotes values   taken from the previous time step\nθdot: 2/dt*(θ-θ_p) - θdot_p for this beam element where _p denotes values   taken from the previous time step\nCtCabPdot: 2/dt*(C'*Cab*P - (C'*Cab*P)_p) - (C'*Cab*Pdot)_p for this beam   element where _p denotes values taken from the previous time step\nCtCabHdot: 2/dt*(C'*Cab*H - (C'*Cab*H)_p) - (C'*Cab*Hdot)_p for this beam   element where _p denotes values taken from the previous time step\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.insert_element_residual!","page":"Library","title":"GXBeam.insert_element_residual!","text":"insert_element_residual!(resid, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, f_u1, f_u2, f_ψ1,\n    f_ψ2, f_F1, f_F2, f_M1, f_M2)\ninsert_element_residual!(resid, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, f_u1, f_u2, f_ψ1,\n    f_ψ2, f_F1, f_F2, f_M1, f_M2, f_P, f_H)\n\nInsert beam element resultants into the residual equation.  Initialize equilibrium and constitutive equations if they are not yet initialized.\n\nIf irow_b1 != irow_p1 and/or irow_b2 != irow_p2, assume the equilibrium equations for the left and/or right side are already initialized\n\nThere are two implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State, Initial Step, or Time Marching\n\nArguments\n\nresid: System residual vector\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b1: Row index of the first equation for the right side of the beam element   (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p2: Row index of the first equation for the point on the right side of the beam element\nf_u1, f_u2: Resultant displacements for the left and right side of the beam element, respectively\nf_ψ1, f_ψ2: Resultant rotations for the left and right side of the beam element, respectively\nf_F1, f_F2: Resultant forces for the left and right side of the beam element, respectively\nf_M1, f_M2: Resultant moments for the left and right side of the beam element, respectively\n\nAdditional Arguments for Dynamic Analyses\n\nf_P: Resultant linear momenta of the beam element\nf_H: Resultant angular momenta of the beam element\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_residual!","page":"Library","title":"GXBeam.element_residual!","text":"element_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,\n    irow_b1, irow_p1, irow_b2, irow_p2)\nelement_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,\n    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0)\nelement_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,\n    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, u0, θ0, udot0, θdot0)\nelement_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,\n    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, udot_init, θdot_init,\n    CtCabPdot_init, CtCabHdot_init, dt)\n\nCompute and add a beam element's contributions to the residual vector\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\nresid: System residual vector\nx: current state vector\nibeam: beam element index\nbeam: beam element\ndistributed_loads: dictionary with all distributed loads\nistep: current time step\nicol: starting index for the beam's state variables\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b2: Row index of the first equation for the right side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p2: Row index of the first equation for the point on the right side of the beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu0: initial deflection variables for each beam element\nθ0: initial rotation variables for each beam element\nudot0: initial time derivative of u for each beam element\nθdot0: initial time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot_init: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_jacobian_equations","page":"Library","title":"GXBeam.element_jacobian_equations","text":"element_jacobian_equations(beam, ΔL, Ct, Cab, CtCab, θ, F, M, γ, κ, Ct_θ1,\n    Ct_θ2, Ct_θ3)\nelement_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, M, γ, κ, ω, P, H, V,\n    Ct_θ1, Ct_θ2, Ct_θ3)\nelement_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, γ, ω, P, V, θdot)\nelement_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, M, γ, κ, ω, P, H, V,\n    θdot, dt, Ct_θ1, Ct_θ2, Ct_θ3)\n\nFind the jacobians of the nonlinear equations for a beam element with respect to the state variables given the distributed loads on the beam element and the beam element's properties.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments:\n\nbeam: Beam element\nΔL: Length of the beam element\nCt: Rotation tensor of the beam deformation in the \"a\" frame, transposed\nCab: Direction cosine matrix from \"a\" to \"b\" frame for the element\nCtCab: C'*Cab, precomputed for efficiency\nu: Displacement variables for the element [u1, u2, u3]\nθ: Rotation variables for the element [θ1, θ2, θ3]\nF: Force variables for the element [F1, F2, F3]\nM: Moment variables for the element [M1, M2, M3]\nγ: Engineering strains in the element [γ11, 2γ12, 2γ13]\nκ: Curvatures in the element [κ1, κ2, κ3]\nCt_θ1: Gradient of Ct w.r.t. θ[1]\nCt_θ2: Gradient of Ct w.r.t. θ[2]\nCt_θ3: Gradient of Ct w.r.t. θ[3]\nf1_θ: Gradient w.r.t. θ of integrated distributed force for left side of element\nm1_θ: Gradient w.r.t. θ of integrated distributed moment for left side of element\nf2_θ: Gradient w.r.t. θ of integrated distributed force for right side of element\nm2_θ: Gradient w.r.t. θ of integrated distributed moment for right side of element\n\nAdditional Arguments for Dynamic Analyses\n\nv: Linear velocity of element in global frame \"a\" [v1, v2, v3]\nω: Angular velocity of element in global frame \"a\" [ω1, ω2, ω3]\nP: Linear momenta for the element [P1, P2, P3]\nH: Angular momenta for the element [H1, H2, H3]\nV: Velocity of the element\nΩ: Rotational velocity of the element\n\nAdditional Arguments for Initial Step Analyses\n\nudot: user-specified time derivative of u for this beam element\nθdot: user-specified time derivative of θ for this beam element\nCtCabPdot: C'*Cab*Pdot (which is a state variable for the initial step analysis)\nCtCabHdot: C'*Cab*Hdot (which is a state variable for the initial step analysis)\n\nAdditional Arguments for Time Marching Analyses\n\nudot: -2/dt*u - udot for each beam element from the previous time step\nθdot_init: -2/dt*θ - θdot for each beam element from the previous time step\nCtCabPdot: -2/dt*C'*Cab*P - C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot: -2/dt*C'*Cab*H - C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.insert_element_jacobian!","page":"Library","title":"GXBeam.insert_element_jacobian!","text":"insert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,\n    f_u1_θ, f_u2_θ, f_u1_F, f_u2_F,\n    f_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M,\n    f_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,\n    f_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M)\ninsert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,\n    f_u1_θ, f_u2_θ, f_u1_F, f_u2_F, f_u1_P, f_u2_P,\n    f_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, f_ψ1_P, f_ψ2_P, f_ψ1_H, f_ψ2_H,\n    f_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,\n    f_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M,\n    f_P_u, f_P_θ, f_P_P, f_P_H,\n    f_H_θ, f_H_P, f_H_H)\ninsert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,\n    f_u1_CtCabPdot, f_u2_CtCabPdot, f_u1_F, f_u2_F, f_u1_P, f_u2_P,\n    f_ψ1_CtCabHdot, f_ψ2_CtCabHdot, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, f_ψ1_P, f_ψ2_P, f_ψ1_H, f_ψ2_H,\n    f_F1_F, f_F2_F, f_F1_M, f_F2_M,\n    f_M1_F, f_M2_F, f_M1_M, f_M2_M,\n    f_P_P, f_P_H,\n    f_H_P, f_H_H)\n\nInsert the the beam element jacobian entries into the jacobian matrix\n\nThere are three implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State or Time Marching\nDynamic - Initial Step (for initializing time domain simulations)\n\nArguments\n\njacob: System jacobian matrix\nicol_p1: Row/column index of the first unknown for the left endpoint (a value <= 0 indicates the unknowns have been eliminated from the system of equations)\nirow_b1: Row index of the first equation for the left side of the beam\nirow_p1: Row index of the first equation for the point on the left side of the beam\nicol_p2: Row/column index of the first unknown for the right endpoint   (a value <= 0 indicates the unknowns have been eliminated from the system of equations)\nirow_b2: Row index of the first equation for the right side of the beam\nirow_p2: Row index of the first equation for the point on the right side of the beam\nicol: Row/Column index corresponding to the first beam state variable\n\nAll other arguments use the following naming convention:\n\nf_y_x: Jacobian of element equation \"y\" with respect to state variable \"x\"\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_jacobian!","page":"Library","title":"GXBeam.element_jacobian!","text":"element_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,\n    irow_b1, irow_p1, irow_b2, irow_p2)\nelement_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,\n    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0)\nelement_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,\n    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, u0, θ0, udot0, θdot0)\nelement_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,\n    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, udot_init, θdot_init,\n    CtCabPdot_init, CtCabHdot_init, dt)\n\nAdds a beam element's contributions to the jacobian matrix\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: System jacobian matrix\nx: current state vector\nibeam: beam element index\nbeam: beam element\ndistributed_loads: dictionary with all distributed loads\nistep: current time step\nicol: starting index for the beam's state variables\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b2: Row index of the first equation for the right side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p2: Row index of the first equation for the point on the right side of the beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu0: initial deflection variables for each beam element\nθ0: initial rotation variables for each beam element\nudot0: initial time derivative of u for each beam element\nθdot0: initial time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot_init: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_mass_matrix_properties","page":"Library","title":"GXBeam.element_mass_matrix_properties","text":"element_mass_matrix_properties(x, icol, beam)\n\nExtract/Compute the properties needed for mass matrix construction: ΔL, Ct, Cab, CtCab, θ, P, H, Ctdot_cdot1, Ctdot_cdot2, and Ctdot_cdot3\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_mass_matrix_equations","page":"Library","title":"GXBeam.element_mass_matrix_equations","text":"element_mass_matrix_equations(ΔL, Ct, Cab, CtCab, θ, P, H)\n\nCalculates the jacobians of the nonlinear equations for a beam element with respect to the time derivatives of the state variables.\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments:\n\nΔL: Length of the beam element\nCt: Rotation tensor of the beam deformation in the \"a\" frame, transposed\nCab: Direction cosine matrix from \"a\" to \"b\" frame for the element\nθ: Rotation variables for the element [θ1, θ2, θ3]\nP: Linear momenta for the element [P1, P2, P3]\nH: Angular momenta for the element [H1, H2, H3]\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.insert_element_mass_matrix!","page":"Library","title":"GXBeam.insert_element_mass_matrix!","text":"insert_element_mass_matrix!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,\n    f_u1_θdot, f_u2_θdot, f_u1_Pdot, f_u2_Pdot, f_ψ1_θdot, f_ψ2_θdot,\n    f_ψ1_Hdot, f_ψ2_Hdot, f_P_udot, f_H_θdot)\n\nInsert the beam element's contributions into the \"mass matrix\": the jacobian of the residual equations with respect to the time derivatives of the state variables\n\nArguments\n\njacob: System jacobian matrix (mass matrix)\nirow_b1: Row index of the first equation for the left side of the beam\nirow_p1: Row index of the first equation for the point on the left side of the beam\nirow_b2: Row index of the first equation for the right side of the beam\nirow_p2: Row index of the first equation for the point on the right side of the beam\nicol: Row/Column index corresponding to the first beam state variable\n\nAll other arguments use the following naming convention:\n\nf_y_x: Jacobian of element equation \"y\" with respect to state variable \"x\"\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_mass_matrix!","page":"Library","title":"GXBeam.element_mass_matrix!","text":"element_mass_matrix!(jacob, x, beam, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2)\n\nAdd the beam element's contributions to the \"mass matrix\": the jacobian of the residual equations with respect to the time derivatives of the state variables\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: System jacobian matrix\nx: current state vector\nbeam: beam element\nicol: starting index for the beam's state variables\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b2: Row index of the first equation for the right side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p2: Row index of the first equation for the point on the right side of the beam element\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.ElementState","page":"Library","title":"GXBeam.ElementState","text":"ElementState\n\nHolds the state variables for an element\n\nFields:\n\nu: Displacement variables for the element (in the global coordinate frame)\ntheta: Wiener-Milenkovic rotational displacement variables for the element\nF: Resultant forces for the element (in the deformed beam coordinate frame)\nM: Resultant moments for the element (in the deformed beam coordinate frame)\nP: Linear momenta of the element (in the deformed beam coordinate frame)\nH: Angular momenta of the element (in the deformed beam coordinate frame)\n\n\n\n\n\n","category":"type"},{"location":"library/#Loads","page":"Library","title":"Loads","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GXBeam.PrescribedConditions\nGXBeam.DistributedLoads","category":"page"},{"location":"library/#GXBeam.PrescribedConditions","page":"Library","title":"GXBeam.PrescribedConditions","text":"PrescribedConditions{T}\n\nDescribes the forces, moments, displacements, and/or rotations prescribed at a point for each time step\n\n\n\n\n\n","category":"type"},{"location":"library/#GXBeam.DistributedLoads","page":"Library","title":"GXBeam.DistributedLoads","text":"DistributedLoads{T}\n\nContains the integrated distributed forces and moments for each beam element for each time step.\n\nFields\n\nf1: Integrated non-follower distributed force for the beam element's left endpoint for each time step\nf2: Integrated non-follower distributed force for the beam element's right endpoint for each time step\nm1: Integrated non-follower distributed moment for the beam element's left endpoint for each time step\nm2: Integrated non-follower distributed moment for the beam element's right endpoint for each time step\nf1_follower: Integrated follower distributed force for the beam element's left endpoint for each time step\nf2_follower: Integrated follower distributed force for the beam element's right endpoint for each time step\nm1_follower: Integrated follower distributed moment for the beam element's left endpoint for each time step\nm2_follower: Integrated follower distributed moment for the beam element's right endpoint for each time step\n\n\n\n\n\n","category":"type"},{"location":"library/#System","page":"Library","title":"System","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GXBeam.Assembly\nGXBeam.curve_triad\nGXBeam.curve_coordinates\nGXBeam.System\nGXBeam.point_connections\nGXBeam.system_indices\nGXBeam.system_residual!\nGXBeam.system_jacobian!\nGXBeam.system_mass_matrix!","category":"page"},{"location":"library/#GXBeam.Assembly","page":"Library","title":"GXBeam.Assembly","text":"Assembly{TF, TP<:AbstractVector{<:AbstractVector{TF}}, TC<:AbstractVector{<:Integer}, TE<:AbstractVector{Element{TF}}}\n\nComposite type that defines an assembly of connected nonlinear beam elements for analysis.\n\nFields\n\npoints: Array of all beam element endpoints\nstart: Array containing point index where each beam element starts\nstop: Array containing point index where each beam element stops\nelement: Array of Elements\n\n\n\n\n\n","category":"type"},{"location":"library/#GXBeam.curve_triad","page":"Library","title":"GXBeam.curve_triad","text":"curve_triad(Cab, k, s)\ncurve_triad(Cab, kkt, ktilde, kn, s)\n\nReturn the rotation matrix at s along the length of the beam given the curvature vector k and the initial rotation matrix Cab.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.curve_coordinates","page":"Library","title":"GXBeam.curve_coordinates","text":"curve_coordiantes(r, Cab, k, s)\ncurve_coordinates(r, Cab, kkt, ktilde, kn, s)\n\nReturn the coordinates at s along the length of the beam given the starting point r, initial rotation matrix Cab, and curvature vector k.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.System","page":"Library","title":"GXBeam.System","text":"System{TF, TV<:AbstractVector{TF}, TM<:AbstractMatrix{TF}, TTF<:AbstractVector{TF}}\n\nContains the system state, residual vector, and jacobian matrices as well as pointers to be able to access their contents.  Also contains additional storage needed for time domain simulations.\n\nFields:\n\nstatic: Flag indicating whether system matrices are only valid for static analyses\nx: State vector\nr: Residual vector\nK: System jacobian matrix with respect to the state variables\nM: System jacobian matrix with respect to the time derivative of the state variables\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Row/Column index of first state variable for each point\nicol_beam: Row/Column index of first state variable for each beam element\ncurrent_step: Current time step\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot_init: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\n\n\n\n\n\n","category":"type"},{"location":"library/#GXBeam.point_connections","page":"Library","title":"GXBeam.point_connections","text":"point_connections(assembly)\n\nCount the number of beams connected to each point\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.system_indices","page":"Library","title":"GXBeam.system_indices","text":"system_indices(assembly, points, n_connections, static)\n\nSolve for the row indices of the first equilibrium or compatability equations for each point and side of each beam element.  Also solve for the row/column index of each point and beam state variable.\n\nNote that this function includes the following logic which reduces the size of the system of equations where possible (without sacrificing any accuracy):\n\nIf only two beams meet at a point, the 6 unknowns associated with that point as well as the 6 compatability equations are eliminated from the system, except if specified in the array points.  Points for which unknowns have been eliminated are assigned a column index of -1.  Beams for which the compatability equations have been eliminated are also assigned an index of -1\n\nArguments:\n\nassembly: Assembly of rigidly connected nonlinear beam elements\npoints: Point indices which should be preserved in the system matrices\nn_connections: Number of connections to each point\nstatic: flag indicating whether analysis is static\n\nReturn Arguments:\n\nn: total number of equations/unknowns in the system\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.system_residual!","page":"Library","title":"GXBeam.system_residual!","text":"system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam)\nsystem_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0)\nsystem_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0,\n    u, θ, udot, θdot)\nsystem_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0,\n    udot, θdot_init, CtCabPdot, CtCabHdot, dt)\n\nPopulate the residual vector resid with the results of the residual equations for the system.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by  Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using  Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\nresid: System residual vector\nx: Current state variables of the system\nassembly: Assembly of rigidly connected nonlinear beam elements\nprescribed_conditions: Dictionary of prescribed conditions at all time steps\ndistributed_loads: Dictionary of distributed loads at all time steps\nistep: Current time step\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu: deflection variables for each beam element\nθ: rotation variables for each beam element\nudot: time derivative of u for each beam element\nθdot: time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot: -2/dt*u - udot for each beam element from the previous time step\nθdot_init: -2/dt*θ - θdot for each beam element from the previous time step\nCtCabPdot: -2/dt*C'*Cab*P - C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot: -2/dt*C'*Cab*H - C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.system_jacobian!","page":"Library","title":"GXBeam.system_jacobian!","text":"system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam)\nsystem_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n    x0, v0, ω0)\nsystem_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n    x0, v0, ω0, u, θ, udot, θdot)\nsystem_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n    x0, v0, ω0, udot_init, θdot_init, CtCabPdot_init, CtCabHdot_init, dt)\n\nPopulate the jacobian matrix jacob with the jacobian of the residual vector with respect to the state variables.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by  Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using  Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: Jacobian matrix\nx: Vector containing current state variables of the system\nassembly: Assembly of rigidly connected nonlinear beam elements\nprescribed_conditions: Dictionary of prescribed conditions at all time steps\ndistributed_loads: Dictionary of distributed loads at all time steps\nistep: Current time step\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu: deflection variables for each beam element\nθ: rotation variables for each beam element\nudot: time derivative of u for each beam element\nθdot: time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot: -2/dt*u - udot for each beam element from the previous time step\nθdot_init: -2/dt*θ - θdot for each beam element from the previous time step\nCtCabPdot: -2/dt*C'*Cab*P - C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot: -2/dt*C'*Cab*H - C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.system_mass_matrix!","page":"Library","title":"GXBeam.system_mass_matrix!","text":"system_mass_matrix!(jacob, x, assembly, irow_pt, irow_beam, irow_beam1,\n    irow_beam2, icol_pt, icol_beam)\n\nPopulate the system \"mass matrix\", the jacobian of the residual vector with respect to the time derivatives of the state variables.\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: Jacobian matrix\nx: Vector containing current state variables of the system\nassembly: Assembly of rigidly connected nonlinear beam elements\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\n\n\n\n\n","category":"function"},{"location":"library/#Index","page":"Library","title":"Index","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples show how to use the various analysis capabilities of GXBeam.  Many of these examples also provide a verification/validation for the implementation of geometrically exact beam theory in GXBeam.  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 3","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# this is placed here to pre-install matplotlib so the documentation doesn't get cluttered with the installation print statements.\nusing Plots\npyplot()","category":"page"},{"location":"examples/#Linear-Analysis-of-a-Cantilever-Partially-Under-a-Uniform-Distributed-Load","page":"Examples","title":"Linear Analysis of a Cantilever Partially Under a Uniform Distributed Load","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a cantilever beam which is partially subjected to a uniform distributed load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# make sure error messages and warnings aren't printed in final documentation\nerr_rd, err_wr = redirect_stderr()","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nerr_rd, err_wr = redirect_stderr() #nothing\n\nusing GXBeam, LinearAlgebra\n\nnelem = 12\n\n# create points\na = 0.3\nb = 0.7\nL = 1.0\nn1 = n3 = div(nelem, 3)\nn2 = nelem - n1 - n3\nx1 = range(0, 0.3, length=n1+1)\nx2 = range(0.3, 0.7, length=n2+1)\nx3 = range(0.7, 1.0, length=n3+1)\nx = vcat(x1, x2[2:end], x3[2:end])\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints for each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# create compliance matrix for each beam element\nEI = 1e9\ncompliance = fill(Diagonal([0, 0, 0, 0, 1/EI, 0]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# set prescribed conditions (fixed right endpoint)\nprescribed_conditions = Dict(\n    nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n)\n\n# create distributed load\nq = 1000\ndistributed_loads = Dict()\nfor ielem in n1+1:n1+n2\n    distributed_loads[ielem] = DistributedLoads(assembly, ielem; fz = (s) -> q)\nend\n\nsystem, converged = static_analysis(assembly, prescribed_conditions=prescribed_conditions,\n    distributed_loads=distributed_loads, linear=true)\n\nstate = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can construct the analytical solution for this problem by integrating from the free end of the beam and applying the appropriate boundary conditions.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# construct analytical solution\ndx = 1e-6\nx_a = 0.0:dx:L\nq_a = (x) -> a <= x <= b ? -q : 0 # define distributed load\nV_a = cumsum(-q_a.(x_a) .* dx) # integrate to get shear\nM_a = cumsum(V_a .* dx) # integrate to get moment\nslope_a = cumsum(M_a./EI .* dx) # integrate to get slope\nslope_a .-= slope_a[end] # apply boundary condition\ndeflection_a = cumsum(slope_a .* dx) # integrate to get deflection\ndeflection_a .-= deflection_a[end] # apply boundary condition\n\n# get elastic twist angle\ntheta_a = -atan.(slope_a)\n\n# adjust coordinate system of the analytical solution to match the computational solution\nM_a = -M_a\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational solutions show excellent agreement.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\n# deflection plot\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Deflection (m)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint = 1:length(assembly.points)]\ndeflection = [state.points[ipoint].u[3] for ipoint = 1:length(assembly.points)]\nplot!(x_a, deflection_a, label=\"Analytical\")\nscatter!(x, deflection, label=\"GXBeam\")\n\nsavefig(\"linear-cantilever-pudl-1.svg\") #hide\n\n# elastic twist plot (euler angle)\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Rotation Parameter \\$\\\\theta_y\\$\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint = 1:length(assembly.points)]\ntheta = [4*atan.(state.points[ipoint].theta[2]/4) for ipoint = 1:length(assembly.points)]\nplot!(x_a, theta_a, label=\"Analytical\")\nscatter!(x, theta, label=\"GXBeam\")\n\nsavefig(\"linear-cantilever-pudl-2.svg\") #hide\n\n# bending moment plot\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Bending Moment (\\$Nm\\$)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.elements[ielem].x[1] + state.elements[ielem].u[1] for ielem = 1:length(assembly.elements)]\nM = [state.elements[ielem].M[2] for ielem = 1:length(assembly.elements)]\nplot!(x_a, M_a, label=\"Analytical\")\nscatter!(x, M, label=\"GXBeam\")\n\nsavefig(\"linear-cantilever-pudl-3.svg\") #hide\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that we could have easily performed a nonlinear analysis for this problem by setting linear=false.","category":"page"},{"location":"examples/#Linear-Analysis-of-a-Beam-Under-a-Linear-Distributed-Load","page":"Examples","title":"Linear Analysis of a Beam Under a Linear Distributed Load","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a beam which is clamped at one end and simply supported at the other end when subjected to a linear distributed load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\nnelem = 16\n\n# create points\nL = 1\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints for each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# create compliance matrix for each beam element\nEI = 1e7\ncompliance = fill(Diagonal([0, 0, 0, 0, 1/EI, 0]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# set prescribed conditions\nprescribed_conditions = Dict(\n    # simply supported left endpoint\n    1 => PrescribedConditions(uz=0),\n    # clamped right endpoint\n    nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n)\n\n# create distributed load\nqmax = 1000\ndistributed_loads = Dict()\nfor i = 1:nelem\n    distributed_loads[i] = DistributedLoads(assembly, i; s1=x[i],\n        s2=x[i+1], fz = (s) -> qmax*s)\nend\n\n# perform a static analysis\nsystem, converged = static_analysis(assembly, prescribed_conditions=prescribed_conditions,\n    distributed_loads=distributed_loads, linear=true)\n\n# post-process the results\nstate = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"An analytical solution to this over-determined problem can be found using the method of superposition using the analytical solutions to a cantilever with a linearly distributed load and a cantilever with an end load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# construct analytical solution\nx_a = range(0.0, L, length=1000)\nw_a = @. qmax*(1-x_a)^2/(120*EI)*(4 - 8*(1-x_a) + 5*(1-x_a)^2 - (1-x_a)^3)\nslope_a = @. -qmax*(1-x_a)/(120*EI)*(8 - 24*(1-x_a) + 20*(1-x_a)^2 - 5*(1-x_a)^3)\nM_a = @. qmax/120*(8 - 48*(1-x_a) + 60*(1-x_a)^2 - 20*(1-x_a)^3)\n\ntheta_a = -atan.(slope_a)\n\n# adjust coordinate system of analytical solution\nM_a = -M_a\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational solutions show excellent agreement.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\n# set up the plot\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Deflection (m)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint = 1:length(assembly.points)]\ndeflection = [state.points[ipoint].u[3] for ipoint = 1:length(assembly.points)]\nplot!(x_a, w_a, label=\"Analytical\")\nscatter!(x, deflection, label=\"GXBeam\")\n\nsavefig(\"linear-overdetermined-ldl-1.svg\") #hide\n\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Rotation Parameter \\$\\\\theta_y\\$\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint = 1:length(assembly.points)]\ntheta = [4*atan.(state.points[ipoint].theta[2]/4) for ipoint = 1:length(assembly.points)]\nplot!(x_a, theta_a, label=\"Analytical\")\nscatter!(x, theta, label=\"GXBeam\")\n\nsavefig(\"linear-overdetermined-ldl-2.svg\") #hide\n\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Bending Moment (\\$Nm\\$)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.elements[ielem].x[1] + state.elements[ielem].u[1] for ielem = 1:length(assembly.elements)]\nM = [state.elements[ielem].M[2] for ielem = 1:length(assembly.elements)]\nplot!(x_a, M_a, label=\"Analytical\")\nscatter!(x, M, label=\"GXBeam\")\n\nsavefig(\"linear-overdetermined-ldl-3.svg\") #hide\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that we could have easily performed a nonlinear analysis for this problem by setting linear=false.","category":"page"},{"location":"examples/#Nonlinear-Analysis-of-a-Cantilever-Subjected-to-a-Constant-Tip-Load","page":"Examples","title":"Nonlinear Analysis of a Cantilever Subjected to a Constant Tip Load","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a cantilever beam that is subjected to a constant tip load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\nL = 1\nEI = 1e6\n\n# shear force (applied at end)\nλ = 0:0.5:16\np = EI/L^2\nP = λ*p\n\n# create points\nnelem = 16\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([0, 0, 0, 0, 1/EI, 0]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# pre-initialize system storage\nstatic = true\nkeep_points = [1, nelem+1] # points that we request are included in the system of equations\nsystem = System(assembly, keep_points, static)\n\n# run an analysis for each prescribed tip load\nstates = Vector{AssemblyState{Float64}}(undef, length(P))\nfor i = 1:length(P)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # shear force on right tip\n        nelem+1 => PrescribedConditions(Fz = P[i])\n    )\n\n    # perform a static analysis\n    static_analysis!(system, assembly, prescribed_conditions=prescribed_conditions)\n\n    # post-process the results\n    states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The analytical solution to this problem has been presented by several authors.  Here we follow the solution by H. J. Barten in \"On the Deflection of a Cantilever Beam\", after incorporating the corrections they submitted for finding the tip angle.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nimport Elliptic\n\nδ = range(pi/4, pi/2, length=10^5)[2:end-1]\n\nk = @. cos(pi/4)/sin(δ)\nλ_a = @. (Elliptic.F(pi/2, k^2) - Elliptic.F(δ,  k^2))^2\n\nθ_a = @. 2*(pi/4 - acos(k))\n\nξ_a = @. sqrt(2*sin(θ_a)/λ_a) .- 1\n\nη_a = @. 1-2/sqrt(λ_a)*(Elliptic.E(pi/2, k^2) - Elliptic.E(δ, k^2))\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational solutions show excellent agreement.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\nu = [states[i].points[end].u[1] for i = 1:length(P)]\nθ = [states[i].points[end].theta[2] for i = 1:length(P)]\nw = [states[i].points[end].u[3] for i = 1:length(P)]\n\n# set up the plot\nplot(\n    xlim = (0, 16),\n    xticks = 0:1:16,\n    xlabel = \"Nondimensional Force \\$\\\\left(\\\\frac{PL^2}{EI}\\\\right)\\$\",\n    ylim = (0, 1.2),\n    yticks = 0.0:0.2:1.2,\n    ylabel = \"Nondimensional Tip Displacements\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nplot!([Inf], [Inf], color=:black, label=\"Analytical\")\nscatter!([Inf], [Inf], color=:black, label=\"GXBeam\")\nplot!([Inf], [Inf], color=1, label=\"Vertical \\$\\\\left(w/L\\\\right)\\$\")\nplot!([Inf], [Inf], color=2, label=\"Horizontal \\$\\\\left(-u/L\\\\right)\\$\")\nplot!([Inf], [Inf], color=3, label=\"\\$ \\\\theta/(\\\\pi/2) \\$\")\n\nplot!(λ_a, η_a, color=1, label=\"\")\nscatter!(λ, w/L, color=1, label=\"\")\n\nplot!(λ_a, -ξ_a, color=2, label=\"\")\nscatter!(λ, -u/L, color=2, label=\"\")\n\nplot!(λ_a, θ_a*2/pi, color=3, label=\"\")\nscatter!(λ, -4*atan.(θ/4)*2/pi, color=3, label=\"\")\n\nsavefig(\"cantilever-tipforce.svg\"); nothing #hide\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Analysis-of-a-Cantilever-Subjected-to-a-Constant-Moment","page":"Examples","title":"Nonlinear Analysis of a Cantilever Subjected to a Constant Moment","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a cantilever beam that is subjected to a constant tip moment.  This is a common benchmark problem for the geometrically nonlinear analysis of beams.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\nL = 12 # inches\nh = w = 1 # inches\nE = 30e6 # lb/in^4 Young's Modulus\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\n\n# bending moment (applied at end)\nλ = [0.0, 0.4, 0.8, 1.2, 1.6, 1.8, 2.0]\nm = pi*E*Iyy/L\nM = λ*m\n\n# create points\nnelem = 16\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([1/(E*A), 0, 0, 0, 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# pre-initialize system storage\nstatic = true\nkeep_points = [1, nelem+1] # points that we request are included in the system of equations\nsystem = System(assembly, keep_points, static)\n\n# run an analysis for each prescribed bending moment\nstates = Vector{AssemblyState{Float64}}(undef, length(M))\nfor i = 1:length(M)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # moment on right side\n        nelem+1 => PrescribedConditions(Mz = M[i])\n    )\n\n    # perform a static analysis\n    static_analysis!(system, assembly, prescribed_conditions=prescribed_conditions)\n\n    # post-process the results\n    states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This problem has a simple analytical solution, which we obtained from \"Study of the Geometric Stiffening Effect: Comparison of Different Formulations\" by Juana M. Mayo, Daniel Garcia-Vallejo, and Jaime Dominguez.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# analytical solution (ρ = E*I/M)\nanalytical(x, ρ) = ifelse(ρ == Inf, zeros(3), [ρ*sin(x/ρ)-x, ρ*(1-cos(x/ρ)), 0])\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational results show excellent agreement.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\n# set up the plot\nplot(\n    xlim = (-0.25, 1.1),\n    xticks = -0.25:0.25:1.0,\n    xlabel = \"x/L\",\n    ylim = (-0.05, 0.8),\n    yticks = 0.0:0.2:0.8,\n    ylabel = \"y/L\",\n    aspect_ratio = 1.0,\n    grid = false,\n    overwrite_figure=false\n    )\n\n# create dummy legend entries for GXBeam and Analytical\nscatter!([NaN, NaN], [NaN, NaN], color=:black, label=\"GXBeam\")\nplot!([NaN, NaN], [NaN, NaN], color=:black, label=\"Analytical\")\n\n# plot the data\nfor i = 1:length(M)\n    local x, y #hide\n    # GXBeam\n    x = [assembly.points[ipoint][1] + states[i].points[ipoint].u[1] for ipoint = 1:length(assembly.points)]\n    y = [assembly.points[ipoint][2] + states[i].points[ipoint].u[2] for ipoint = 1:length(assembly.points)]\n    scatter!(x/L, y/L, label=\"\", color = i)\n\n    # Analytical\n    x0 = range(0, L, length=100)\n    deflection = analytical.(x0, E*Iyy/M[i])\n    x = (x0 + getindex.(deflection, 1))\n    y = getindex.(deflection, 2)\n    plot!(x/L, y/L, label=\"λ=$(λ[i])\", color=i)\nend\n\nsavefig(\"cantilever-tipmoment.svg\"); nothing #hide\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Analysis-of-the-Bending-of-a-Curved-Beam-in-3D-Space","page":"Examples","title":"Nonlinear Analysis of the Bending of a Curved Beam in 3D Space","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is also a common benchmark problem for the geometrically exact bending of nonlinear beams.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\n# problem constants\nR = 100\nL = R*pi/4 # inches\nh = w = 1 # inches\nE = 1e7 # psi Young's Modulus\nν = 0.0\nG = E/(2*(1+ν))\n\n# beam starting point, frame, and curvature\nstart = [0, 0, 0]\nframe = [0 -1 0; 1 0 0; 0 0 1]\ncurvature = [0, 0, -1/R]\n\n# cross section properties\nA = h*w\nAy = A\nAz = A\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\n# discretize the beam\nnelem = 16\nΔL, xp, xm, Cab = discretize_beam(L, start, nelem; frame=frame, curvature=curvature)\n\n# force\nP = 600 # lbs\n\n# index of left and right endpoints of each beam element\npt1 = 1:nelem\npt2 = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*J), 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(xp, pt1, pt2, compliance=compliance, frames=Cab,\n    lengths=ΔL, midpoints=xm)\n\n# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # fixed left endpoint\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    # force on right endpoint\n    nelem+1 => PrescribedConditions(Fz=P)\n)\n\n# perform static analysis\nsystem, converged = static_analysis(assembly, prescribed_conditions=prescribed_conditions)\n\n# post-process results\nstate = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nprintln(\"Tip Displacement: \", state.points[end].u)\nprintln(\"Tip Displacement (Bathe and Bolourch): [-13.4, -23.5, 53.4]\")\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The calculated tip displacements match those reported by Bathe and Bolourch in \"Large Displacement Analysis of Three-Dimensional Beam Structures\" closely, thus verifying our implementation of geometrically exact beam theory.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can visualize the deformed geometry and inspect the associated point and element data using ParaView.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"cantilever-curved\", assembly, state)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Rotating-Beam-with-a-Swept-Tip","page":"Examples","title":"Rotating Beam with a Swept Tip","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we analyze a rotating beam with a swept tip.  The parameters for this example come from \"Finite element solution of nonlinear intrinsic equations for curved composite beams\" by Hodges, Shang, and Cesnik.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\nsweep = 45 * pi/180\nrpm = 0:25:750\n\n# straight section of the beam\nL_b1 = 31.5 # inch\nr_b1 = [2.5, 0, 0]\nnelem_b1 = 13\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)\n\n# swept section of the beam\nL_b2 = 6 # inch\nr_b2 = [34, 0, 0]\nnelem_b2 = 3\ncs, ss = cos(sweep), sin(sweep)\nframe_b2 = [cs ss 0; -ss cs 0; 0 0 1]\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, frame=frame_b2)\n\n# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2\npoints = vcat(xp_b1, xp_b2[2:end])\nstart = 1:nelem_b1 + nelem_b2\nstop = 2:nelem_b1 + nelem_b2 + 1\nlengths = vcat(lengths_b1, lengths_b2)\nmidpoints = vcat(xm_b1, xm_b2)\nCab = vcat(Cab_b1, Cab_b2)\n\n# cross section\nw = 1 # inch\nh = 0.063 # inch\n\n# material properties\nE = 1.06e7 # lb/in^2\nν = 0.325\nρ = 2.51e-4 # lb sec^2/in^4\n\n# shear and torsion correction factors\nky = 1.2000001839588001\nkz = 14.625127919304001\nkt = 65.85255016982444\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\n# apply corrections\nAy = A/ky\nAz = A/kz\nJx = J/kt\n\nG = E/(2*(1+ν))\n\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\nmass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance, mass=mass, frames=Cab, lengths=lengths, midpoints=midpoints)\n\n# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # root section is fixed\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n    )\n\nnonlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nfor i = 1:length(rpm)\n    # global frame rotation\n    w0 = [0, 0, rpm[i]*(2*pi)/60]\n\n    # perform nonlinear steady state analysis\n    system, converged = steady_state_analysis(assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions)\n\n    nonlinear_states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\n    # perform linear steady state analysis\n    system, converged = steady_state_analysis(assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions,\n        linear = true)\n\n    linear_states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To visualize the solutions we will plot the root moment and tip deflections against the angular speed.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\n# root moment\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    yticks = 0.0:2:12,\n    ylabel = \"\\$M_z\\$ at the root (lb-in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nMz_nl = [-nonlinear_states[i].points[1].M[3] for i = 1:length(rpm)]\nMz_l = [-linear_states[i].points[1].M[3] for i = 1:length(rpm)]\nplot!(rpm, Mz_nl, label=\"Nonlinear\")\nplot!(rpm, Mz_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-Mz.svg\"); nothing #hide\n\n# x tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.002, 0.074),\n    yticks = 0.0:0.01:0.07,\n    ylabel = \"\\$u_x\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nux_nl = [nonlinear_states[i].points[end].u[1] for i = 1:length(rpm)]\nux_l = [linear_states[i].points[end].u[1] for i = 1:length(rpm)]\nplot!(rpm, ux_nl, label=\"Nonlinear\")\nplot!(rpm, ux_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-ux.svg\"); nothing #hide\n\n# y tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.01, 0.27),\n    yticks = 0.0:0.05:0.25,\n    ylabel = \"\\$u_y\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nuy_nl = [nonlinear_states[i].points[end].u[2] for i = 1:length(rpm)]\nuy_l = [linear_states[i].points[end].u[2] for i = 1:length(rpm)]\nplot!(rpm, uy_nl, label=\"Nonlinear\")\nplot!(rpm, uy_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-uy.svg\"); nothing #hide\n\n# rotation of the tip\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylabel = \"\\$θ_z\\$ at the tip\",\n    grid = false,\n    overwrite_figure=false\n    )\ntheta_z_nl = [4*atan(nonlinear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]\ntheta_z_l = [4*atan(linear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]\n\nplot!(rpm, theta_z_nl, label=\"Nonlinear\")\nplot!(rpm, theta_z_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-theta_z.svg\"); nothing #hide\n\nend #hide\n\nnothing #hide\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We will now compute the eigenvalues of this system for a range of sweep angles and and angular speeds.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nsweep = (0:2.5:45) * pi/180\nrpm = [0, 500, 750]\nnev = 30\n\nλ = Matrix{Vector{ComplexF64}}(undef, length(sweep), length(rpm))\nU = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))\nMV = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))\nstate = Matrix{AssemblyState{Float64}}(undef, length(sweep), length(rpm))\neigenstates = Matrix{Vector{AssemblyState{ComplexF64}}}(undef, length(sweep), length(rpm))\nfor i = 1:length(sweep)\n    local L_b1, r_b1, nelem_b1, lengths_b1 #hide\n    local xp_b1, xm_b1, Cab_b1 #hide\n    local cs, ss #hide\n    local L_b2, r_b2, nelem_b2, frame_b2, lengths_b2 #hide\n    local xp_b2, xm_b2, Cab_b2 #hide\n    local nelem, points, start, stop #hide\n    local lengths, midpoints, Cab, compliance, mass, assembly #hide\n\n    # straight section of the beam\n    L_b1 = 31.5 # inch\n    r_b1 = [2.5, 0, 0]\n    nelem_b1 = 20\n    lengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)\n\n    # swept section of the beam\n    L_b2 = 6 # inch\n    r_b2 = [34, 0, 0]\n    nelem_b2 = 20\n    cs, ss = cos(sweep[i]), sin(sweep[i])\n    frame_b2 = [cs ss 0; -ss cs 0; 0 0 1]\n    lengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, frame=frame_b2)\n\n    # combine elements and points into one array\n    nelem = nelem_b1 + nelem_b2\n    points = vcat(xp_b1, xp_b2[2:end])\n    start = 1:nelem_b1 + nelem_b2\n    stop = 2:nelem_b1 + nelem_b2 + 1\n    lengths = vcat(lengths_b1, lengths_b2)\n    midpoints = vcat(xm_b1, xm_b2)\n    Cab = vcat(Cab_b1, Cab_b2)\n\n    compliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\n    mass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)\n\n    # create assembly\n    assembly = Assembly(points, start, stop, compliance=compliance, mass=mass, frames=Cab, lengths=lengths, midpoints=midpoints)\n\n    # create system\n    keep_points = [1, nelem_b1+1, nelem+1] # points that we request are included in the system of equations\n    system = System(assembly, keep_points, false)\n\n    for j = 1:length(rpm)\n        # global frame rotation\n        w0 = [0, 0, rpm[j]*(2*pi)/60]\n\n        # eigenvalues and (right) eigenvectors\n        system, λ[i,j], V, converged = eigenvalue_analysis!(system, assembly,\n            angular_velocity = w0,\n            prescribed_conditions = prescribed_conditions,\n            nev=nev)\n\n        # corresponding left eigenvectors\n        U[i,j] = left_eigenvectors(system, λ[i,j], V)\n\n        # post-multiply mass matrix with right eigenvector matrix\n        # (we use this later for correlating eigenvalues)\n        MV[i,j] = system.M * V\n\n        # process state and eigenstates\n        state[i,j] = AssemblyState(system, assembly; prescribed_conditions=prescribed_conditions)\n        eigenstates[i,j] = [AssemblyState(system, assembly, V;\n            prescribed_conditions=prescribed_conditions) for k = 1:nev]\n    end\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can correlate each eigenmode by taking advantage of the fact that left and right eigenvectors satisfy the following relationships:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginaligned\nu^H M v = 1 textif (u) and (v) correspond to the same eigenmode \nu^H M v = 0 textif (u) and (v) correspond to different eigenmodes\nendaligned","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# set previous left eigenvector matrix\nU_p = copy(U[1,1])\n\nfor j = 1:length(rpm)\n    for i = 1:length(sweep)\n        # construct correlation matrix\n        C = U_p*MV[i,j]\n\n        # correlate eigenmodes\n        perm, corruption = correlate_eigenmodes(C)\n\n        # re-arrange eigenvalues and eigenvectors\n        λ[i,j] = λ[i,j][perm]\n        U[i,j] = U[i,j][perm,:]\n        MV[i,j] = MV[i,j][:,perm]\n        eigenstates[i,j] = eigenstates[i,j][perm]\n\n        # update previous eigenvector matrix\n        U_p .= U[i,j]\n    end\n    # update previous eigenvector matrix\n    U_p .= U[1,j]\nend\n\nfrequency = [[imag(λ[i,j][k])/(2*pi) for i = 1:length(sweep), j=1:length(rpm)] for k = 2:2:nev]\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this case these eigenmode correlations work, but remember that large changes in the underlying parameters (or just drastic changes in the eigenvectors themselves due to a small perturbation) can cause these automatic eigenmode correlations to fail.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We'll now plot the frequency of the different eigenmodes against those found by Epps and Chandra in \"The Natural Frequencies of Rotating Composite Beams With Tip Sweep\".","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nnames = [\"First Bending Mode\", \"Second Bending Mode\", \"Third Bending Mode\"]\nindices = [1, 2, 4]\n\nexperiment_rpm = [0, 500, 750]\nexperiment_sweep = [0, 15, 30, 45]\nexperiment_frequencies = [\n    [1.4 1.8 1.7 1.6;\n     10.2 10.1 10.2 10.2;\n     14.8 14.4 14.9 14.7],\n    [10.3 10.2 10.4 10.4;\n     25.2 25.2 23.7 21.6;\n     36.1 34.8 30.7 26.1],\n    [27.7 27.2 26.6 24.8;\n     47.0 44.4 39.3 35.1;\n     62.9 55.9 48.6 44.8]\n]\n\nplot!([NaN, NaN], [NaN, NaN], color=:black, label=\"GXBeam\")\nscatter!([NaN, NaN], [NaN, NaN], color=:black, label=\"Experiment (Epps and Chandra)\")\n\nfor k = 1:length(indices)\n    plot(\n        title = names[k],\n        xticks = 0:15:45,\n        xlabel = \"Sweep Angle (degrees)\",\n        ylim = (0, Inf),\n        ylabel = \"Frequency (Hz)\",\n        grid = false,\n        overwrite_figure=false\n        )\n\n    for j = length(rpm):-1:1\n        plot!(sweep*180/pi, frequency[indices[k]][:,j], label=\"$(rpm[j]) RPM\", color=j)\n        scatter!(experiment_sweep, experiment_frequencies[k][j,:],\n            label=\"\", color=j)\n    end\n\n    plot!(show=true)\n    savefig(\"rotating-beam-frequencies-$(k).svg\") #hide\nend\n\nnames = [\"1T/5B\", \"5B/1T\", \"4B/1T\"]\nindices = [5, 7, 6]\n\nexperiment_frequencies = [\n    132.7 147.3 166.2 162.0\n    106.6 120.1 122.6 117.7;\n    95.4 87.5 83.7 78.8;\n]\n\nplot(\n    title = \"Coupled Torsion-Bending Modes at 750 RPM\",\n    xticks = 0:15:45,\n    xlabel = \"Sweep Angle (degrees)\",\n    ylim = (0, Inf),\n    ylabel = \"Frequency (Hz)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nplot!([NaN, NaN], [NaN, NaN], color=:black, label=\"GXBeam\")\nscatter!([NaN, NaN], [NaN, NaN], color=:black, label=\"Experiment (Epps and Chandra)\")\n\nfor k = 1:length(indices)\n    plot!(sweep*180/pi, frequency[indices[k]][:,end], label=names[k], color=k)\n    scatter!(experiment_sweep, experiment_frequencies[k,:],\n        label=\"\", color=k)\nend\n\nplot!(show=true)\n\nsavefig(\"rotating-beam-frequencies-4.svg\"); nothing #hide\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As you can see, the frequency results from the eigenmode analysis in this package compare well with experimental results.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also visualize eigenmodes using ParaView.  Here we will visualize the first bending mode for the 45 degree swept tip at a rotational speed of 750 RPM.  This can be helpful for identifying different eigenmodes.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"rotating-beam-45d-750rpm-bending-mode-1\", assembly, state[end,end], λ[end,end][1],\n    eigenstates[end,end][1], mode_scaling=100.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Dynamic-Analysis-of-a-Wind-Turbine-Blade","page":"Examples","title":"Nonlinear Dynamic Analysis of a Wind Turbine Blade","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\nL = 60 # m\n\n# create points\nnelem = 10\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# stiffness matrix for each beam element\nstiffness = fill(\n    [2.389e9  1.524e6  6.734e6 -3.382e7 -2.627e7 -4.736e8\n     1.524e6  4.334e8 -3.741e6 -2.935e5  1.527e7  3.835e5\n     6.734e6 -3.741e6  2.743e7 -4.592e5 -6.869e5 -4.742e6\n    -3.382e7 -2.935e5 -4.592e5  2.167e7 -6.279e5  1.430e6\n    -2.627e7  1.527e7 -6.869e5 -6.279e5  1.970e7  1.209e7\n    -4.736e8  3.835e5 -4.742e6  1.430e6  1.209e7  4.406e8],\n    nelem)\n\n# mass matrix for each beam element\nmass = fill(\n    [258.053      0.0        0.0      0.0      7.07839  -71.6871\n       0.0      258.053      0.0     -7.07839  0.0        0.0\n       0.0        0.0      258.053   71.6871   0.0        0.0\n       0.0       -7.07839   71.6871  48.59     0.0        0.0\n       7.07839    0.0        0.0      0.0      2.172      0.0\n     -71.6871     0.0        0.0      0.0      0.0       46.418],\n     nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop; stiffness=stiffness, mass=mass)\n\n# simulation time\ndt = 0.001\nt = 0:dt:2.0\nnstep = length(t)\n\n# prescribed conditions\nprescribed_conditions = Dict(\n    # fixed left side\n    1 => PrescribedConditions(dt; nstep=nstep, ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    # force on right side\n    nelem+1 => PrescribedConditions(dt; nstep=nstep, Fz=(t)->1e5*sin.(20*t))\n)\n\nsystem, history, converged = time_domain_analysis(assembly, dt; prescribed_conditions=prescribed_conditions, nstep=nstep)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can visualize tip displacements and the resultant forces in the root by accessing the post-processed results for each time step contained in the variable history.  Note that  the root resultant forces for this case are equal to the external forces/moments, but with opposite sign.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\npoint = vcat(fill(nelem+1, 6), fill(1, 6))\nfield = [:u, :u, :u, :theta, :theta, :theta, :F, :F, :F, :M, :M, :M]\ndirection = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\nylabel = [\"\\$u_x\\$ (\\$m\\$)\", \"\\$u_y\\$ (\\$m\\$)\", \"\\$u_z\\$ (\\$m\\$)\",\n    \"Rodriguez Parameter \\$\\\\theta_x\\$ (degree)\", \"Rodriguez Parameter \\$\\\\theta_y\\$ (degree)\", \"Rodriguez Parameter \\$\\\\theta_z\\$ (degree)\",\n    \"\\$F_x\\$ (\\$N\\$)\", \"\\$F_y\\$ (\\$N\\$)\", \"\\$F_z\\$ (\\$N\\$)\",\n    \"\\$M_x\\$ (\\$Nm\\$)\", \"\\$M_y\\$ (\\$Nm\\$)\", \"\\$M_z\\$ (\\$N\\$)\"]\n\nfor i = 1:12\n    local y #hide\n    plot(\n        xlim = (0, 2.0),\n        xticks = 0:0.5:2.0,\n        xlabel = \"Time (s)\",\n        ylabel = ylabel[i],\n        grid = false,\n        overwrite_figure=false\n        )\n    y = [getproperty(state.points[point[i]], field[i])[direction[i]] for state in history]\n\n    if field[i] == :theta\n        # convert to Rodriguez parameter\n        @. y = 4*atan(y/4)\n        # convert to degrees\n        @. y = rad2deg(y)\n    end\n\n    if field[i] == :F || field[i] == :M\n        y = -y\n    end\n\n    plot!(t, y, label=\"\")\n    plot!(show=true)\n    savefig(\"dynamic-wind-turbine-\"*string(field[i])*string(direction[i])*\".svg\"); nothing #hide\nend\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These plots are identical to those presented by Qi Wang, Wenbin Yu, and Michael A. Sprague in \"Geometric Nonlinear Analysis of Composite Beams Using Wiener-Milenkovic Parameters\".","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also visualize the time history of the system using ParaView.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"dynamic-wind-turbine\", assembly, history, dt)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Static-Analysis-of-a-Joined-Wing","page":"Examples","title":"Nonlinear Static Analysis of a Joined-Wing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we analyze joined-wing model proposed by Blair in \"An Equivalent Beam Formulation for Joined-Wings in a Post-Buckled State\" and optimized by Green et al. in \"Structural Optimization of Joined-Wing Beam Model with Bend-Twist Coupling using Equivalent Static Loads\".","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\n# Set endpoints of each beam\np1 = [-7.1726, -12, -3.21539]\np2 = [-5.37945, -9, -2.41154]\np3 = [-3.5863, -6, -1.6077]\np4 = [-1.79315, -3, -0.803848]\np5 = [0, 0, 0]\np6 = [7.1726, -12, 3.21539]\n\n# get rotation matrix for left beams\n\n# rotation about z in global frame\ntmp1 = sqrt(p1[1]^2 + p1[2]^2)\nc1, s1 = -p1[1]/tmp1, -p1[2]/tmp1\nrot1 = [c1 -s1 0; s1 c1 0; 0 0 1]\n\n# rotation about new y-axis to local frame\ntmp2 = sqrt(p1[1]^2 + p1[2]^2 + p1[3]^2)\nc2, s2 = tmp1/tmp2, -p1[3]/tmp2\nrot2 = [c2 0 -s2; 0 1 0; s2 0 c2]\n\n# get rotation matrix from local to global frame\nCab_1 = rot1*rot2\n\n# get rotation matrix for right beam\n\n# rotation about z in global frame\ntmp1 = sqrt(p6[1]^2 + p6[2]^2)\nc1, s1 = p6[1]/tmp1, p6[2]/tmp1\nrot1 = [c1 -s1 0; s1 c1 0; 0 0 1]\n\n# rotation about new y-axis to local frame\ntmp2 = sqrt(p6[1]^2 + p6[2]^2 + p6[3]^2)\nc2, s2 = tmp1/tmp2, p6[3]/tmp2\nrot2 = [c2 0 -s2; 0 1 0; s2 0 c2]\n\n# get rotation matrix from global to local frame\nCab_2 = rot1*rot2\n\n# beam 1\nL_b1 = norm(p2-p1)\nr_b1 = p1\nnelem_b1 = 5\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1, frame=Cab_1)\ncompliance_b1 = fill(Diagonal([1.05204e-9, 3.19659e-9, 2.13106e-8, 1.15475e-7, 1.52885e-7, 7.1672e-9]), nelem_b1)\n\n# beam 2\nL_b2 = norm(p3-p2)\nr_b2 = p2\nnelem_b2 = 5\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, frame=Cab_1)\ncompliance_b2 = fill(Diagonal([1.24467e-9, 3.77682e-9, 2.51788e-8, 1.90461e-7, 2.55034e-7, 1.18646e-8]), nelem_b2)\n\n# beam 3\nL_b3 = norm(p4-p3)\nr_b3 = p3\nnelem_b3 = 5\nlengths_b3, xp_b3, xm_b3, Cab_b3 = discretize_beam(L_b3, r_b3, nelem_b3, frame=Cab_1)\ncompliance_b3 = fill(Diagonal([1.60806e-9, 4.86724e-9, 3.24482e-8, 4.07637e-7, 5.57611e-7, 2.55684e-8]), nelem_b3)\n\n# beam 4\nL_b4 = norm(p5-p4)\nr_b4 = p4\nnelem_b4 = 5\nlengths_b4, xp_b4, xm_b4, Cab_b4 = discretize_beam(L_b4, r_b4, nelem_b4, frame=Cab_1)\ncompliance_b4 = fill(Diagonal([2.56482e-9, 7.60456e-9, 5.67609e-8, 1.92171e-6, 2.8757e-6, 1.02718e-7]), nelem_b4)\n\n# beam 5\nL_b5 = norm(p6-p5)\nr_b5 = p5\nnelem_b5 = 20\nlengths_b5, xp_b5, xm_b5, Cab_b5 = discretize_beam(L_b5, r_b5, nelem_b5, frame=Cab_2)\ncompliance_b5 = fill(Diagonal([2.77393e-9, 7.60456e-9, 1.52091e-7, 1.27757e-5, 2.7835e-5, 1.26026e-7]), nelem_b5)\n\n# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + nelem_b5\npoints = vcat(xp_b1, xp_b2[2:end], xp_b3[2:end], xp_b4[2:end], xp_b5[2:end])\nstart = 1:nelem\nstop = 2:nelem + 1\nlengths = vcat(lengths_b1, lengths_b2, lengths_b3, lengths_b4, lengths_b5)\nmidpoints = vcat(xm_b1, xm_b2, xm_b3, xm_b4, xm_b5)\nCab = vcat(Cab_b1, Cab_b2, Cab_b3, Cab_b4, Cab_b5)\ncompliance = vcat(compliance_b1, compliance_b2, compliance_b3, compliance_b4, compliance_b5)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance,\n    frames=Cab, lengths=lengths, midpoints=midpoints)\n\nFz = range(0, 70e3, length=141)\n\n# pre-allocate memory to reduce run-time\nijoint = nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1\npoints_to_keep = [1, ijoint, nelem+1]\nstatic = true\nsystem = System(assembly, points_to_keep, static)\n\nlinear_states = Vector{AssemblyState{Float64}}(undef, length(Fz))\nfor i = 1:length(Fz)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed endpoint on beam 1\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force applied on point 4\n        nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1 => PrescribedConditions(Fz = Fz[i]),\n        # fixed endpoint on last beam\n        nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    )\n\n    static_analysis!(system, assembly, prescribed_conditions=prescribed_conditions, linear=true)\n\n    linear_states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nend\n\nreset_state!(system)\nnonlinear_states = Vector{AssemblyState{Float64}}(undef, length(Fz))\nfor i = 1:length(Fz)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed endpoint on beam 1\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force applied on point 4\n        nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1 => PrescribedConditions(Fz = Fz[i]),\n        # fixed endpoint on last beam\n        nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    )\n\n    static_analysis!(system, assembly, prescribed_conditions=prescribed_conditions)\n\n    nonlinear_states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nend\n\nreset_state!(system)\nnonlinear_follower_states = Vector{AssemblyState{Float64}}(undef, length(Fz))\nfor i = 1:length(Fz)\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed endpoint on beam 1\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force applied on point 4\n        nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1 => PrescribedConditions(Fz_follower = Fz[i]),\n        # fixed endpoint on last beam\n        nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    )\n\n    static_analysis!(system, assembly, prescribed_conditions=prescribed_conditions)\n\n    nonlinear_follower_states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that we incrementally increased the load from 0 to 70 kN in order to ensure that we obtained converged solutions.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To visualize the differences between the different types of analyses we can plot the load deflection curve.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\nplot(\n    xlim = (0, 7),\n    xticks = 0:1:7,\n    xlabel = \"Vertical Displacement at the Joint (m)\",\n    yticks = 0:10:70,\n    ylim = (0, 70),\n    ylabel = \"Load (kN)\",\n    grid = false,\n    overwrite_figure=false\n    )\nuz_l = [linear_states[i].points[ijoint].u[3] for i = 1:length(Fz)]\nuz_nl = [nonlinear_states[i].points[ijoint].u[3] for i = 1:length(Fz)]\nuz_fnl = [nonlinear_follower_states[i].points[ijoint].u[3] for i = 1:length(Fz)]\n\nplot!(uz_l, Fz./1e3, label=\"Linear\")\nplot!(uz_nl, Fz./1e3, label=\"Nonlinear with Dead Force\")\nplot!(uz_fnl, Fz./1e3, label=\"Nonlinear with Follower Force\")\n\nsavefig(\"static-joined-wing.svg\"); nothing #hide\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This plot matches the plot provided by Wenbin Yu in \"GEBT: A general-purpose nonlinear analysis tool for composite beams\".","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also visualize the deformed geometry and inspect the associated point and element data for any of these operating conditions conditions using ParaView.  To demonstrate we will visualize the 70kN follower force condition and set the color gradient to match the magnitude of the deflections.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"static-joined-wing\", assembly, nonlinear_follower_states[end])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Dynamic-Analysis-of-a-Joined-Wing","page":"Examples","title":"Nonlinear Dynamic Analysis of a Joined-Wing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we use the same joined-wing model as used in the previous example, but with the following time varying loads applied at the wingtip:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A piecewise-linear load F_L in the x and y-directions defined as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"F_L(t) = begincases\n    t10^6 text N  0 leq t leq 001 \n    (002-t)10^6  001 leq t leq 002 \n    0  textotherwise\nendcases","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A sinusoidal load F_S applied in the z-direction defined as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"F_S(t) = begincases\n    0  t lt 0 \n    5 times 10^3 (1-cos(pi t 002)) text N  0 leq t lt 002 \n    10^4 text N  002 leq t\nendcases","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We will also use the same compliance and mass matrix for all beams, in order to simplify the problem definition.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\n# Set endpoints of each beam\np1 = [0, 0, 0]\np2 = [-7.1726, -12, -3.21539]\np3 = [7.1726, -12,  3.21539]\n\nCab_1 = [\n0.5         0.866025  0.0   \n0.836516    -0.482963  0.258819\n0.224144     -0.12941   -0.965926\n]\n\nCab_2 = [\n0.5         0.866025  0.0   \n-0.836516    0.482963 0.258819\n0.224144    -0.12941   0.965926\n]\n\n# beam 1\nL_b1 = norm(p1-p2)\nr_b1 = p2\nnelem_b1 = 8\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1, frame=Cab_1)\n\n# beam 2\nL_b2 = norm(p3-p1)\nr_b2 = p1\nnelem_b2 = 8\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, frame=Cab_2)\n\n# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2\npoints = vcat(xp_b1, xp_b2[2:end])\nstart = 1:nelem\nstop = 2:nelem + 1\nlengths = vcat(lengths_b1, lengths_b2)\nmidpoints = vcat(xm_b1, xm_b2)\nCab = vcat(Cab_b1, Cab_b2)\n\n# assign all beams the same compliance and mass matrix\ncompliance = fill(Diagonal([2.93944738387698e-10, 8.42991725049126e-10, 3.38313996669689e-08,\n    4.69246721094557e-08, 6.79584100559513e-08, 1.37068861370898e-09]), nelem)\nmass = fill(Diagonal([4.86e-2, 4.86e-2, 4.86e-2,\n    1.0632465e-2, 2.10195e-4, 1.042227e-2]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop; compliance=compliance, mass=mass,\n    frames=Cab, lengths=lengths, midpoints=midpoints)\n\n# time\nt = range(0, 0.04, length=1001)\ndt = t[2] - t[1]\nnstep = length(t)\n\nF_L = function(t)\n    if 0.0 <= t < 0.01\n        return 1e6*t\n    elseif 0.01 <= t < 0.02\n        return -1e6*(t-0.02)\n    else\n        return zero(t)\n    end\nend\n\nF_S = function(t)\n    if t < 0.0\n        return zero(t)\n    elseif 0.0 <= t < 0.02\n        return 5e3*(1-cos(pi*t/0.02))\n    else\n        return 1e4\n    end\nend\n\n# assign boundary conditions and point load\nprescribed_conditions = Dict(\n    # fixed endpoint on beam 1\n    1 => PrescribedConditions(dt; nstep=nstep, ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    # force applied on point 4\n    nelem_b1 + 1 => PrescribedConditions(dt; nstep=nstep, Fx=F_L, Fy=F_L, Fz=F_S),\n    # fixed endpoint on last beam\n    nelem+1 => PrescribedConditions(dt; nstep=nstep, ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n)\n\nsystem, history, converged = time_domain_analysis(assembly, dt; prescribed_conditions=prescribed_conditions, nstep=nstep)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can visualize tip displacements and the resultant forces accessing the post-processed results for each time step contained in the variable history.  Note that the fore-root and rear-root resultant forces for this case are equal to the external forces/moments, but with opposite sign.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\npoint = vcat(fill(nelem_b1+1, 6), fill(1, 6))\nfield = [:u, :u, :u, :theta, :theta, :theta, :F, :F, :F, :M, :M, :M]\ndirection = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\nylabel = [\"\\$u_x\\$ (\\$m\\$)\", \"\\$u_y\\$ (\\$m\\$)\", \"\\$u_z\\$ (\\$m\\$)\",\n    \"Rodriguez Parameter \\$\\\\theta_x\\$\", \"Rodriguez Parameter \\$\\\\theta_y\\$\", \"Rodriguez Parameter \\$\\\\theta_z\\$\",\n    \"\\$F_x\\$ at the forewing root (\\$N\\$)\", \"\\$F_y\\$ at the forewing root (\\$N\\$)\", \"\\$F_z\\$ at the forewing root (\\$N\\$)\",\n    \"\\$M_x\\$ at the forewing root (\\$Nm\\$)\", \"\\$M_y\\$ at the forewing root (\\$Nm\\$)\", \"\\$M_z\\$ at the forewing root (\\$N\\$)\"]\n\nfor i = 1:12\n    local y #hide\n    plot(\n        xlim = (0, 0.04),\n        xticks = 0:0.01:0.04,\n        xlabel = \"Time (s)\",\n        ylabel = ylabel[i],\n        grid = false,\n        overwrite_figure=false\n        )\n    y = [getproperty(state.points[point[i]], field[i])[direction[i]] for state in history]\n\n    if field[i] == :theta\n        # convert to angle\n        @. y = 4*atan(y/4)\n    end\n\n    if field[i] == :F || field[i] == :M\n        y = -y\n    end\n\n    plot!(t, y, label=\"\")\n    plot!(show=true)\n    savefig(\"dynamic-joined-wing-\"*string(field[i])*string(direction[i])*\".svg\"); nothing #hide\nend\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These graphs are identical to those presented in \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and Maxwell Blair.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also visualize the time history of the system using ParaView.  In order to view the small deflections we'll scale all the deflections up by a couple orders of magnitude.  We'll also set the color gradient to match the magnitude of the deflections at each point.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"dynamic-joined-wing\", assembly, history, dt, scaling=1e2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"#GXBeam","page":"Home","title":"GXBeam","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pure Julia Implementation of Geometrically Exact Beam Theory","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Taylor McDonnell","category":"page"},{"location":"","page":"Home","title":"Home","text":"GXBeam is a pure Julia implementation of Geometrically Exact Beam Theory, based on the open source code GEBT and its associated papers[1][2].","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a sample of one of the many things this package can do, here's a time domain simulation of the dynamic response of a joined wing subjected to a simulated gust, scaled up in order to visualize the deflections: (Image: )","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Performs multiple types of analyses including:\nLinear/Nonlinear static analyses\nLinear/Nonlinear steady-state dynamic analyses\nLinear/Nonlinear eigenvalue analyses (by linearizing about a steady state condition)\nLinear/Nonlinear time-marching dynamic analyses\nAccurately models arbitrary systems of interconnected highly flexible composite beams.\nCaptures all geometric nonlinearities due to large deflections and rotations\nCapable of using the full 6x6 Timoshenko beam stiffness matrix\nSingularity-free rotational deflections of any magnitude using only 3 rotational parameters\nModels arbitrary time-varying distributed forces/moments on beam elements using:\nDead forces/moments (which do not rotate as the beam element rotates)\nFollower forces/moments (which rotate as the beam element rotates)\nModels arbitrary time-varying prescribed forces/moments and/or displacements/rotations at the connection points between beam elements using:\nDead forces/moments (which do not rotate as the point rotates)\nFollower forces/moments (which rotate as the point rotates)\nCapable of using arbitrary units (as long as they are compatible)\nSimple result visualization using WriteVTK\nExtensively validated against published analytical and computational results. See the examples.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the package manager by typing ] and then run the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add GXBeam","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This code has been optimized to be highly performant, primarily by maintaining type stability and minimizing allocations.  As a result the performance of this package rivals (or even outperforms) that of the Fortran implementation in GEBT.  At this point, differences in performance between the two codes can be primarily attributed to the performance of the sparse linear system solver in each.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the examples","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that while the theoretical basis for this code is identical to Wenbin Yu's code, some of the implementation details vary.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Yu, W., & Blair, M. (2012). GEBT: A general-purpose nonlinear analysis tool for composite beams. Composite Structures, 94(9), 2677-2689.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Wang, Q., & Yu, W. (2017). Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters. Journal of Renewable and Sustainable Energy, 9(3), 033306.","category":"page"}]
}
