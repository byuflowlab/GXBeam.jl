var documenterSearchIndex = {"docs":
[{"location":"guide/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# this is placed here to pre-install matplotlib so the documentation doesn't get cluttered with the installation print statements.\nusing Plots\npyplot()","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"In this guide we introduce you to the basic functionality of this package in a step by step manner.  This is a good starting point for learning about how to use this package.  For more details about how to use a particular function the Public API is likely a better resource.  For more examples of how to use this package see the examples.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"If you haven't yet, now would be a good time to install GXBeam.  GXBeam can be installed from the Julia REPL by typing ] (to enter the package manager) and then running the following command.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"pkg> add GXBeam","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Now, that the package is installed we need to load it so that we can use it.  It's also often helpful to load the LinearAlgebra package.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using GXBeam, LinearAlgebra\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The geometry we will be working with is a rotating beam with a swept tip as pictured.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"This geometry has a fixed boundary condition on the left side of the beam and rotates around a point 2.5 inches to the left of the beam.  We will investigating the steady behavior of this system for a variety of RPM settings at a constant sweep of 45°.","category":"page"},{"location":"guide/#Creating-an-Assembly","page":"Getting Started","title":"Creating an Assembly","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The first step for any analysis is to create an object of type Assembly.  This object stores the properties of each of the points and beam elements in our model.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To create an object of type Assembly we need the following:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"An array of points\nThe starting point for each beam element\nThe ending point for each beam element\nThe stiffness or compliance matrix for each beam element\nThe mass or inverse mass matrix for each beam element (for dynamic simulations)\nRotation matrices for each beam element which transform from the global frame to the undeformed local beam frame.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"In case the beam elements are curved we can also manually provide the length and midpoint of each beam element.  This is not necessary for straight beam elements.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We will first focus on the geometry.  We start by defining the straight section of the beam.  This section extends from (2.5, 0, 0) to (34, 0, 0).  Its local undeformed coordinate frame is the same as the global coordinate frame.  We will discretize this section into 10 elements.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To aid with constructing the geometry we can use the discretize_beam function.  Here we will pass in the length, starting point, and number of elements.  The function returns the lengths, endpoints, midpoints, and frame of each beam element.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# straight section of the beam\nL_b1 = 31.5 # length of straight section of the beam in inches\nr_b1 = [2.5, 0, 0] # starting point of straight section of the beam\nnelem_b1 = 10 # number of elements in the straight section of the beam\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The lengths of each beam element is equal since we used the number of elements to define the discretization.  Alternatively we can manually specify the discretization of the section. The following is equivalent to the previous function call.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"disc_b1 = range(0, 1, length=nelem_b1+1) # normalized discretization in straight section of the beam\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, disc_b1)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We will now create the geometry for the swept portion of the wing.  To do so we use the same discretize_beam function, with an additional argument that allows us to specify a transformation matrix which performs a coordinate transformation from the undeformed local beam frame to the global frame.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"sweep = 45 * pi/180\n\n# swept section of the beam\nL_b2 = 6 # length of swept section of the beam\nr_b2 = [34, 0, 0] # starting point of swept section of the beam\nnelem_b2 = 5 # number of elements in swept section of the beam\ncs, ss = cos(sweep), sin(sweep)\nframe_b2 = [cs ss 0; -ss cs 0; 0 0 1] # transformation matrix from local to global frame\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, frame=frame_b2)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"If either of these beam sections were curved we would have also had to pass in a curvature vector to discretize_beam.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We will now manually combine the results of our two calls to discretize_beam.  Since the last endpoint from the straight section is the same as the first endpoint of the swept section we drop one of the endpoints when combining our results.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2 # total number of elements\npoints = vcat(xp_b1, xp_b2[2:end]) # all points in our assembly\nstart = 1:nelem_b1 + nelem_b2 # starting point of each beam element in our assembly\nstop = 2:nelem_b1 + nelem_b2 + 1 # ending point of each beam element in our assembly\nlengths = vcat(lengths_b1, lengths_b2) # length of each beam element in our assembly\nmidpoints = vcat(xm_b1, xm_b2) # midpoint of each beam element in our assembly\nCab = vcat(Cab_b1, Cab_b2) # transformation matrix from local to global frame\n                           # for each beam element in our assembly\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Next we need to define the stiffness (or compliance) and mass (or inverse mass) matrices for each beam element.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The compliance matrix is defined according to the following equation","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"beginbmatrix\ngamma_11 \n2gamma_12 \n2gamma_13 \nkappa_1 \nkappa_2 \nkappa_3\nendbmatrix\n=\nbeginbmatrix\n   S_11  S_12  S_13  S_14  S_15  S_16 \n   S_12  S_22  S_23  S_24  S_25  S_26 \n   S_13  S_23  S_33  S_34  S_35  S_36 \n   S_14  S_24  S_43  S_44  S_45  S_46 \n   S_15  S_25  S_35  S_45  S_55  S_56 \n   S_16  S_26  S_36  S_46  S_56  S_66\nendbmatrix\nbeginbmatrix\n   F_1 \n   F_2 \n   F_3 \n   M_1 \n   M_2 \n   M_3\nendbmatrix","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"with the variables defined as follows:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"gamma_11: beam axial strain\n2gamma_12 engineering transverse strain along axis 2\n2gamma_13 engineering transverse strain along axis 3\nkappa_1: twist\nkappa_2: curvature about axis 2\nkappa_3: curvature about axis 3\nF_i: resultant force about axis i\nM_i: resultant moment about axis i","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The elements of the mass matrix are defined as:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"beginbmatrix\n   mu  0  0  0  mu x_m3  -mu x_m2 \n   0  mu  0  -mu x_m3  0  0 \n   0  0  mu  mu x_m2  0  0 \n   0  -mu x_m3  mu x_m2  i_22 + i_33  0  0 \n   mu x_m3   0  0  0  i_22  -i_23 \n   -mu x_m2  0  0  0  -i_23  i_33\nendbmatrix","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"with the variables defined as follows:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"mu: mass per unit length\n(x_m2 x_m3): location of mass center\ni_22: mass moment of inertia about axis 2\ni_33: mass moment of inertia about axis 3\ni_23: product of inertia","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We assume that our beam has a constant cross section with the following properties:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"1 inch width\n0.063 inch height\n1.06 x 10^7 lb/in^2 elastic modulus\n0.325 Poisson's ratio\n2.51 x 10^-4 lb sec^2/in^4 density","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We also assume the following shear and torsion correction factors:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"k_y = 12000001839588001\nk_z = 14625127919304001\nk_t = 6585255016982444","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# cross section\nw = 1 # inch\nh = 0.063 # inch\n\n# material properties\nE = 1.06e7 # lb/in^2\nν = 0.325\nρ = 2.51e-4 # lb sec^2/in^4\n\n# shear and torsion correction factors\nky = 1.2000001839588001\nkz = 14.625127919304001\nkt = 65.85255016982444\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\n# apply corrections\nAy = A/ky\nAz = A/kz\nJx = J/kt\n\nG = E/(2*(1+ν))\n\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy),\n    1/(E*Izz)]), nelem)\n\nmass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Our case is simple enough that we can analytically calculate most values for the compliance and mass matrices, but this is not generally the case.  For more complex geometries/structures it may be necessary to use a cross-sectional property solver such as PreComp or VABS.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Also note that any row/column of the stiffness and/or compliance matrix which is zero will be interpreted as infinitely stiff in that degree of freedom.  This corresponds to a row/column of zeros in the compliance matrix.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We are now ready to put together our assembly.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"assembly = Assembly(points, start, stop;\n   compliance = compliance,\n   mass = mass,\n   frames = Cab,\n   lengths = lengths,\n   midpoints = midpoints)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"At this point this is probably a good time to check that the geometry of our assembly is correct.  We can do this by visualizing the geometry in ParaView.  We can use the write_vtk function to do this.  Note that in order to visualize the generated file yourself you will need to install ParaView separately.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"write_vtk(\"swept-tip\", assembly)","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/#Defining-Distributed-Loads","page":"Getting Started","title":"Defining Distributed Loads","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We won't be applying distributed loads to our model, but will demonstrate how to do so.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Distributed loads are defined by using the constructor DistributedLoads.  One instance of DistributedLoads must be created for every beam element on which the distributed load is applied.  These instances of DistributedLoads are then stored in a dictionary in which they are accessed by their beam element index.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To define a DistributedLoad the assembly, element number, and distributed load functions must be passed to distributed_loads.  Possible distributed load functions are:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"fx: Distributed non-follower force on beam element in x-direction\nfy: Distributed non-follower force on beam element in y-direction\nfz: Distributed non-follower force on beam element in z-direction\nmx: Distributed non-follower moment on beam element in x-direction\nmy: Distributed non-follower moment on beam element in y-direction\nmz: Distributed non-follower moment on beam element in z-direction\nfx_follower: Distributed follower force on beam element in x-direction\nfy_follower: Distributed follower force on beam element in y-direction\nfz_follower: Distributed follower force on beam element in z-direction\nmx_follower: Distributed follower moment on beam element in x-direction\nmy_follower: Distributed follower moment on beam element in y-direction\nmz_follower: Distributed follower moment on beam element in z-direction","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Each of these forces/moments are specified as functions of the arbitrary coordinate s (f(s)).  The s-coordinate at the start and end of the beam element can be specified using the keyword arguments s1 and s2.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For example, the following code applies a uniform 10 pound distributed load in the global z-direction on all beam elements:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"distributed_loads = Dict()\nfor ielem in 1:nelem\n    distributed_loads[ielem] = DistributedLoads(assembly, ielem; fz = (s) -> 10)\nend\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To instead make this a follower force (a force that rotates with the structure) we would use the following code:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"distributed_loads = Dict()\nfor ielem in 1:nelem\n    distributed_loads[ielem] = DistributedLoads(assembly, ielem;\n        fz_follower = (s) -> 10)\nend\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The units are arbitrary, but must be consistent with the units used when constructing assembly.  Also note that both non-follower and follower forces may exist simultaneously.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"It is worth noting that the distributed loads are integrated over each element when they are created using 4-point Gauss-Legendre quadrature.  If more control over the integration is desired one may specify a custom integration method as described in the documentation for DistributedLoads.","category":"page"},{"location":"guide/#Defining-Prescribed-Conditions","page":"Getting Started","title":"Defining Prescribed Conditions","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Whereas distributed loads are applied to beam elements, prescribed conditions are forces and/or displacement boundary conditions applied to points. One instance of PrescribedConditions must be created for every point on which prescribed conditions are applied.  These instances of PrescribedConditions are then stored in a dictionary in which they are accessed by their point index.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Possible prescribed conditions include:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"ux: Prescribed x-direction displacement of the point\nuy: Prescribed y-direction displacement of the point\nuz: Prescribed z-direction displacement of the point\ntheta_x: Prescribed first Wiener-Milenkovic parameter of the point\ntheta_y: Prescribed second Wiener-Milenkovic parameter of the point\ntheta_z: Prescribed third Wiener-Milenkovic parameter of the point\nFx: Prescribed force in x-direction applied on the point\nFy: Prescribed force in y-direction applied on the point\nFz: Prescribed force in z-direction applied on the point\nMx: Prescribed moment about x-axis applied on the point\nMy: Prescribed moment about y-axis applied on the point\nMz: Prescribed moment about z-axis applied on the point\nFx_follower: Prescribed follower force in x-direction applied on the point\nFy_follower: Prescribed follower force in y-direction applied on the point\nFz_follower: Prescribed follower force in z-direction applied on the point\nMx_follower: Prescribed follower moment about x-axis applied on the point\nMy_follower: Prescribed follower moment about y-axis applied on the point\nMz_follower: Prescribed follower moment about z-axis applied on the point","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"One can apply both force and displacement boundary conditions to the same point, but one cannot specify a force and displacement condition at the same point corresponding to the same degree of freedom.  If this is requested an error will result.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Here we create a fixed boundary condition on the left side of the beam.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # root section is fixed\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n    )\n\nnothing #hide","category":"page"},{"location":"guide/#Pre-Initializing-Memory-for-an-Analysis","page":"Getting Started","title":"Pre-Initializing Memory for an Analysis","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"At this point we have everything we need to perform an analysis.  However, since we will be performing multiple analyses using the same assembly we can save computational time be pre-allocating memory for the analysis.  This can be done by constructing an object of type System.  The constructor for this object requires that we provide the assembly, a list of points upon which point conditions are applied, and a flag indicating whether the system is static.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"prescribed_points = [1, nelem+1]\nstatic = false\nsystem = System(assembly, prescribed_points, static)\nnothing #hide","category":"page"},{"location":"guide/#Performing-a-Steady-State-Analysis","page":"Getting Started","title":"Performing a Steady State Analysis","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We're now ready to perform our steady state analyses.  This can be done by calling steady_state_analysis with the pre-allocated system storage, assembly, angular velocity, and the prescribed point conditions.  We can also perform a linear analysis instead of a nonlinear analysis by using the linear keyword argument.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"After each analysis we'll also construct an object of type AssemblyState so that we can save the results of each analysis prior to re-using the pre-allocated memory for the next analysis.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"\nrpm = 0:25:750\n\nlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nfor i = 1:length(rpm)\n\n    # global frame rotation\n    w0 = [0, 0, rpm[i]*(2*pi)/60]\n\n    # perform linear steady state analysis\n    _, converged = steady_state_analysis!(system, assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions,\n        linear = true)\n\n    linear_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions=prescribed_conditions)\n\nend\n\nreset_state!(system)\n\nnonlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nfor i = 1:length(rpm)\n\n   # global frame rotation\n   w0 = [0, 0, rpm[i]*(2*pi)/60]\n\n    # perform nonlinear steady state analysis\n    _, converged = steady_state_analysis!(system, assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions)\n\n     nonlinear_states[i] = AssemblyState(system, assembly;\n         prescribed_conditions=prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"guide/#Post-Processing-Results","page":"Getting Started","title":"Post Processing Results","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We can access the fields in each instance of AssemblyState in order to plot various quantities of interest.  This object stores an array of objects of type PointState in the field points and an array of objects of type ElementState in the field elements.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The fields of PointState are the following:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"u: displacement\ntheta: angular displacement\nF: externally applied forces\nM: externally applied moments","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The fields of ElementState are the following:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"u: displacement\ntheta: angular displacement\nF: resultant forces\nM: resultant moments\nP: linear momenta\nH: angular momenta","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To demonstrate how these fields can be accessed we will now plot the root moment and tip deflections.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nusing Plots\npyplot()\n\n# root moment\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    yticks = 0.0:2:12,\n    ylabel = \"\\$M_z\\$ at the root (lb-in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nMz_nl = [-nonlinear_states[i].points[1].M[3] for i = 1:length(rpm)]\nMz_l = [-linear_states[i].points[1].M[3] for i = 1:length(rpm)]\nplot!(rpm, Mz_nl, label=\"Nonlinear\")\nplot!(rpm, Mz_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-Mz.svg\"); nothing #hide\n\n# x tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.002, 0.074),\n    yticks = 0.0:0.01:0.07,\n    ylabel = \"\\$u_x\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nux_nl = [nonlinear_states[i].points[end].u[1] for i = 1:length(rpm)]\nux_l = [linear_states[i].points[end].u[1] for i = 1:length(rpm)]\nplot!(rpm, ux_nl, label=\"Nonlinear\")\nplot!(rpm, ux_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-ux.svg\"); nothing #hide\n\n# y tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.01, 0.27),\n    yticks = 0.0:0.05:0.25,\n    ylabel = \"\\$u_y\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nuy_nl = [nonlinear_states[i].points[end].u[2] for i = 1:length(rpm)]\nuy_l = [linear_states[i].points[end].u[2] for i = 1:length(rpm)]\nplot!(rpm, uy_nl, label=\"Nonlinear\")\nplot!(rpm, uy_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-uy.svg\"); nothing #hide\n\n# rotation of the tip\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylabel = \"\\$θ_z\\$ at the tip\",\n    grid = false,\n    overwrite_figure=false\n    )\ntheta_z_nl = [4*atan(nonlinear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]\ntheta_z_l = [4*atan(linear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]\n\nplot!(rpm, theta_z_nl, label=\"Nonlinear\")\nplot!(rpm, theta_z_l, label=\"Linear\")\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"guide/#Other-Capabilities","page":"Getting Started","title":"Other Capabilities","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For information on how to use the other capabilities of this package see the examples and/or the the Public API.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/#Creating-an-Assembly","page":"Library","title":"Creating an Assembly","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"curve_length\ndiscretize_beam\nAssembly(points, start, stop)","category":"page"},{"location":"library/#GXBeam.curve_length","page":"Library","title":"GXBeam.curve_length","text":"curve_length(start, stop, curvature)\n\nCalculate the length of a curve given its endpoints and its curvature vector\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.discretize_beam","page":"Library","title":"GXBeam.discretize_beam","text":"discretize_beam(L, start, discretization; frame = Matrix(I,3,3)), curvature = zeros(3))\n\nDiscretize a beam according to the discretization provided in discretization given the beam length (L), and starting point (start).\n\nReturn the lengths, endpoints, midpoints, and trasformation matrices of the beam elements.\n\nArguments\n\nL: Beam length\nstart: Beam starting point\ndiscretization: May be either an integer, representing the number of      elements that the beam should be discretized into, or a vector containing      the normalized endpoints of each beam element, where 0 is the beginning      of the beam and 1 is the end of the beam.\nframe: 3x3 tranformation matrix which transforms from the local beam      coordinate frame at the start of the beam to the global coordinate frame.\ncurvature: curvature vector\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.Assembly-Tuple{Any, Any, Any}","page":"Library","title":"GXBeam.Assembly","text":"Assembly(points, start, stop; kwargs...)\n\nConstruct an assembly of connected nonlinear beam elements for analysis.  Beam lengths and midpoints may be manually specified in case beam elements are curved rather than straight.\n\nArguments\n\npoints: Array of all beam element endpoints\nstart: Array containing point indices where each beam element starts\nstop: Array containing point indices where each beam element stops\n\nKeyword Arguments\n\nstiffness: Array of (6 x 6) stiffness matrices for each beam element, alternative to providing compliance\ncompliance: Array of (6 x 6) compliance matrices for each beam element, defaults to zeros(6,6) for each beam element\nmass: Array of (6 x 6) mass matrices for each beam element, alternative to providing minv\nminv: Array of (6 x 6) mass matrices for each beam element, defaults to the identity matrix for each beam element\nframes: Array of (3 x 3) tranformation matrices for each beam element, which      transform from the local undeformed beam frame to the global frame),      defaults to the identity matrix for each beam element\nlengths: Array containing the length of each beam, defaults to the distance between beam endpoints\nmidpoints: Array containing the midpoint of each beam element, defaults to the average of the beam element endpoints\n\n\n\n\n\n","category":"method"},{"location":"library/#Defining-Distributed-Loads","page":"Library","title":"Defining Distributed Loads","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"DistributedLoads(assembly, ibeam)\ncombine_loads","category":"page"},{"location":"library/#GXBeam.DistributedLoads-Tuple{Any, Any}","page":"Library","title":"GXBeam.DistributedLoads","text":"DistributedLoads(assembly, ibeam; kwargs...)\n\nReturn the integrated distributed loads at a point (as an object of type DistributedLoads).\n\nArguments\n\nassembly: The beam element assembly\nibeam: The index of the beam element which the distributed load is assigned to\n\nKeyword Arguments\n\ns1 = 0.0: Start of the beam element (used solely for integrating the distributed loads)\ns2 = 1.0: End of the beam element (used solely for integrating the distributed loads)\nmethod = (f, a, b) -> gauss_quadrature(f, a, b): Method which integrates function  f from a to b. Defaults to the Gauss-Legendre quadrature with 4 points on each element.\nfx = (s) -> 0.0: Distributed non-follower force on beam element in x-direction\nfy = (s) -> 0.0: Distributed non-follower force on beam element in y-direction\nfz = (s) -> 0.0: Distributed non-follower force on beam element in z-direction\nmx = (s) -> 0.0: Distributed non-follower moment on beam element in x-direction\nmy = (s) -> 0.0: Distributed non-follower moment on beam element in y-direction\nmz = (s) -> 0.0: Distributed non-follower moment on beam element in z-direction\nfx_follower = (s) -> 0.0: Distributed follower force on beam element in x-direction\nfy_follower = (s) -> 0.0: Distributed follower force on beam element in y-direction\nfz_follower = (s) -> 0.0: Distributed follower force on beam element in z-direction\nmx_follower = (s) -> 0.0: Distributed follower moment on beam element in x-direction\nmy_follower = (s) -> 0.0: Distributed follower moment on beam element in y-direction\nmz_follower = (s) -> 0.0: Distributed follower moment on beam element in z-direction\n\n\n\n\n\n","category":"method"},{"location":"library/#GXBeam.combine_loads","page":"Library","title":"GXBeam.combine_loads","text":"combine_loads(l1, l2)\n\nCombine the distributed loads in l1 and l2\n\n\n\n\n\n","category":"function"},{"location":"library/#Defining-Prescribed-Conditions","page":"Library","title":"Defining Prescribed Conditions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"PrescribedConditions()","category":"page"},{"location":"library/#GXBeam.PrescribedConditions-Tuple{}","page":"Library","title":"GXBeam.PrescribedConditions","text":"PrescribedConditions(t = 0.0; kwargs...)\n\nReturn the combined prescribed conditions at a point (as an object of type PrescribedConditions) at time t.\n\nIndividual prescribed conditions may be assigned as either a scalar parameter or as a function of time.\n\nPrescribed Wiener-Milenkovic parameters must satisfy the following inequality: sqrt(thetax^2 + thetay^2 + theta_z^2) <= 4.  Note that this restriction still allows all possible rotations to be represented.\n\nKeyword Arguments\n\nux: Prescribed x-direction displacement of the point\nuy: Prescribed y-direction displacement of the point\nuz: Prescribed z-direction displacement of the point\ntheta_x: Prescribed first Wiener-Milenkovic parameter of the point\ntheta_y: Prescribed second Wiener-Milenkovic parameter of the point\ntheta_z: Prescribed third Wiener-Milenkovic parameter of the point\nFx: Prescribed force in x-direction applied on the point\nFy: Prescribed force in y-direction applied on the point\nFz: Prescribed force in z-direction applied on the point\nMx: Prescribed moment about x-axis applied on the point\nMy: Prescribed moment about y-axis applied on the point\nMz: Prescribed moment about z-axis applied on the point\nFx_follower: Prescribed follower force in x-direction applied on the point\nFy_follower: Prescribed follower force in y-direction applied on the point\nFz_follower: Prescribed follower force in z-direction applied on the point\nMx_follower: Prescribed follower moment about x-axis applied on the point\nMy_follower: Prescribed follower moment about y-axis applied on the point\nMz_follower: Prescribed follower moment about z-axis applied on the point\n\n\n\n\n\n","category":"method"},{"location":"library/#Pre-Initializing-Memory-for-an-Analysis","page":"Library","title":"Pre-Initializing Memory for an Analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"System(assembly, points, static)\nsystem_state\nreset_state!\nset_state!\nset_element_deflections!\nset_element_rotations!\nset_element_forces!\nset_element_moments!\nset_element_linear_momenta!\nset_element_angular_momenta!\nset_point_deflections!\nset_point_rotations!\nset_point_forces!\nset_point_moments!","category":"page"},{"location":"library/#GXBeam.System-Tuple{Any, Any, Any}","page":"Library","title":"GXBeam.System","text":"System([TF=eltype(assembly),] assembly, points, static)\n\nInitialize an object of type System which stores the system state, residual vector, current time function values,and jacobian matrices as well as pointers to be able to access their contents.\n\nArguments:\n\nTF: (optional) Used to specify floating point type used by resulting System object\nassembly: Assembly of rigidly connected nonlinear beam elements\npoints: Point indices which should be preserved in the system of equations.      All points with prescribed conditions should be included.\nstatic: Flag indicating whether system matrices will be used for static simulations\n\n\n\n\n\n","category":"method"},{"location":"library/#GXBeam.system_state","page":"Library","title":"GXBeam.system_state","text":"system_state(system)\n\nReturn a vector containing the state variables of system.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.reset_state!","page":"Library","title":"GXBeam.reset_state!","text":"reset_state!(system)\n\nReset the state variables in system (stored in system.x).\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.set_state!","page":"Library","title":"GXBeam.set_state!","text":"setstate!([x,] system, prescribedconditions; kwargs...)\n\nSet the state variables in system (or in the vector x) to the provided values. If values are not provided for a given keyword argument, then the state variables corresponding to the keyword argument are not updated.\n\nKeyword Arguments\n\nu_b: Vector containing initial displacements (in the global frame) for each beam element.\ntheta_b: Vector containing rotation variables (in the global frame) for each beam element.\nF_b: Vector containing resultant forces (in the beam coordinate frame) for each beam element.\nM_b: Vector containing resultant moments (in the beam coordinate frame) for each beam element.\nP_b: Vector containing linear momenta (in the beam coordinate frame) for each beam element.\nH_b: Vector containing angular momenta (in the beam coordinate frame) for each beam element.\nu_p: Vector containing initial displacements (in the global frame) for each point.\ntheta_p: Vector containing rotation variables (in the global frame) for each point.\nF_p: Vector containing externally applied forces (in the global frame) for each point.\nM_p: Vector containing externally applied moments (in the global frame) for each point.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.set_element_deflections!","page":"Library","title":"GXBeam.set_element_deflections!","text":"setelementdeflections!([x,] system, u_b, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the deflections of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.set_element_rotations!","page":"Library","title":"GXBeam.set_element_rotations!","text":"setelementrotations!([x,] system, θ_b, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the rotations of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.set_element_forces!","page":"Library","title":"GXBeam.set_element_forces!","text":"setelementforces!([x,] system, F_b, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the resultant forces of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.set_element_moments!","page":"Library","title":"GXBeam.set_element_moments!","text":"setelementmoments!([x,] system, u_b, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the resultant moments of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.set_element_linear_momenta!","page":"Library","title":"GXBeam.set_element_linear_momenta!","text":"setelementlinearmomenta!([x,] system, ub, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the linear_momenta of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.set_element_angular_momenta!","page":"Library","title":"GXBeam.set_element_angular_momenta!","text":"setelementangularmomenta!([x,] system, ub, ielem)\n\nSet the state variables in system (or in the vector x) corresponding to the angular_momenta of element ielem to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.set_point_deflections!","page":"Library","title":"GXBeam.set_point_deflections!","text":"setpointdeflections!([x,] system, ub, ipoint, prescribedconditions)\n\nSet the state variables in system (or in the vector x) corresponding to the deflections (or externally applied forces) at point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.set_point_rotations!","page":"Library","title":"GXBeam.set_point_rotations!","text":"setpointrotations!([x,] system, ub, ipoint, prescribedconditions)\n\nSet the state variables in system (or in the vector x) corresponding to the rotations (or externally applied moments) at point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.set_point_forces!","page":"Library","title":"GXBeam.set_point_forces!","text":"setpointforces!([x,] system, Fp, ipoint, prescribedconditions)\n\nSet the state variables in system (or in the vector x) corresponding to the external forces applied on point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.set_point_moments!","page":"Library","title":"GXBeam.set_point_moments!","text":"setpointmoments!([x,] system, Mp, ipoint, prescribedconditions)\n\nSet the state variables in system (or in the vector x) corresponding to the external moments applied on point ipoint to the provided values.\n\n\n\n\n\n","category":"function"},{"location":"library/#Performing-an-Analysis","page":"Library","title":"Performing an Analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"static_analysis\nstatic_analysis!\nsteady_state_analysis\nsteady_state_analysis!\neigenvalue_analysis\neigenvalue_analysis!\ninitial_condition_analysis\ninitial_condition_analysis!\ntime_domain_analysis\ntime_domain_analysis!","category":"page"},{"location":"library/#GXBeam.static_analysis","page":"Library","title":"GXBeam.static_analysis","text":"static_analysis(assembly; kwargs...)\n\nPerform a static analysis of the system of nonlinear beams contained in assembly. Return the resulting system and a flag indicating whether the iteration procedure converged.\n\nKeyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and elements of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary      with keys corresponding to the elements to which distributed loads are      applied and elements of type DistributedLoads which describe      the distributed loads at those points.  If time varying, this input may      be provided as a function of time.\nlinear = false: Set to true for a linear analysis\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.BackTracking(maxstep=1e6): Line search used to solve nonlinear system of equations\nftol = 1e-9: tolerance for solving nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\ntvec = 0: Time vector/value. May be used in conjunction with time varying    prescribed conditions and distributed loads to gradually increase   displacements/loads.\nreset_state = true: Flag indicating whether the state variables should be   reset prior to performing the analysis.  This keyword argument is only valid   for the pre-allocated version of this function.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.static_analysis!","page":"Library","title":"GXBeam.static_analysis!","text":"static_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of static_analysis.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.steady_state_analysis","page":"Library","title":"GXBeam.steady_state_analysis","text":"steady_state_analysis(assembly; kwargs...)\n\nPerform a steady-state analysis for the system of nonlinear beams contained in assembly.  Return the resulting system and a flag indicating whether the iteration procedure converged.\n\nKeyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and elements of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary      with keys corresponding to the elements to which distributed loads are      applied and elements of type DistributedLoads which describe      the distributed loads at those points.  If time varying, this input may      be provided as a function of time.\nlinear = false: Set to true for a linear analysis\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6): Line search used to solve nonlinear system of equations\nftol = 1e-9: tolerance for solving nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\norigin = zeros(3): Global frame origin vector. If time varying, this input      may be provided as a function of time.\nlinear_velocity = zeros(3): Global frame linear velocity vector. If time      varying, this vector may be provided as a function of time.\nangular_velocity = zeros(3): Global frame angular velocity vector. If time      varying, this vector may be provided as a function of time.\ntvec = 0.0: Time vector/value. May be used in conjunction with time varying  prescribed conditions, distributed loads, and global motion to gradually  increase displacements/loads.\nreset_state = true: Flag indicating whether the state variables should be  reset prior to performing the analysis.  This keyword argument is only valid  for the pre-allocated version of this function.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.steady_state_analysis!","page":"Library","title":"GXBeam.steady_state_analysis!","text":"steady_state_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of steady_state_analysis.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.eigenvalue_analysis","page":"Library","title":"GXBeam.eigenvalue_analysis","text":"eigenvalue_analysis(assembly; kwargs...)\n\nCompute the eigenvalues and eigenvectors of the system of nonlinear beams contained in assembly.  Return the modified system, eigenvalues, eigenvectors, and a convergence flag indicating whether the corresponding steady-state analysis converged.\n\nKeyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and elements of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary      with keys corresponding to the elements to which distributed loads are      applied and elements of type DistributedLoads which describe      the distributed loads at those points.  If time varying, this input may      be provided as a function of time.\nlinear = false: Set to true for a linear analysis\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6): Line search used to solve nonlinear system of equations\nftol = 1e-9: tolerance for solving nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\nreset_state = true: Flag indicating whether the state variables should be  reset prior to performing the steady-state analysis.  This keyword argument  is only valid for the pre-allocated version of this function.\nfind_steady_state = reset_state && !linear: Flag indicating whether the  steady state solution should be found prior to performing the eigenvalue analysis.\norigin = zeros(3): Global frame origin.  If time varying, this vector may be provided as a function of time.\nlinear_velocity = zeros(3): Global frame linear velocity vector.  If time varying, this vector may be provided as a function of time.  May be provided either as a constant or as a function of time.\nangular_velocity = zeros(3): Global frame angular velocity vector.  If time varying, this vector may be provided as a function of time.\ntvec: Time vector. May be used in conjunction with time varying  prescribed conditions, distributed loads, and global motion to gradually  increase displacements/loads during the steady-state analysis.\nnev = 6: Number of eigenvalues to compute\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.eigenvalue_analysis!","page":"Library","title":"GXBeam.eigenvalue_analysis!","text":"eigenvalue_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of eigenvalue_analysis.  Uses the state variables stored in system as an initial guess for iterating to find the steady state solution.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.initial_condition_analysis","page":"Library","title":"GXBeam.initial_condition_analysis","text":"initial_condition_analysis(assembly, t0; kwargs...)\n\nPerform an analysis to obtain a consistent set of initial conditions.  Return the final system with the new initial conditions.\n\nKeyword Arguments\n\nprescribed_conditions: A dictionary with keys corresponding to the points at      which prescribed conditions are applied and elements of type      [PrescribedConditions`](@ref) which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads: A dictionary with keys corresponding to the elements to      which distributed loads are applied and elements of type      [DistributedLoads`](@ref) which describe the distributed loads at those      points.  If time varying, this input may be provided as a function of      time.\nlinear = false: Set to true for a linear analysis\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6): Line search used to solve nonlinear system of equations\nftol = 1e-9: tolerance for solving nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\nreset_state = true: Flag indicating whether the state variables should be  reset prior to performing the analysis.  This keyword argument is only valid  for the pre-allocated version of this function.\norigin = zeros(3): Global frame origin.  If time varying, this vector may be provided as a function of time.\nlinear_velocity = zeros(3): Global frame linear velocity vector.  If time varying, this vector may be provided as a function of time.  May be provided either as a constant or as a function of time.\nangular_velocity = zeros(3): Global frame angular velocity vector.  If time varying, this vector may be provided as a function of time.\nu0=fill(zeros(3), length(assembly.elements)): Initial displacment of each beam element,\ntheta0=fill(zeros(3), length(assembly.elements)): Initial angular displacement of each beam element,\nudot0=fill(zeros(3), length(assembly.elements)): Initial time derivative with respect to u\nthetadot0=fill(zeros(3), length(assembly.elements)): Initial time derivative with respect to theta\nsave=1:length(tvec): Steps at which to save the time history\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.initial_condition_analysis!","page":"Library","title":"GXBeam.initial_condition_analysis!","text":"initial_condition_analysis!(system, assembly, t0; kwargs...)\n\nPre-allocated version of initial_condition_analysis.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.time_domain_analysis","page":"Library","title":"GXBeam.time_domain_analysis","text":"time_domain_analysis(assembly, tvec; kwargs...)\n\nPerform a time-domain analysis for the system of nonlinear beams contained in assembly using the time vector tvec.  Return the final system, a post-processed solution history, and a convergence flag indicating whether the iterations converged for each time step.\n\nKeyword Arguments\n\nprescribed_conditions: A dictionary with keys corresponding to the points at      which prescribed conditions are applied and elements of type      [PrescribedConditions`](@ref) which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads: A dictionary with keys corresponding to the elements to      which distributed loads are applied and elements of type      [DistributedLoads`](@ref) which describe the distributed loads at those      points.  If time varying, this input may be provided as a function of      time.\nlinear = false: Set to true for a linear analysis\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6): Line search used to solve nonlinear system of equations\nftol = 1e-9: tolerance for solving nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\nreset_state = true: Flag indicating whether the state variables should be  reset prior to performing the analysis.  This keyword argument is only valid  for the pre-allocated version of this function.\ninitialize = true: Flag indicating whether a consistent set of initial  conditions should be found using initial_condition_analysis. If  false, the keyword arguments u0, theta0, udot0 and thetadot0 will  be ignored and the system state vector will be used as the initial state  variables.\norigin: Global frame origin vector. If time varying, this input      may be provided as a function of time.\nlinear_velocity: Global frame linear velocity vector. If time      varying, this vector may be provided as a function of time.\nangular_velocity: Global frame angular velocity vector. If time      varying, this vector may be provided as a function of time.\nu0=fill(zeros(3), length(assembly.elements)): Initial displacment of each beam element,\ntheta0=fill(zeros(3), length(assembly.elements)): Initial angular displacement of each beam element,\nudot0=fill(zeros(3), length(assembly.elements)): Initial time derivative with respect to u\nthetadot0=fill(zeros(3), length(assembly.elements)): Initial time derivative with respect to theta\nsave=1:length(tvec): Steps at which to save the time history\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.time_domain_analysis!","page":"Library","title":"GXBeam.time_domain_analysis!","text":"time_domain_analysis!(system, assembly, tvec; kwargs...)\n\nPre-allocated version of time_domain_analysis.\n\n\n\n\n\n","category":"function"},{"location":"library/#Post-Processing","page":"Library","title":"Post-Processing","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AssemblyState(system, assembly)\nAssemblyState\nPointState\nextract_element_state\nextract_element_states\nextract_element_states!\nextract_point_state\nextract_point_states\nextract_point_states!\nleft_eigenvectors\ncorrelate_eigenmodes\nwiener_milenkovic\nrotate\nrotate!\ntranslate\ntranslate!\ndeform_cross_section\ndeform_cross_section!\ncross_section_velocities\ncross_section_velocities!\nwrite_vtk","category":"page"},{"location":"library/#GXBeam.AssemblyState-Tuple{Any, Any}","page":"Library","title":"GXBeam.AssemblyState","text":"AssemblyState(system, assembly, x = system.x;\n    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nPost-process the system state given the solution vector x.  Return an object of type AssemblyState that defines the state of the assembly for the time step.\n\nIf prescribed_conditions is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.\n\n\n\n\n\n","category":"method"},{"location":"library/#GXBeam.AssemblyState","page":"Library","title":"GXBeam.AssemblyState","text":"AssemblyState{TF, TP<:AbstractVector{PointState{TF}}, TE<:AbstractVector{ElementState{TF}}}\n\nStruct for storing state variables for the points and elements in an assembly.\n\nFields:\n\npoints::TP: Array of PointStates for each point in the assembly\nelements::TE: Array of ElementStates for each element in the assembly\n\n\n\n\n\n","category":"type"},{"location":"library/#GXBeam.PointState","page":"Library","title":"GXBeam.PointState","text":"PointState\n\nHolds the state variables for a point\n\nFields:\n\nu: Displacement variables for the point (in the global coordinate frame)\ntheta: Wiener-Milenkovic rotational displacement variables for the point\nF: Externally applied forces on the point (in the global coordinate frame)\nM: Externally applied moments on the point (in the global coordinate frame)\n\n\n\n\n\n","category":"type"},{"location":"library/#GXBeam.extract_element_state","page":"Library","title":"GXBeam.extract_element_state","text":"extract_element_state(system, ielem, x = system.x)\n\nReturn the state variables corresponding to element ielem (see ElementState) given the solution vector x.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.extract_element_states","page":"Library","title":"GXBeam.extract_element_states","text":"extract_element_states(system, x = system.x)\n\nReturn the state variables corresponding to each element (see ElementState) given the solution vector x.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.extract_element_states!","page":"Library","title":"GXBeam.extract_element_states!","text":"extract_element_states!(elements, system, x = system.x)\n\nPre-allocated version of extract_element_states\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.extract_point_state","page":"Library","title":"GXBeam.extract_point_state","text":"extract_point_state(system, assembly, ipoint, x = system.x;\n    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nReturn the state variables corresponding to point ipoint (see PointState) given the solution vector x.\n\nIf prescribed_conditions is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.extract_point_states","page":"Library","title":"GXBeam.extract_point_states","text":"extract_point_states(system, assembly, x = system.x;\n    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nReturn the state variables corresponding to each point (see PointState) given the solution vector x.\n\nIf prescribed_conditions is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.extract_point_states!","page":"Library","title":"GXBeam.extract_point_states!","text":"extract_point_states!(points, system, assembly, x = system.x;\n    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nPre-allocated version of extract_point_states\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.left_eigenvectors","page":"Library","title":"GXBeam.left_eigenvectors","text":"left_eigenvectors(system, λ, V)\nleft_eigenvectors(K, M, λ, V)\n\nCompute the left eigenvector matrix U for the system using inverse power iteration given the eigenvalues λ and the corresponding right eigenvector matrix V.\n\nThe complex conjugate of each left eigenvector is stored in each row of the matrix U\n\nLeft and right eigenvectors satisfy the following M-orthogonality condition:\n\nu'Mv = 1 if u and v correspond to the same eigenvalue\nu'Mv = 0 if u and v correspond to different eigenvalues\n\nThis means that UMV = I\n\nThis function assumes that system has not been modified since the eigenvalues and right eigenvectors were computed.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.correlate_eigenmodes","page":"Library","title":"GXBeam.correlate_eigenmodes","text":"correlate_eigenmodes(C)\n\nReturn the permutation and the associated corruption index vector which associates eigenmodes from the current iteration with those of the previous iteration given the correlation matrix C.\n\nThe correlation matrix can take one of the following forms (in order of preference):\n\nC = U_p*M*V\nC = U*M_p*V_p\nC = V_p'*V\nC = V'*V_p\n\nwhere U is a matrix of conjugated left eigenvectors, M is the system mass matrix, V is a matrix of right eigenvectors, and ()_p indicates a variable from the previous iteration.\n\nNote that the following two forms of the correlation matrix seem to be significantly inferior to their counterparts listed above: C = U*M*V_p and C = U_p*M_p*V. This is likely due to the way in which the left eigenvector matrix is calculated.\n\nThe corruption index is the largest magnitude in a given row of C that was not chosen divided by the magnitude of the chosen eigenmode.  It is most meaningful when using one of the forms of the correlation matrix that uses left eigenvectors since correct eigenmodes will have magnitudes close to 1 and incorrect eigenmodes will have magnitudes close to 0.\n\nIf the new mode number is already assigned, the next highest unassigned mode number is used.  In this case a corruption index higher than 1 will be returned, otherwise the values of the corruption index will always be bounded by 0 and 1.\n\nSee \"New Mode Tracking Methods in Aeroelastic Analysis\" by Eldred, Vankayya, and Anderson.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.wiener_milenkovic","page":"Library","title":"GXBeam.wiener_milenkovic","text":"wiener_milenkovic(c)\n\nConstruct a Wiener-Milenkovic transformation matrix, given the three Wiener-Milenkovic parameters in c.\n\nNote that the corresponding rotation matrix is the transpose of this transformation matrix.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.rotate","page":"Library","title":"GXBeam.rotate","text":"rotate(xyz, r, theta)\n\nRotate the vectors in xyz about point r using the Wiener-Milenkovic parameters in theta.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.rotate!","page":"Library","title":"GXBeam.rotate!","text":"rotate!(xyz, r, theta)\n\nPre-allocated version of rotate\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.translate","page":"Library","title":"GXBeam.translate","text":"translate(xyz, u)\n\nTranslate the points in xyz by the displacements in u.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.translate!","page":"Library","title":"GXBeam.translate!","text":"translate!(xyz, u)\n\nPre-allocated version of translate\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.deform_cross_section","page":"Library","title":"GXBeam.deform_cross_section","text":"deform_cross_section(xyz, r, u, theta)\n\nRotate the points in xyz (of shape (3, :)) about point r using the Wiener-Milenkovic parameters in theta, then translate the points by the displacements in u.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.deform_cross_section!","page":"Library","title":"GXBeam.deform_cross_section!","text":"deform_cross_section!(xyz, r, u, theta)\n\nPre-allocated version of deform_cross_section\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.cross_section_velocities","page":"Library","title":"GXBeam.cross_section_velocities","text":"cross_section_velocities(xyz, r, v, ω)\n\nCalculate the velocities of the points in xyz given the linear velocity v, and the angular velocity ω about point r.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.cross_section_velocities!","page":"Library","title":"GXBeam.cross_section_velocities!","text":"cross_section_velocities!(vxyz, xyz, r, v, ω)\n\nPre-allocated version of cross_section_velocities\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.write_vtk","page":"Library","title":"GXBeam.write_vtk","text":"write_vtk(name, assembly::Assembly; kwargs...)\nwrite_vtk(name, assembly::Assembly, state::AssemblyState; kwargs...)\nwrite_vtk(name, assembly::Assembly, history::Vector{<:AssemblyState}], dt; kwargs...)\n\nWrite the deformed geometry (and associated data) to a VTK file for visualization using ParaView.\n\nThe state parameter may be omitted to write the original geometry to a VTK file without any associated data.\n\nIf the solution time history is provided, the time step must also be provided\n\nKeyword Arguments\n\nscaling=1.0: Parameter to scale the deflections (only valid if state is provided)\nmetadata=Dict(): Dictionary of metadata for the file(s)\n\n\n\n\n\nwrite_vtk(name, assembly::Assembly, [state::AssemblyState, ]λ::Number, eigenstate::AssemblyState;\nscaling=1.0, mode_scaling=1.0, cycles=1, steps=100)\n\nWrite a series of files corresponding to the elastic motion of the assembly about the deformed state encoded in state defined by the eigenvalue λ and the eigenvector encoded in eigenstate over the time period specified by time.\n\nThe steady-state deflections can be scaled with scaling and the eigenmode deflections can be scaled using mode_scaling.\n\nThe current time is encoded in the metadata tag \"time\"\n\n\n\n\n\n","category":"function"},{"location":"library/#Private-API","page":"Library","title":"Private API","text":"","category":"section"},{"location":"library/#Math","page":"Library","title":"Math","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GXBeam.tilde\nGXBeam.rotation_parameter_scaling\nGXBeam.get_C\nGXBeam.get_C_t\nGXBeam.get_C_θ\nGXBeam.get_C_θdot\nGXBeam.get_Q\nGXBeam.get_Q_θ\nGXBeam.get_Qinv\nGXBeam.get_Qinv_θ\nGXBeam.mul3\nGXBeam.gauss_quadrature","category":"page"},{"location":"library/#GXBeam.tilde","page":"Library","title":"GXBeam.tilde","text":"tilde(x)\n\nConstruct the cross product operator matrix\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.rotation_parameter_scaling","page":"Library","title":"GXBeam.rotation_parameter_scaling","text":"rotation_parameter_scaling(θ)\n\nExtract a scaling parameter which may be multiplied by the angular parameters to yield the Wiener-Milenkovic rotation parameters.  Use of this scaling parameter allows deflections greater than 360 degrees.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_C","page":"Library","title":"GXBeam.get_C","text":"get_C(θ)\n\nReturns the transformation matrix C given the three angular parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_C_t","page":"Library","title":"GXBeam.get_C_t","text":"get_C_t([C, ] θ, θ_t)\n\nCalculate the derivative of the Wiener-Milenkovic transformation matrix C with respect to the scalar parameter t. θ_t is the derivative of the angular parameter θ with respect to t.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_C_θ","page":"Library","title":"GXBeam.get_C_θ","text":"get_C_θ([C, ] θ)\n\nCalculate the derivative of the Wiener-Milenkovic transformation matrix C with respect to each of the rotation parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_C_θdot","page":"Library","title":"GXBeam.get_C_θdot","text":"get_C_θdot([C, ] θ)\n\nCalculate the derivative of the time derivative of the Wiener-Milenkovic transformation matrix C with respect to each of the time derivatives of θ. Used for constructing the \"mass\" matrix for eigenvalue computations.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_Q","page":"Library","title":"GXBeam.get_Q","text":"get_Q(θ)\n\nCalculate the matrix Q as defined in the paper \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu given the rotational parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_Q_θ","page":"Library","title":"GXBeam.get_Q_θ","text":"get_Q_θ(θ)\nget_Q_θ(Q, θ)\n\nCalculate the derivative of the matrix Q with respect to each of the rotation parameters in c.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_Qinv","page":"Library","title":"GXBeam.get_Qinv","text":"get_Qinv(θ)\n\nCalculate the matrix inverse Qinv as defined in the paper \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu given the rotational parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_Qinv_θ","page":"Library","title":"GXBeam.get_Qinv_θ","text":"get_Qinv_θ(θ)\n\nCalculate the derivative of the matrix inverse Qinv with respect to each of the rotation parameters in θ.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.mul3","page":"Library","title":"GXBeam.mul3","text":"mul3(A_1, A_2, A_3, b)\n\nReturn the product of a 3x3x3 tensor represented by A_1, A_2, and A_3 with the vector b.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.gauss_quadrature","page":"Library","title":"GXBeam.gauss_quadrature","text":"gauss_quadrature(f, a, b)\n\nDefault gauss-quadrature function used for integrating distributed loads.\n\n\n\n\n\n","category":"function"},{"location":"library/#Points","page":"Library","title":"Points","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GXBeam.point_variables\nGXBeam.insert_point_residual!\nGXBeam.point_residual!\nGXBeam.point_follower_jacobians\nGXBeam.insert_point_jacobian!\nGXBeam.point_jacobian!","category":"page"},{"location":"library/#GXBeam.point_variables","page":"Library","title":"GXBeam.point_variables","text":"point_variables(x, icol)\npoint_variables(x, icol, prescribed_conditions)\n\nExtract u, θ, F, M for the point described by the point state variables at icol in x after incorporating the prescribed conditions in prescribed_conditions\n\nNote that the degrees of freedom that are not specified in prescribed_conditions are used as state variables (e.g. prescribing F[2] would mean u[2] = x[icol+1])\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.insert_point_residual!","page":"Library","title":"GXBeam.insert_point_residual!","text":"insert_point_residual!(resid, irow_b, irow_p, u, θ, F, M, side)\n\nModify the equilibrium and constitutive equations to account for the point variables given by u, θ, F, M\n\nIf irowb != irowp, assume that the equilibrium equations have already been modified\n\nArguments\n\nresid: Residual vector\nirow_b: Row index of the first equilibrium/compatability equation for one side of the beam element\nirow_p: Row index of the first equilibrium equation for the point\nu: Displacement of the point\nθ: Rotation of the point\nF: External forces imposed on the point\nM: External moments imposed on the point\nside: Side of beam (-1 (left) or 1 (right))\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.point_residual!","page":"Library","title":"GXBeam.point_residual!","text":"point_residual!(resid, x, ipoint, assembly, prescribed_conditions,\n    force_scaling, icol, irow_p, irow_beam1, irow_beam2)\n\nAdds a points contributions to the residual vector\n\nArguments\n\nresid: residual vector\nx: current state vector\nipoint: index of point\nassembly: assembly of interconnected beam elements\nprescribed_conditions: dictionary of prescribed conditions\nforce_scaling: scaling parameter for forces\nicol: starting index for the point's state variables\nirow_p: Row index of the first equilibrium equation for the point\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.point_follower_jacobians","page":"Library","title":"GXBeam.point_follower_jacobians","text":"point_follower_jacobians(x, icol, prescribed_conditions)\n\nCalculate the jacobians of the follower forces/moments with respect to θ\n\nArguments\n\nx: Current state variable vector\nicol: Row/Column index of the first state variable for the point\nprescribed_conditions: Prescribed conditions for the point\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.insert_point_jacobian!","page":"Library","title":"GXBeam.insert_point_jacobian!","text":"insert_point_jacobian!(jacob, irow_b, irow_p, icol, prescribed_conditions, side, F_θ, M_θ)\n\nModify the jacobian entries for the equilibrium and constitutive equations to account for the point variables at icol\n\nIf irowb != irowp, assume that the equilibrium equations have already been modified\n\nArguments\n\njacob: Jacobian of residual vector with respect to state vectors\nirow_b: Row index of the first equilibrium/compatability equation for one side of the beam element\nirow_p: Row index of the first equilibrium equation for the point\nicol: Row/Column index of the first state variable for the point\nprescribed_conditions: Prescribed force/displacement and moment/rotation on point\nside: Side of beam (-1 (left) or 1 (right))\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.point_jacobian!","page":"Library","title":"GXBeam.point_jacobian!","text":"point_jacobian!(jacob, x, ipoint, assembly, prescribed_conditions, icol,\n    irow_p, irow_beam1, irow_beam2)\n\nAdds a points contributions to the residual vector\n\nArguments\n\njacob: residual vector\nx: current state vector\nipoint: index of point\nassembly: assembly of interconnected beam elements\nprescribed_conditions: dictionary of prescribed conditions\nforce_scaling: scaling parameter for forces\nicol: starting index for the point's state variables\nirow_p: Row index of the first equilibrium equation for the point\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\n\n\n\n\n\n","category":"function"},{"location":"library/#Elements","page":"Library","title":"Elements","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GXBeam.Element\nGXBeam.element_strain\nGXBeam.element_curvature\nGXBeam.element_linear_velocity\nGXBeam.element_angular_velocity\nGXBeam.element_properties\nGXBeam.element_dynamic_properties\nGXBeam.element_equations\nGXBeam.insert_element_residual!\nGXBeam.element_residual!\nGXBeam.element_jacobian_equations\nGXBeam.insert_element_jacobian!\nGXBeam.element_jacobian!\nGXBeam.element_mass_matrix_properties\nGXBeam.element_mass_matrix_equations\nGXBeam.insert_element_mass_matrix!\nGXBeam.element_mass_matrix!\nGXBeam.ElementState","category":"page"},{"location":"library/#GXBeam.Element","page":"Library","title":"GXBeam.Element","text":"Element{TF}\n\nComposite type that defines a beam element's properties\n\nFields\n\nL: Length of the beam element\nx: Location of the beam element (the midpoint of the beam element)\nC11: Upper left portion of the beam element's compliance matrix\nC12: Upper right portion of the beam element's compliance matrix\nC22: Lower right portion of the beam element's compliance matrix\nminv11: Upper left portion of the inverse of the beam element's mass matrix\nminv12: Upper right portion of the inverse of the beam element's mass matrix\nminv22: Lower right portion of the inverse of the beam element's mass matrix\nCab: Rotation matrix from the global frame to beam element's frame\n\n\n\n\n\n","category":"type"},{"location":"library/#GXBeam.element_strain","page":"Library","title":"GXBeam.element_strain","text":"element_strain(element, F, M)\n\nCalculate the strain of a beam element given the resultant force and moments (in the deformed local beam frame)\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_curvature","page":"Library","title":"GXBeam.element_curvature","text":"element_curvature(element, F, M)\n\nCalculate the curvature of a beam element given the resultant force and moments (in the deformed local beam frame)\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_linear_velocity","page":"Library","title":"GXBeam.element_linear_velocity","text":"element_linear_velocity(element, P, H)\n\nCalculate the linear velocity (in the deformed local beam frame) of a beam element given the linear and angular momenta\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_angular_velocity","page":"Library","title":"GXBeam.element_angular_velocity","text":"element_angular_velocity(element, P, H)\n\nCalculate the angular velocity (in the deformed local beam frame) of a beam element given the linear and angular momenta\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_properties","page":"Library","title":"GXBeam.element_properties","text":"element_properties(x, icol, beam, force_scaling, mass_scaling)\nelement_properties(x, icol, beam, force_scaling, mass_scaling, x0, v0, ω0)\nelement_properties(x, icol, ibeam, beam, force_scaling, mass_scaling, x0, v0, ω0, u, θ,\n    udot, θdot)\nelement_properties(x, icol, ibeam, beam, force_scaling, mass_scaling, x0, v0, ω0, udot,\n    θdot_init, CtCabPdot, CtCabHdot, dt)\n\nExtract/calculate the properties of a specific beam element.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\nx: current state vector\nicol: starting index for the beam's state variables\nibeam: beam element index\nbeam: beam element\nforce_scaling: scaling parameter for forces/moments\nmass_scaling: scaling parameter for mass/inertia\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu: deflection variables for each beam element\nθ: rotation variables for each beam element\nudot: time derivative of u for each beam element\nθdot: time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot_init: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_dynamic_properties","page":"Library","title":"GXBeam.element_dynamic_properties","text":"element_dynamic_properties(x, icol, beam, x0, v0, ω0, mass_scaling)\n\nExtract/Compute v, ω, P, H, V, and Ω.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_equations","page":"Library","title":"GXBeam.element_equations","text":"element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ)\nelement_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, v, ω, P, H, V, Ω)\nelement_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, v, ω, P, H, V, Ω,\n    udot, θdot, CtCabPdot, CtCabHdot)\n\nEvaluate the nonlinear equations for a beam element.\n\nThere are three implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step or Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments:\n\nΔL: Length of the beam element\nCt: Rotation tensor of the beam deformation in the \"a\" frame, transposed\nCab: Direction cosine matrix from \"a\" to \"b\" frame for the element\nCtCab: C'*Cab, precomputed for efficiency\nu: Displacement variables for the element [u1, u2, u3]\nθ: Rotation variables for the element [θ1, θ2, θ3]\nF: Force variables for the element [F1, F2, F3]\nM: Moment variables for the element [M1, M2, M3]\nγ: Engineering strains in the element [γ11, 2γ12, 2γ13]\nκ: Curvatures in the element [κ1, κ2, κ3]\n\nAdditional Arguments for Dynamic Analyses\n\nv: Linear velocity of element in global frame \"a\" [v1, v2, v3]\nω: Angular velocity of element in global frame \"a\" [ω1, ω2, ω3]\nP: Linear momenta for the element [P1, P2, P3]\nH: Angular momenta for the element [H1, H2, H3]\nV: Velocity of the element\nΩ: Rotational velocity of the element\n\nAdditional Arguments for Initial Step Analysis\n\nudot: user-specified time derivative of u\nθdot: user-specified time derivative of θ\nCtCabPdot: C'CabPdot state variable\nCtCabHdot: C'CabHdot state variable\n\nAdditional Arguments for Time Marching Analysis\n\nudot: 2/dt*(u-u_p) - udot_p for this beam element where _p denotes values   taken from the previous time step\nθdot: 2/dt*(θ-θ_p) - θdot_p for this beam element where _p denotes values   taken from the previous time step\nCtCabPdot: 2/dt*(C'*Cab*P - (C'*Cab*P)_p) - (C'*Cab*Pdot)_p for this beam   element where _p denotes values taken from the previous time step\nCtCabHdot: 2/dt*(C'*Cab*H - (C'*Cab*H)_p) - (C'*Cab*Hdot)_p for this beam   element where _p denotes values taken from the previous time step\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.insert_element_residual!","page":"Library","title":"GXBeam.insert_element_residual!","text":"insert_element_residual!(resid, force_scaling, mass_scaling, irow_b, irow_b1, irow_p1,\n    irow_b2, irow_p2, f_u1, f_u2, f_ψ1, f_ψ2, f_F1, f_F2, f_M1, f_M2)\ninsert_element_residual!(resid, force_scaling, mass_scaling, irow_b, irow_b1, irow_p1,\n    irow_b2, irow_p2, f_u1, f_u2, f_ψ1, f_ψ2, f_F1, f_F2, f_M1, f_M2, f_P, f_H)\n\nInsert beam element resultants into the residual equation.  Initialize equilibrium and constitutive equations if they are not yet initialized.\n\nIf irow_b1 != irow_p1 and/or irow_b2 != irow_p2, assume the equilibrium equations for the left and/or right side are already initialized\n\nThere are two implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State, Initial Step, or Time Marching\n\nArguments\n\nresid: System residual vector\nforce_scaling: Scaling parameter for forces\nmass_scaling: Scaling parameter for masses\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b1: Row index of the first equation for the right side of the beam element   (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p2: Row index of the first equation for the point on the right side of the beam element\nf_u1, f_u2: Resultant displacements for the left and right side of the beam element, respectively\nf_ψ1, f_ψ2: Resultant rotations for the left and right side of the beam element, respectively\nf_F1, f_F2: Resultant forces for the left and right side of the beam element, respectively\nf_M1, f_M2: Resultant moments for the left and right side of the beam element, respectively\n\nAdditional Arguments for Dynamic Analyses\n\nf_P: Resultant linear momenta of the beam element\nf_H: Resultant angular momenta of the beam element\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_residual!","page":"Library","title":"GXBeam.element_residual!","text":"element_residual!(resid, x, ibeam, beam, distributed_loads, force_scaling,\n    mass_scaling, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2)\nelement_residual!(resid, x, ibeam, beam, distributed_loads, force_scaling,\n    mass_scaling, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0)\nelement_residual!(resid, x, ibeam, beam, distributed_loads, force_scaling,\n    mass_scaling, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, u0, θ0,\n    udot0, θdot0)\nelement_residual!(resid, x, ibeam, beam, distributed_loads, force_scaling,\n    mass_scaling, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, udot_init,\n    θdot_init, CtCabPdot_init, CtCabHdot_init, dt)\n\nCompute and add a beam element's contributions to the residual vector\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\nresid: System residual vector\nx: current state vector\nibeam: beam element index\nbeam: beam element\ndistributed_loads: dictionary with all distributed loads\nforce_scaling: scaling parameter for forces\nmass_scaling: scaling parameter for masses/inertias\nicol: starting index for the beam's state variables\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b2: Row index of the first equation for the right side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p2: Row index of the first equation for the point on the right side of the beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu0: initial deflection variables for each beam element\nθ0: initial rotation variables for each beam element\nudot0: initial time derivative of u for each beam element\nθdot0: initial time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot_init: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_jacobian_equations","page":"Library","title":"GXBeam.element_jacobian_equations","text":"element_jacobian_equations(beam, ΔL, Ct, Cab, CtCab, θ, F, M, γ, κ, Ct_θ1,\n    Ct_θ2, Ct_θ3)\nelement_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, M, γ, κ, ω, P, H, V,\n    Ct_θ1, Ct_θ2, Ct_θ3)\nelement_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, γ, ω, P, V, θdot)\nelement_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, M, γ, κ, ω, P, H, V,\n    θdot, dt, Ct_θ1, Ct_θ2, Ct_θ3)\n\nFind the jacobians of the nonlinear equations for a beam element with respect to the state variables given the distributed loads on the beam element and the beam element's properties.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments:\n\nbeam: Beam element\nΔL: Length of the beam element\nCt: Rotation tensor of the beam deformation in the \"a\" frame, transposed\nCab: Direction cosine matrix from \"a\" to \"b\" frame for the element\nCtCab: C'*Cab, precomputed for efficiency\nu: Displacement variables for the element [u1, u2, u3]\nθ: Rotation variables for the element [θ1, θ2, θ3]\nF: Force variables for the element [F1, F2, F3]\nM: Moment variables for the element [M1, M2, M3]\nγ: Engineering strains in the element [γ11, 2γ12, 2γ13]\nκ: Curvatures in the element [κ1, κ2, κ3]\nCt_θ1: Gradient of Ct w.r.t. θ[1]\nCt_θ2: Gradient of Ct w.r.t. θ[2]\nCt_θ3: Gradient of Ct w.r.t. θ[3]\nf1_θ: Gradient w.r.t. θ of integrated distributed force for left side of element\nm1_θ: Gradient w.r.t. θ of integrated distributed moment for left side of element\nf2_θ: Gradient w.r.t. θ of integrated distributed force for right side of element\nm2_θ: Gradient w.r.t. θ of integrated distributed moment for right side of element\n\nAdditional Arguments for Dynamic Analyses\n\nv: Linear velocity of element in global frame \"a\" [v1, v2, v3]\nω: Angular velocity of element in global frame \"a\" [ω1, ω2, ω3]\nP: Linear momenta for the element [P1, P2, P3]\nH: Angular momenta for the element [H1, H2, H3]\nV: Velocity of the element\nΩ: Rotational velocity of the element\n\nAdditional Arguments for Initial Step Analyses\n\nudot: user-specified time derivative of u for this beam element\nθdot: user-specified time derivative of θ for this beam element\nCtCabPdot: C'*Cab*Pdot (which is a state variable for the initial step analysis)\nCtCabHdot: C'*Cab*Hdot (which is a state variable for the initial step analysis)\n\nAdditional Arguments for Time Marching Analyses\n\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.insert_element_jacobian!","page":"Library","title":"GXBeam.insert_element_jacobian!","text":"insert_element_jacobian!(jacob, force_scaling, mass_scaling, irow_b1, irow_p1, irow_b2,\n    irow_p2, icol,\n    f_u1_θ, f_u2_θ, f_u1_F, f_u2_F,\n    f_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M,\n    f_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,\n    f_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M)\ninsert_element_jacobian!(jacob, force_scaling, mass_scaling, irow_b1, irow_p1, irow_b2,\n    irow_p2, icol,\n    f_u1_θ, f_u2_θ, f_u1_F, f_u2_F, f_u1_P, f_u2_P,\n    f_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, f_ψ1_P, f_ψ2_P, f_ψ1_H, f_ψ2_H,\n    f_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,\n    f_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M,\n    f_P_u, f_P_θ, f_P_P, f_P_H,\n    f_H_θ, f_H_P, f_H_H)\ninsert_element_jacobian!(jacob, force_scaling, mass_scaling, irow_b1, irow_p1, irow_b2,\n    irow_p2, icol,\n    f_u1_CtCabPdot, f_u2_CtCabPdot, f_u1_F, f_u2_F, f_u1_P, f_u2_P,\n    f_ψ1_CtCabHdot, f_ψ2_CtCabHdot, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, f_ψ1_P, f_ψ2_P, f_ψ1_H, f_ψ2_H,\n    f_F1_F, f_F2_F, f_F1_M, f_F2_M,\n    f_M1_F, f_M2_F, f_M1_M, f_M2_M,\n    f_P_P, f_P_H,\n    f_H_P, f_H_H)\n\nInsert the the beam element jacobian entries into the jacobian matrix\n\nThere are three implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State or Time Marching\nDynamic - Initial Step (for initializing time domain simulations)\n\nArguments\n\njacob: System jacobian matrix\nforce_scaling: Scaling parameter for forces\nmass_scaling: Scaling parameter for masses/inertias\nicol_p1: Row/column index of the first unknown for the left endpoint (a value <= 0 indicates the unknowns have been eliminated from the system of equations)\nirow_b1: Row index of the first equation for the left side of the beam\nirow_p1: Row index of the first equation for the point on the left side of the beam\nicol_p2: Row/column index of the first unknown for the right endpoint   (a value <= 0 indicates the unknowns have been eliminated from the system of equations)\nirow_b2: Row index of the first equation for the right side of the beam\nirow_p2: Row index of the first equation for the point on the right side of the beam\nicol: Row/Column index corresponding to the first beam state variable\n\nAll other arguments use the following naming convention:\n\nf_y_x: Jacobian of element equation \"y\" with respect to state variable \"x\"\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_jacobian!","page":"Library","title":"GXBeam.element_jacobian!","text":"element_jacobian!(jacob, x, ibeam, beam, distributed_loads, force_scaling,\n    mass_scaling, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2)\nelement_jacobian!(jacob, x, ibeam, beam, distributed_loads, force_scaling,\n    mass_scaling, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0)\nelement_jacobian!(jacob, x, ibeam, beam, distributed_loads, force_scaling,\n    mass_scaling, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, u0, θ0,\n    udot0, θdot0)\nelement_jacobian!(jacob, x, ibeam, beam, distributed_loads, force_scaling,\n    mass_scaling, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, udot_init,\n    θdot_init, CtCabPdot_init, CtCabHdot_init, dt)\n\nAdds a beam element's contributions to the jacobian matrix\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: System jacobian matrix\nx: current state vector\nibeam: beam element index\nbeam: beam element\ndistributed_loads: dictionary with all distributed loads\nforce_scaling: scaling parameter for forces/moments\nmass_scaling: scaling parameter for masses/inertias\nicol: starting index for the beam's state variables\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b2: Row index of the first equation for the right side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p2: Row index of the first equation for the point on the right side of the beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu0: initial deflection variables for each beam element\nθ0: initial rotation variables for each beam element\nudot0: initial time derivative of u for each beam element\nθdot0: initial time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot_init: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_mass_matrix_properties","page":"Library","title":"GXBeam.element_mass_matrix_properties","text":"element_mass_matrix_properties(x, icol, beam, mass_scaling)\n\nExtract/Compute the properties needed for mass matrix construction: ΔL, Ct, Cab, CtCab, θ, P, H, Ctdot_cdot1, Ctdot_cdot2, and Ctdot_cdot3\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_mass_matrix_equations","page":"Library","title":"GXBeam.element_mass_matrix_equations","text":"element_mass_matrix_equations(ΔL, Ct, Cab, CtCab, θ, P, H)\n\nCalculates the jacobians of the nonlinear equations for a beam element with respect to the time derivatives of the state variables.\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments:\n\nΔL: Length of the beam element\nCt: Rotation tensor of the beam deformation in the \"a\" frame, transposed\nCab: Direction cosine matrix from \"a\" to \"b\" frame for the element\nθ: Rotation variables for the element [θ1, θ2, θ3]\nP: Linear momenta for the element [P1, P2, P3]\nH: Angular momenta for the element [H1, H2, H3]\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.insert_element_mass_matrix!","page":"Library","title":"GXBeam.insert_element_mass_matrix!","text":"insert_element_mass_matrix!(jacob, force_scaling, mass_scaling, irow_b1, irow_p1, irow_b2, irow_p2,\n    icol, f_u1_θdot, f_u2_θdot, f_u1_Pdot, f_u2_Pdot, f_ψ1_θdot, f_ψ2_θdot,\n    f_ψ1_Hdot, f_ψ2_Hdot, f_P_udot, f_H_θdot)\n\nInsert the beam element's contributions into the \"mass matrix\": the jacobian of the residual equations with respect to the time derivatives of the state variables\n\nArguments\n\njacob: System mass matrix\nforce_scaling: Scaling parameter for forces/moments\nmass_scaling: Scaling parameter for masses/inertias\nirow_b1: Row index of the first equation for the left side of the beam\nirow_p1: Row index of the first equation for the point on the left side of the beam\nirow_b2: Row index of the first equation for the right side of the beam\nirow_p2: Row index of the first equation for the point on the right side of the beam\nicol: Row/Column index corresponding to the first beam state variable\n\nAll other arguments use the following naming convention:\n\nf_y_x: Jacobian of element equation \"y\" with respect to state variable \"x\"\n\n\n\n\n\ninsert_element_mass_matrix!(jacob, gamma, force_scaling, mass_scaling,\n    irow_b1, irow_p1, irow_b2, irow_p2,\n    icol, f_u1_θdot, f_u2_θdot, f_u1_Pdot, f_u2_Pdot, f_ψ1_θdot, f_ψ2_θdot,\n    f_ψ1_Hdot, f_ψ2_Hdot, f_P_udot, f_H_θdot)\n\nAdd the beam element's mass matrix to the system jacobian matrix jacob, scaled by the scaling parameter gamma.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.element_mass_matrix!","page":"Library","title":"GXBeam.element_mass_matrix!","text":"element_mass_matrix!(jacob, x, beam, force_scaling, mass_scaling, icol, irow_b, irow_b1,\n    irow_p1, irow_b2, irow_p2)\n\nInsert the beam element's contributions to the \"mass matrix\": the jacobian of the residual equations with respect to the time derivatives of the state variables\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: System jacobian matrix to add mass matrix jacobian to\nx: current state vector\nbeam: beam element\nforce_scaling: scaling parameter for forces/moments\nmass_scaling: scaling parameter for masses/inertias\nicol: starting index for the beam's state variables\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b2: Row index of the first equation for the right side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p2: Row index of the first equation for the point on the right side of the beam element\ngamma: Scaling parameter for scaling mass matrix contribution to jacob\n\n\n\n\n\nelement_mass_matrix!(jacob, gamma, x, beam, force_scaling, mass_scaling,\n    icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2)\n\nAdd the beam element's mass matrix to the system jacobian matrix jacob, scaled by the scaling parameter gamma.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.ElementState","page":"Library","title":"GXBeam.ElementState","text":"ElementState\n\nHolds the state variables for an element\n\nFields:\n\nu: Displacement variables for the element (in the global coordinate frame)\ntheta: Wiener-Milenkovic rotational displacement variables for the element\nF: Resultant forces for the element (in the deformed beam coordinate frame)\nM: Resultant moments for the element (in the deformed beam coordinate frame)\nP: Linear momenta of the element (in the deformed beam coordinate frame)\nH: Angular momenta of the element (in the deformed beam coordinate frame)\n\n\n\n\n\n","category":"type"},{"location":"library/#Loads","page":"Library","title":"Loads","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GXBeam.PrescribedConditions\nGXBeam.DistributedLoads","category":"page"},{"location":"library/#GXBeam.PrescribedConditions","page":"Library","title":"GXBeam.PrescribedConditions","text":"PrescribedConditions{T}\n\nDescribes the forces, moments, displacements, and/or rotations prescribed at a point at a specific point in time.\n\n\n\n\n\n","category":"type"},{"location":"library/#GXBeam.DistributedLoads","page":"Library","title":"GXBeam.DistributedLoads","text":"DistributedLoads{T}\n\nContains the integrated distributed forces and moments for each beam element at a specific time step.\n\nFields\n\nf1: Integrated non-follower distributed force for the beam element's left endpoint for each time step\nf2: Integrated non-follower distributed force for the beam element's right endpoint for each time step\nm1: Integrated non-follower distributed moment for the beam element's left endpoint for each time step\nm2: Integrated non-follower distributed moment for the beam element's right endpoint for each time step\nf1_follower: Integrated follower distributed force for the beam element's left endpoint for each time step\nf2_follower: Integrated follower distributed force for the beam element's right endpoint for each time step\nm1_follower: Integrated follower distributed moment for the beam element's left endpoint for each time step\nm2_follower: Integrated follower distributed moment for the beam element's right endpoint for each time step\n\n\n\n\n\n","category":"type"},{"location":"library/#System","page":"Library","title":"System","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GXBeam.Assembly\nGXBeam.curve_triad\nGXBeam.curve_coordinates\nGXBeam.System\nGXBeam.point_connections\nGXBeam.get_sparsity\nGXBeam.system_indices\nGXBeam.system_residual!\nGXBeam.system_jacobian!\nGXBeam.system_mass_matrix!","category":"page"},{"location":"library/#GXBeam.Assembly","page":"Library","title":"GXBeam.Assembly","text":"Assembly{TF, TP<:AbstractVector{<:AbstractVector{TF}}, TC<:AbstractVector{<:Integer}, TE<:AbstractVector{Element{TF}}}\n\nComposite type that defines an assembly of connected nonlinear beam elements for analysis.\n\nFields\n\npoints: Array of all beam element endpoints\nstart: Array containing point index where each beam element starts\nstop: Array containing point index where each beam element stops\nelement: Array of Elements\n\n\n\n\n\n","category":"type"},{"location":"library/#GXBeam.curve_triad","page":"Library","title":"GXBeam.curve_triad","text":"curve_triad(Cab, k, s)\ncurve_triad(Cab, kkt, ktilde, kn, s)\n\nReturn the transformation matrix at s along the length of the beam given the curvature vector k and the initial transformation matrix Cab.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.curve_coordinates","page":"Library","title":"GXBeam.curve_coordinates","text":"curve_coordiantes(r, Cab, k, s)\ncurve_coordinates(r, Cab, kkt, ktilde, kn, s)\n\nReturn the coordinates at s along the length of the beam given the starting point r, initial transformation matrix Cab, and curvature vector k.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.System","page":"Library","title":"GXBeam.System","text":"System{TF, TV<:AbstractVector{TF}, TM<:AbstractMatrix{TF}}\n\nContains the system state, residual vector, and jacobian matrices as well as pointers to be able to access their contents.  Also contains additional storage needed for time domain simulations.\n\nFields:\n\nstatic: Flag indicating whether system matrices are only valid for static analyses\nx: State vector\nr: Residual vector\nK: System jacobian matrix with respect to the state variables\nM: System jacobian matrix with respect to the time derivative of the state variables\nforce_scaling: Scaling for state variables corresponding to forces/moments\nmass_scaling: Scaling for state variables corresponding to masses/inertias\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Row/Column index of first state variable for each point\nicol_beam: Row/Column index of first state variable for each beam element\nudot: 2/dt*u + udot for each beam element from the previous time step\nθdot: 2/dt*θ + θdot for each beam element from the previous time step\nPdot: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nHdot: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\nt: Current system time\n\n\n\n\n\n","category":"type"},{"location":"library/#GXBeam.point_connections","page":"Library","title":"GXBeam.point_connections","text":"point_connections(assembly)\n\nCount the number of beams connected to each point\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.get_sparsity","page":"Library","title":"GXBeam.get_sparsity","text":"get_sparsity(system, assembly)\n\nReturn a matrix indicating the sparsity structure of the jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.system_indices","page":"Library","title":"GXBeam.system_indices","text":"system_indices(assembly, points, n_connections, static)\n\nSolve for the row indices of the first equilibrium or compatability equations for each point and side of each beam element.  Also solve for the row/column index of each point and beam state variable.\n\nNote that this function includes the following logic which reduces the size of the system of equations where possible (without sacrificing any accuracy):\n\nIf only two beams meet at a point, the 6 unknowns associated with that point as well as the 6 compatability equations are eliminated from the system, except if specified in the array points.  Points for which unknowns have been eliminated are assigned a column index of -1.  Beams for which the compatability equations have been eliminated are also assigned an index of -1\n\nArguments:\n\nassembly: Assembly of rigidly connected nonlinear beam elements\npoints: Point indices which should be preserved in the system matrices\nn_connections: Number of connections to each point\nstatic: flag indicating whether analysis is static\n\nReturn Arguments:\n\nn: total number of equations/unknowns in the system\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.system_residual!","page":"Library","title":"GXBeam.system_residual!","text":"system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n    force_scaling, mass_scaling, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam)\nsystem_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n    force_scaling, mass_scaling, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n    x0, v0, ω0)\nsystem_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n    force_scaling, mass_scaling, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n    x0, v0, ω0, u, θ, udot, θdot)\nsystem_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n    force_scaling, mass_scaling, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n    x0, v0, ω0, udot_init, θdot_init, CtCabPdot_init, CtCabHdot_init, dt)\n\nPopulate the residual vector resid with the results of the residual equations for the system.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by  Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using  Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\nresid: System residual vector\nx: Current state variables of the system\nassembly: Assembly of rigidly connected nonlinear beam elements\nprescribed_conditions: Dictionary of prescribed conditions at all time steps\ndistributed_loads: Dictionary of distributed loads at all time steps\nforce_scaling: Scaling parameter for forces/moments\nmass_scaling: Scaling parameter for masses/inertias\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu: deflection variables for each beam element\nθ: rotation variables for each beam element\nudot: time derivative of u for each beam element\nθdot: time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot_init: -2/dt*u - udot for each beam element from the previous time step\nθdot_init: -2/dt*θ - θdot for each beam element from the previous time step\nCtCabPdot_init: -2/dt*C'*Cab*P - C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: -2/dt*C'*Cab*H - C'*Cab*Hdot for each beam element from the previous time step\ndt: Time step size. If set to nothing, udot_init,\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.system_jacobian!","page":"Library","title":"GXBeam.system_jacobian!","text":"system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n    force_scaling, mass_scaling, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam)\nsystem_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n    force_scaling, mass_scaling, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n    x0, v0, ω0)\nsystem_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n    force_scaling, mass_scaling, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n    x0, v0, ω0, u, θ, udot, θdot)\nsystem_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n    force_scaling, mass_scaling, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n    x0, v0, ω0, udot_init, θdot_init, CtCabPdot_init, CtCabHdot_init, dt)\n\nPopulate the jacobian matrix jacob with the jacobian of the residual vector with respect to the state variables.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by  Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using  Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: Jacobian matrix\nx: Vector containing current state variables of the system\nassembly: Assembly of rigidly connected nonlinear beam elements\nprescribed_conditions: Dictionary of prescribed conditions at all time steps\ndistributed_loads: Dictionary of distributed loads at all time steps\nforce_scaling: Scaling parameter for forces/moments\nmass_scaling: Scaling parameter for masses/inertia\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu: deflection variables for each beam element\nθ: rotation variables for each beam element\nudot: time derivative of u for each beam element\nθdot: time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot: -2/dt*u - udot for each beam element from the previous time step\nθdot_init: -2/dt*θ - θdot for each beam element from the previous time step\nCtCabPdot: -2/dt*C'*Cab*P - C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot: -2/dt*C'*Cab*H - C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GXBeam.system_mass_matrix!","page":"Library","title":"GXBeam.system_mass_matrix!","text":"system_mass_matrix!(jacob, x, assembly, force_scaling, mass_scaling, irow_pt, irow_beam,\n    irow_beam1, irow_beam2, icol_pt, icol_beam)\n\nAdd entries to the system \"mass matrix\", the jacobian of the residual vector with respect to the time derivatives of the state variables.\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: Jacobian matrix\nx: Vector containing current state variables of the system\nassembly: Assembly of rigidly connected nonlinear beam elements\nforce_scaling: Scaling parameter for forces\nmass_scaling: Scaling parameter for masses\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\n\n\n\n\nsystem_mass_matrix!(jacob, gamma, x, dx, assembly, force_scaling, mass_scaling, irow_pt,\n    irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam)\n\nAdd the system mass matrix to jacob, scaled by the scaling parameter gamma.\n\n\n\n\n\n","category":"function"},{"location":"library/#Index","page":"Library","title":"Index","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples show how to use the various analysis capabilities of GXBeam.  Many of these examples also provide a verification/validation for the implementation of geometrically exact beam theory in GXBeam.  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 3","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# this is placed here to pre-install matplotlib so the documentation doesn't get cluttered with the installation print statements.\nusing Plots\npyplot()","category":"page"},{"location":"examples/#Linear-Analysis-of-a-Cantilever-Partially-Under-a-Uniform-Distributed-Load","page":"Examples","title":"Linear Analysis of a Cantilever Partially Under a Uniform Distributed Load","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a cantilever beam which is partially subjected to a uniform distributed load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\nnelem = 12\n\n# create points\na = 0.3\nb = 0.7\nL = 1.0\nn1 = n3 = div(nelem, 3)\nn2 = nelem - n1 - n3\nx1 = range(0, 0.3, length=n1+1)\nx2 = range(0.3, 0.7, length=n2+1)\nx3 = range(0.7, 1.0, length=n3+1)\nx = vcat(x1, x2[2:end], x3[2:end])\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints for each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# create compliance matrix for each beam element\nEI = 1e9\ncompliance = fill(Diagonal([0, 0, 0, 0, 1/EI, 0]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# set prescribed conditions (fixed right endpoint)\nprescribed_conditions = Dict(\n    nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n)\n\n# create distributed load\nq = 1000\ndistributed_loads = Dict(\n    ielem => DistributedLoads(assembly, ielem; fz = (s) -> q) for ielem in n1+1:n1+n2\n)\n\nsystem, converged = static_analysis(assembly, prescribed_conditions=prescribed_conditions,\n    distributed_loads=distributed_loads, linear=true)\n\nstate = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can construct the analytical solution for this problem by integrating from the free end of the beam and applying the appropriate boundary conditions.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# construct analytical solution\ndx = 1e-6\nx_a = 0.0:dx:L\nq_a = (x) -> a <= x <= b ? -q : 0 # define distributed load\nV_a = cumsum(-q_a.(x_a) .* dx) # integrate to get shear\nM_a = cumsum(V_a .* dx) # integrate to get moment\nslope_a = cumsum(M_a./EI .* dx) # integrate to get slope\nslope_a .-= slope_a[end] # apply boundary condition\ndeflection_a = cumsum(slope_a .* dx) # integrate to get deflection\ndeflection_a .-= deflection_a[end] # apply boundary condition\n\n# get elastic twist angle\ntheta_a = -atan.(slope_a)\n\n# adjust coordinate system of the analytical solution to match the computational solution\nM_a = -M_a\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational solutions show excellent agreement.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Suppressor #hide\n\n@suppress_err begin #hide\n\nglobal x #hide\n\nusing Plots\npyplot()\n\n# deflection plot\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Deflection (m)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint =\n    1:length(assembly.points)]\ndeflection = [state.points[ipoint].u[3] for ipoint = 1:length(assembly.points)]\nplot!(x_a, deflection_a, label=\"Analytical\")\nscatter!(x, deflection, label=\"GXBeam\")\n\nsavefig(\"linear-cantilever-pudl-1.svg\") #hide\n\n# elastic twist plot (euler angle)\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Rotation Parameter \\$\\\\theta_y\\$\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1]\n    for ipoint = 1:length(assembly.points)]\ntheta = [4*atan.(state.points[ipoint].theta[2]/4) for ipoint =\n    1:length(assembly.points)]\nplot!(x_a, theta_a, label=\"Analytical\")\nscatter!(x, theta, label=\"GXBeam\")\n\nsavefig(\"linear-cantilever-pudl-2.svg\") #hide\n\n# bending moment plot\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Bending Moment (\\$Nm\\$)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.elements[ielem].x[1] + state.elements[ielem].u[1] for\n    ielem = 1:length(assembly.elements)]\nM = [state.elements[ielem].M[2] for ielem = 1:length(assembly.elements)]\nplot!(x_a, M_a, label=\"Analytical\")\nscatter!(x, M, label=\"GXBeam\")\n\nsavefig(\"linear-cantilever-pudl-3.svg\") #hide\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that we could have easily performed a nonlinear analysis for this problem by setting linear=false.","category":"page"},{"location":"examples/#Linear-Analysis-of-a-Beam-Under-a-Linear-Distributed-Load","page":"Examples","title":"Linear Analysis of a Beam Under a Linear Distributed Load","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a beam which is clamped at one end and simply supported at the other end when subjected to a linear distributed load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\nnelem = 16\n\n# create points\nL = 1\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints for each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# create compliance matrix for each beam element\nEI = 1e7\ncompliance = fill(Diagonal([0, 0, 0, 0, 1/EI, 0]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# set prescribed conditions\nprescribed_conditions = Dict(\n    # simply supported left endpoint\n    1 => PrescribedConditions(uz=0),\n    # clamped right endpoint\n    nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n)\n\n# create distributed load\nqmax = 1000\ndistributed_loads = Dict()\nfor i = 1:nelem\n    distributed_loads[i] = DistributedLoads(assembly, i; s1=x[i],\n        s2=x[i+1], fz = (s) -> qmax*s)\nend\n\n# perform a static analysis\nsystem, converged = static_analysis(assembly;\n    prescribed_conditions = prescribed_conditions,\n    distributed_loads = distributed_loads,\n    linear = true)\n\n# post-process the results\nstate = AssemblyState(system, assembly;\n    prescribed_conditions = prescribed_conditions)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"An analytical solution to this over-determined problem can be found using the method of superposition using the analytical solutions to a cantilever with a linearly distributed load and a cantilever with an end load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# construct analytical solution\nx_a = range(0.0, L, length=1000)\nw_a = @. qmax*(1-x_a)^2/(120*EI)*(4 - 8*(1-x_a) + 5*(1-x_a)^2 - (1-x_a)^3)\nslope_a = @. -qmax*(1-x_a)/(120*EI)*(8 - 24*(1-x_a) + 20*(1-x_a)^2 - 5*(1-x_a)^3)\nM_a = @. qmax/120*(8 - 48*(1-x_a) + 60*(1-x_a)^2 - 20*(1-x_a)^3)\n\ntheta_a = -atan.(slope_a)\n\n# adjust coordinate system of analytical solution\nM_a = -M_a\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational solutions show excellent agreement.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nglobal x #hide\n\nusing Plots\npyplot()\n\n# set up the plot\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Deflection (m)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint =\n    1:length(assembly.points)]\ndeflection = [state.points[ipoint].u[3] for ipoint = 1:length(assembly.points)]\nplot!(x_a, w_a, label=\"Analytical\")\nscatter!(x, deflection, label=\"GXBeam\")\n\nsavefig(\"linear-overdetermined-ldl-1.svg\") #hide\n\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Rotation Parameter \\$\\\\theta_y\\$\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint =\n    1:length(assembly.points)]\ntheta = [4*atan.(state.points[ipoint].theta[2]/4) for ipoint = 1:length(assembly.points)]\nplot!(x_a, theta_a, label=\"Analytical\")\nscatter!(x, theta, label=\"GXBeam\")\n\nsavefig(\"linear-overdetermined-ldl-2.svg\") #hide\n\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylabel = \"Bending Moment (\\$Nm\\$)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.elements[ielem].x[1] + state.elements[ielem].u[1] for ielem =\n    1:length(assembly.elements)]\nM = [state.elements[ielem].M[2] for ielem = 1:length(assembly.elements)]\nplot!(x_a, M_a, label=\"Analytical\")\nscatter!(x, M, label=\"GXBeam\")\n\nsavefig(\"linear-overdetermined-ldl-3.svg\") #hide\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that we could have easily performed a nonlinear analysis for this problem by setting linear=false.","category":"page"},{"location":"examples/#Nonlinear-Analysis-of-a-Cantilever-Subjected-to-a-Constant-Tip-Load","page":"Examples","title":"Nonlinear Analysis of a Cantilever Subjected to a Constant Tip Load","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a cantilever beam that is subjected to a constant tip load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\nL = 1\nEI = 1e6\n\n# shear force (applied at end)\nλ = 0:0.5:16\np = EI/L^2\nP = λ*p\n\n# create points\nnelem = 16\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([0, 0, 0, 0, 1/EI, 0]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# pre-initialize system storage\nstatic = true\nkeep_points = [1, nelem+1] # points that should be included in the system of equations\nsystem = System(assembly, keep_points, static)\n\n# run an analysis for each prescribed tip load\nstates = Vector{AssemblyState{Float64}}(undef, length(P))\nfor i = 1:length(P)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # shear force on right tip\n        nelem+1 => PrescribedConditions(Fz = P[i])\n    )\n\n    # perform a static analysis\n    static_analysis!(system, assembly;\n        prescribed_conditions=prescribed_conditions)\n\n    # post-process the results\n    states[i] = AssemblyState(system, assembly;\n        prescribed_conditions=prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The analytical solution to this problem has been presented by several authors.  Here we follow the solution by H. J. Barten in \"On the Deflection of a Cantilever Beam\", after incorporating the corrections they submitted for finding the tip angle.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nimport Elliptic\n\nδ = range(pi/4, pi/2, length=10^5)[2:end-1]\n\nk = @. cos(pi/4)/sin(δ)\nλ_a = @. (Elliptic.F(pi/2, k^2) - Elliptic.F(δ,  k^2))^2\n\nθ_a = @. 2*(pi/4 - acos(k))\n\nξ_a = @. sqrt(2*sin(θ_a)/λ_a) .- 1\n\nη_a = @. 1-2/sqrt(λ_a)*(Elliptic.E(pi/2, k^2) - Elliptic.E(δ, k^2))\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational solutions show excellent agreement.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nglobal x #hide\n\nusing Plots\npyplot()\n\nu = [states[i].points[end].u[1] for i = 1:length(P)]\nθ = [states[i].points[end].theta[2] for i = 1:length(P)]\nw = [states[i].points[end].u[3] for i = 1:length(P)]\n\n# set up the plot\nplot(\n    xlim = (0, 16),\n    xticks = 0:1:16,\n    xlabel = \"Nondimensional Force \\$\\\\left(\\\\frac{PL^2}{EI}\\\\right)\\$\",\n    ylim = (0, 1.2),\n    yticks = 0.0:0.2:1.2,\n    ylabel = \"Nondimensional Tip Displacements\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nplot!([0], [0], color=:black, label=\"Analytical\")\nscatter!([0], [0], color=:black, label=\"GXBeam\")\nplot!([0], [0], color=1, label=\"Vertical \\$\\\\left(w/L\\\\right)\\$\")\nplot!([0], [0], color=2, label=\"Horizontal \\$\\\\left(-u/L\\\\right)\\$\")\nplot!([0], [0], color=3, label=\"\\$ \\\\theta/(\\\\pi/2) \\$\")\n\nplot!(λ_a, η_a, color=1, label=\"\")\nscatter!(λ, w/L, color=1, label=\"\")\n\nplot!(λ_a, -ξ_a, color=2, label=\"\")\nscatter!(λ, -u/L, color=2, label=\"\")\n\nplot!(λ_a, θ_a*2/pi, color=3, label=\"\")\nscatter!(λ, -4*atan.(θ/4)*2/pi, color=3, label=\"\")\n\nsavefig(\"cantilever-tipforce.svg\"); nothing #hide\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Analysis-of-a-Cantilever-Subjected-to-a-Constant-Moment","page":"Examples","title":"Nonlinear Analysis of a Cantilever Subjected to a Constant Moment","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a cantilever beam that is subjected to a constant tip moment.  This is a common benchmark problem for the geometrically nonlinear analysis of beams.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\nL = 12 # inches\nh = w = 1 # inches\nE = 30e6 # lb/in^4 Young's Modulus\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\n\n# bending moment (applied at end)\nλ = [0.0, 0.4, 0.8, 1.2, 1.6, 1.8, 2.0]\nm = pi*E*Iyy/L\nM = λ*m\n\n# create points\nnelem = 16\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([1/(E*A), 0, 0, 0, 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# pre-initialize system storage\nstatic = true\nkeep_points = [1, nelem+1] # points that should be included in the system of equations\nsystem = System(assembly, keep_points, static)\n\n# run an analysis for each prescribed bending moment\nstates = Vector{AssemblyState{Float64}}(undef, length(M))\nfor i = 1:length(M)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # moment on right side\n        nelem+1 => PrescribedConditions(Mz = M[i])\n    )\n\n    # perform a static analysis\n    static_analysis!(system, assembly;\n        prescribed_conditions=prescribed_conditions)\n\n    # post-process the results\n    states[i] = AssemblyState(system, assembly;\n        prescribed_conditions=prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This problem has a simple analytical solution, which we obtained from \"Study of the Geometric Stiffening Effect: Comparison of Different Formulations\" by Juana M. Mayo, Daniel Garcia-Vallejo, and Jaime Dominguez.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# analytical solution (ρ = E*I/M)\nanalytical(x, ρ) = ifelse(ρ == Inf, zeros(3), [ρ*sin(x/ρ)-x, ρ*(1-cos(x/ρ)), 0])\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational results show excellent agreement.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nglobal x #hide\n\nusing Plots\npyplot()\n\n# set up the plot\nplot(\n    xlim = (-0.25, 1.1),\n    xticks = -0.25:0.25:1.0,\n    xlabel = \"x/L\",\n    ylim = (-0.05, 0.8),\n    yticks = 0.0:0.2:0.8,\n    ylabel = \"y/L\",\n    aspect_ratio = 1.0,\n    grid = false,\n    overwrite_figure=false\n    )\n\n# create dummy legend entries for GXBeam and Analytical\nscatter!([], [], color=:black, label=\"GXBeam\")\nplot!([], [], color=:black, label=\"Analytical\")\n\n# plot the data\nfor i = 1:length(M)\n    local x, y #hide\n    # GXBeam\n    x = [assembly.points[ipoint][1] + states[i].points[ipoint].u[1] for ipoint =\n        1:length(assembly.points)]\n    y = [assembly.points[ipoint][2] + states[i].points[ipoint].u[2] for ipoint =\n        1:length(assembly.points)]\n    scatter!(x/L, y/L, label=\"\", color = i)\n\n    # Analytical\n    x0 = range(0, L, length=100)\n    deflection = analytical.(x0, E*Iyy/M[i])\n    x = (x0 + getindex.(deflection, 1))\n    y = getindex.(deflection, 2)\n    plot!(x/L, y/L, label=\"λ=$(λ[i])\", color=i)\nend\n\nsavefig(\"cantilever-tipmoment.svg\"); nothing #hide\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Analysis-of-the-Bending-of-a-Curved-Beam-in-3D-Space","page":"Examples","title":"Nonlinear Analysis of the Bending of a Curved Beam in 3D Space","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is also a common benchmark problem for the geometrically exact bending of nonlinear beams.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\n# problem constants\nR = 100\nL = R*pi/4 # inches\nh = w = 1 # inches\nE = 1e7 # psi Young's Modulus\nν = 0.0\nG = E/(2*(1+ν))\n\n# beam starting point, frame, and curvature\nstart = [0, 0, 0]\nframe = [0 -1 0; 1 0 0; 0 0 1]\ncurvature = [0, 0, -1/R]\n\n# cross section properties\nA = h*w\nAy = A\nAz = A\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\n# discretize the beam\nnelem = 16\nΔL, xp, xm, Cab = discretize_beam(L, start, nelem;\n    frame = frame,\n    curvature = curvature)\n\n# force\nP = 600 # lbs\n\n# index of left and right endpoints of each beam element\npt1 = 1:nelem\npt2 = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*J), 1/(E*Iyy),\n    1/(E*Izz)]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(xp, pt1, pt2, compliance=compliance, frames=Cab,\n    lengths=ΔL, midpoints=xm)\n\n# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # fixed left endpoint\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    # force on right endpoint\n    nelem+1 => PrescribedConditions(Fz = P)\n)\n\n# perform static analysis\nsystem, converged = static_analysis(assembly;\n    prescribed_conditions = prescribed_conditions)\n\n# post-process results\nstate = AssemblyState(system, assembly;\n    prescribed_conditions = prescribed_conditions)\n\nprintln(\"Tip Displacement: \", state.points[end].u)\nprintln(\"Tip Displacement (Bathe and Bolourch): [-13.4, -23.5, 53.4]\")\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The calculated tip displacements match those reported by Bathe and Bolourch in \"Large Displacement Analysis of Three-Dimensional Beam Structures\" closely, thus verifying our implementation of geometrically exact beam theory.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can visualize the deformed geometry and inspect the associated point and element data using ParaView.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"cantilever-curved\", assembly, state)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Rotating-Beam-with-a-Swept-Tip","page":"Examples","title":"Rotating Beam with a Swept Tip","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we analyze a rotating beam with a swept tip.  The parameters for this example come from \"Finite element solution of nonlinear intrinsic equations for curved composite beams\" by Hodges, Shang, and Cesnik.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\nsweep = 45 * pi/180\nrpm = 0:25:750\n\n# straight section of the beam\nL_b1 = 31.5 # inch\nr_b1 = [2.5, 0, 0]\nnelem_b1 = 13\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)\n\n# swept section of the beam\nL_b2 = 6 # inch\nr_b2 = [34, 0, 0]\nnelem_b2 = 3\ncs, ss = cos(sweep), sin(sweep)\nframe_b2 = [cs ss 0; -ss cs 0; 0 0 1]\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2;\n    frame = frame_b2)\n\n# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2\npoints = vcat(xp_b1, xp_b2[2:end])\nstart = 1:nelem_b1 + nelem_b2\nstop = 2:nelem_b1 + nelem_b2 + 1\nlengths = vcat(lengths_b1, lengths_b2)\nmidpoints = vcat(xm_b1, xm_b2)\nCab = vcat(Cab_b1, Cab_b2)\n\n# cross section\nw = 1 # inch\nh = 0.063 # inch\n\n# material properties\nE = 1.06e7 # lb/in^2\nν = 0.325\nρ = 2.51e-4 # lb sec^2/in^4\n\n# shear and torsion correction factors\nky = 1.2000001839588001\nkz = 14.625127919304001\nkt = 65.85255016982444\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\n# apply corrections\nAy = A/ky\nAz = A/kz\nJx = J/kt\n\nG = E/(2*(1+ν))\n\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy),\n    1/(E*Izz)]), nelem)\n\nmass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop;\n    compliance = compliance,\n    mass = mass,\n    frames = Cab,\n    lengths = lengths,\n    midpoints = midpoints)\n\n# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # root section is fixed\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n    )\n\nnonlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nfor i = 1:length(rpm)\n    # global frame rotation\n    w0 = [0, 0, rpm[i]*(2*pi)/60]\n\n    # perform nonlinear steady state analysis\n    system, converged = steady_state_analysis(assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions)\n\n    nonlinear_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\n\n    # perform linear steady state analysis\n    system, converged = steady_state_analysis(assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions,\n        linear = true)\n\n    linear_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To visualize the solutions we will plot the root moment and tip deflections against the angular speed.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nglobal x #hide\n\nusing Plots\npyplot()\n\n# root moment\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    yticks = 0.0:2:12,\n    ylabel = \"\\$M_z\\$ at the root (lb-in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nMz_nl = [-nonlinear_states[i].points[1].M[3] for i = 1:length(rpm)]\nMz_l = [-linear_states[i].points[1].M[3] for i = 1:length(rpm)]\nplot!(rpm, Mz_nl, label=\"Nonlinear\")\nplot!(rpm, Mz_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-Mz.svg\"); nothing #hide\n\n# x tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.002, 0.074),\n    yticks = 0.0:0.01:0.07,\n    ylabel = \"\\$u_x\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nux_nl = [nonlinear_states[i].points[end].u[1] for i = 1:length(rpm)]\nux_l = [linear_states[i].points[end].u[1] for i = 1:length(rpm)]\nplot!(rpm, ux_nl, label=\"Nonlinear\")\nplot!(rpm, ux_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-ux.svg\"); nothing #hide\n\n# y tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.01, 0.27),\n    yticks = 0.0:0.05:0.25,\n    ylabel = \"\\$u_y\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nuy_nl = [nonlinear_states[i].points[end].u[2] for i = 1:length(rpm)]\nuy_l = [linear_states[i].points[end].u[2] for i = 1:length(rpm)]\nplot!(rpm, uy_nl, label=\"Nonlinear\")\nplot!(rpm, uy_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-uy.svg\"); nothing #hide\n\n# rotation of the tip\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylabel = \"\\$θ_z\\$ at the tip\",\n    grid = false,\n    overwrite_figure=false\n    )\ntheta_z_nl = [4*atan(nonlinear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]\ntheta_z_l = [4*atan(linear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]\n\nplot!(rpm, theta_z_nl, label=\"Nonlinear\")\nplot!(rpm, theta_z_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-theta_z.svg\"); nothing #hide\n\nend #hide\n\nnothing #hide\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We will now compute the eigenvalues of this system for a range of sweep angles and and angular speeds.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nsweep = (0:2.5:45) * pi/180\nrpm = [0, 500, 750]\nnev = 30\n\nλ = Matrix{Vector{ComplexF64}}(undef, length(sweep), length(rpm))\nU = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))\nMV = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))\nstate = Matrix{AssemblyState{Float64}}(undef, length(sweep), length(rpm))\neigenstates = Matrix{Vector{AssemblyState{ComplexF64}}}(undef, length(sweep), length(rpm))\nfor i = 1:length(sweep)\n    local L_b1, r_b1, nelem_b1, lengths_b1 #hide\n    local xp_b1, xm_b1, Cab_b1 #hide\n    local cs, ss #hide\n    local L_b2, r_b2, nelem_b2, frame_b2, lengths_b2 #hide\n    local xp_b2, xm_b2, Cab_b2 #hide\n    local nelem, points, start, stop #hide\n    local lengths, midpoints, Cab, compliance, mass, assembly #hide\n\n    # straight section of the beam\n    L_b1 = 31.5 # inch\n    r_b1 = [2.5, 0, 0]\n    nelem_b1 = 20\n    lengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)\n\n    # swept section of the beam\n    L_b2 = 6 # inch\n    r_b2 = [34, 0, 0]\n    nelem_b2 = 20\n    cs, ss = cos(sweep[i]), sin(sweep[i])\n    frame_b2 = [cs ss 0; -ss cs 0; 0 0 1]\n    lengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2;\n        frame = frame_b2)\n\n    # combine elements and points into one array\n    nelem = nelem_b1 + nelem_b2\n    points = vcat(xp_b1, xp_b2[2:end])\n    start = 1:nelem_b1 + nelem_b2\n    stop = 2:nelem_b1 + nelem_b2 + 1\n    lengths = vcat(lengths_b1, lengths_b2)\n    midpoints = vcat(xm_b1, xm_b2)\n    Cab = vcat(Cab_b1, Cab_b2)\n\n    compliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx),\n        1/(E*Iyy), 1/(E*Izz)]), nelem)\n\n    mass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)\n\n    # create assembly\n    assembly = Assembly(points, start, stop;\n        compliance = compliance,\n        mass = mass,\n        frames = Cab,\n        lengths = lengths,\n        midpoints = midpoints)\n\n    # create system\n    keep_points = [1, nelem_b1+1, nelem+1]\n    system = System(assembly, keep_points, false)\n\n    for j = 1:length(rpm)\n        # global frame rotation\n        w0 = [0, 0, rpm[j]*(2*pi)/60]\n\n        # eigenvalues and (right) eigenvectors\n        system, λ[i,j], V, converged = eigenvalue_analysis!(system, assembly;\n            angular_velocity = w0,\n            prescribed_conditions = prescribed_conditions,\n            nev = nev)\n\n        # corresponding left eigenvectors\n        U[i,j] = left_eigenvectors(system, λ[i,j], V)\n\n        # post-multiply mass matrix with right eigenvector matrix\n        # (we use this later for correlating eigenvalues)\n        MV[i,j] = system.M * V\n\n        # process state and eigenstates\n        state[i,j] = AssemblyState(system, assembly;\n            prescribed_conditions = prescribed_conditions)\n        eigenstates[i,j] = [AssemblyState(system, assembly, V[:,k];\n            prescribed_conditions = prescribed_conditions) for k = 1:nev]\n    end\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can correlate each eigenmode by taking advantage of the fact that left and right eigenvectors satisfy the following relationships:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginaligned\nu^H M v = 1 textif (u) and (v) correspond to the same eigenmode \nu^H M v = 0 textif (u) and (v) correspond to different eigenmodes\nendaligned","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# set previous left eigenvector matrix\nU_p = copy(U[1,1])\n\nfor j = 1:length(rpm)\n    for i = 1:length(sweep)\n        # construct correlation matrix\n        C = U_p*MV[i,j]\n\n        # correlate eigenmodes\n        perm, corruption = correlate_eigenmodes(C)\n\n        # re-arrange eigenvalues and eigenvectors\n        λ[i,j] = λ[i,j][perm]\n        U[i,j] = U[i,j][perm,:]\n        MV[i,j] = MV[i,j][:,perm]\n        eigenstates[i,j] = eigenstates[i,j][perm]\n\n        # update previous eigenvector matrix\n        U_p .= U[i,j]\n    end\n    # update previous eigenvector matrix\n    U_p .= U[1,j]\nend\n\nfrequency = [[imag(λ[i,j][k])/(2*pi) for i = 1:length(sweep), j=1:length(rpm)]\n    for k = 1:2:nev]\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this case these eigenmode correlations work, but remember that large changes in the underlying parameters (or just drastic changes in the eigenvectors themselves due to a small perturbation) can cause these automatic eigenmode correlations to fail.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We'll now plot the frequency of the different eigenmodes against those found by Epps and Chandra in \"The Natural Frequencies of Rotating Composite Beams With Tip Sweep\".","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nglobal x #hide\n\nnames = [\"First Bending Mode\", \"Second Bending Mode\", \"Third Bending Mode\"]\nindices = [1, 2, 4]\n\nexperiment_rpm = [0, 500, 750]\nexperiment_sweep = [0, 15, 30, 45]\nexperiment_frequencies = [\n    [1.4 1.8 1.7 1.6;\n     10.2 10.1 10.2 10.2;\n     14.8 14.4 14.9 14.7],\n    [10.3 10.2 10.4 10.4;\n     25.2 25.2 23.7 21.6;\n     36.1 34.8 30.7 26.1],\n    [27.7 27.2 26.6 24.8;\n     47.0 44.4 39.3 35.1;\n     62.9 55.9 48.6 44.8]\n]\n\nplot!([], [], color=:black, label=\"GXBeam\")\nscatter!([], [], color=:black, label = \"Experiment (Epps and Chandra)\")\n\nfor k = 1:length(indices)\n    plot(\n        title = names[k],\n        xticks = 0:15:45,\n        xlabel = \"Sweep Angle (degrees)\",\n        ylim = (0, Inf),\n        ylabel = \"Frequency (Hz)\",\n        grid = false,\n        overwrite_figure=false\n        )\n\n    for j = length(rpm):-1:1\n        plot!(sweep*180/pi, frequency[indices[k]][:,j],\n            label=\"$(rpm[j]) RPM\", color=j)\n        scatter!(experiment_sweep, experiment_frequencies[k][j,:],\n            label=\"\", color=j)\n    end\n\n    plot!(show=true)\n    savefig(\"rotating-beam-frequencies-$(k).svg\") #hide\nend\n\nnames = [\"1T/5B\", \"5B/1T\", \"4B/1T\"]\nindices = [5, 7, 6]\n\nexperiment_frequencies = [\n    132.7 147.3 166.2 162.0\n    106.6 120.1 122.6 117.7;\n    95.4 87.5 83.7 78.8;\n]\n\nplot(\n    title = \"Coupled Torsion-Bending Modes at 750 RPM\",\n    xticks = 0:15:45,\n    xlabel = \"Sweep Angle (degrees)\",\n    ylim = (0, Inf),\n    ylabel = \"Frequency (Hz)\",\n    legend = :bottomleft,\n    grid = false,\n    overwrite_figure=false\n    )\n\nplot!([], [], color=:black, label=\"GXBeam\")\nscatter!([], [], color=:black,\n    label=\"Experiment (Epps and Chandra)\")\n\nfor k = 1:length(indices)\n    plot!(sweep*180/pi, frequency[indices[k]][:,end], label=names[k], color=k)\n    scatter!(experiment_sweep, experiment_frequencies[k,:],\n        label=\"\", color=k)\nend\n\nplot!(show=true)\n\nsavefig(\"rotating-beam-frequencies-4.svg\"); nothing #hide\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As you can see, the frequency results from the eigenmode analysis in this package compare well with experimental results.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also visualize eigenmodes using ParaView.  Here we will visualize the first bending mode for the 45 degree swept tip at a rotational speed of 750 RPM.  This can be helpful for identifying different eigenmodes.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"rotating-beam-45d-750rpm-bending-mode-1\", assembly, state[end,end], λ[end,end][1],\n    eigenstates[end,end][1], mode_scaling=100.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Dynamic-Analysis-of-a-Wind-Turbine-Blade","page":"Examples","title":"Nonlinear Dynamic Analysis of a Wind Turbine Blade","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\nL = 60 # m\n\n# create points\nnelem = 10\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# stiffness matrix for each beam element\nstiffness = fill(\n    [2.389e9  1.524e6  6.734e6 -3.382e7 -2.627e7 -4.736e8\n     1.524e6  4.334e8 -3.741e6 -2.935e5  1.527e7  3.835e5\n     6.734e6 -3.741e6  2.743e7 -4.592e5 -6.869e5 -4.742e6\n    -3.382e7 -2.935e5 -4.592e5  2.167e7 -6.279e5  1.430e6\n    -2.627e7  1.527e7 -6.869e5 -6.279e5  1.970e7  1.209e7\n    -4.736e8  3.835e5 -4.742e6  1.430e6  1.209e7  4.406e8],\n    nelem)\n\n# mass matrix for each beam element\nmass = fill(\n    [258.053      0.0        0.0      0.0      7.07839  -71.6871\n       0.0      258.053      0.0     -7.07839  0.0        0.0\n       0.0        0.0      258.053   71.6871   0.0        0.0\n       0.0       -7.07839   71.6871  48.59     0.0        0.0\n       7.07839    0.0        0.0      0.0      2.172      0.0\n     -71.6871     0.0        0.0      0.0      0.0       46.418],\n     nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop; stiffness=stiffness, mass=mass)\n\n# prescribed conditions\nprescribed_conditions = (t) -> begin\n    Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force on right side\n        nelem+1 => PrescribedConditions(Fz = 1e5*sin(20*t))\n    )\nend\n\n# simulation time\nt = 0:0.001:2.0\n\nsystem, history, converged = time_domain_analysis(assembly, t;\n    prescribed_conditions = prescribed_conditions)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can visualize tip displacements and the resultant forces in the root by accessing the post-processed results for each time step contained in the variable history.  Note that  the root resultant forces for this case are equal to the external forces/moments, but with opposite sign.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nglobal x #hide\n\nusing Plots\npyplot()\n\npoint = vcat(fill(nelem+1, 6), fill(1, 6))\nfield = [:u, :u, :u, :theta, :theta, :theta, :F, :F, :F, :M, :M, :M]\ndirection = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\nylabel = [\"\\$u_x\\$ (\\$m\\$)\", \"\\$u_y\\$ (\\$m\\$)\", \"\\$u_z\\$ (\\$m\\$)\",\n    \"Rodriguez Parameter \\$\\\\theta_x\\$ (degree)\",\n    \"Rodriguez Parameter \\$\\\\theta_y\\$ (degree)\",\n    \"Rodriguez Parameter \\$\\\\theta_z\\$ (degree)\",\n    \"\\$F_x\\$ (\\$N\\$)\", \"\\$F_y\\$ (\\$N\\$)\", \"\\$F_z\\$ (\\$N\\$)\",\n    \"\\$M_x\\$ (\\$Nm\\$)\", \"\\$M_y\\$ (\\$Nm\\$)\", \"\\$M_z\\$ (\\$N\\$)\"]\n\nfor i = 1:12\n    local y #hide\n    plot(\n        xlim = (0, 2.0),\n        xticks = 0:0.5:2.0,\n        xlabel = \"Time (s)\",\n        ylabel = ylabel[i],\n        grid = false,\n        overwrite_figure=false\n        )\n    y = [getproperty(state.points[point[i]], field[i])[direction[i]]\n        for state in history]\n\n    if field[i] == :theta\n        # convert to Rodriguez parameter\n        @. y = 4*atan(y/4)\n        # convert to degrees\n        @. y = rad2deg(y)\n    end\n\n    if field[i] == :F || field[i] == :M\n        y = -y\n    end\n\n    plot!(t, y, label=\"\")\n    plot!(show=true)\n    savefig(\"dynamic-wind-turbine-\"*string(field[i])*string(direction[i])*\".svg\"); nothing #hide\nend\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These plots are identical to those presented by Qi Wang, Wenbin Yu, and Michael A. Sprague in \"Geometric Nonlinear Analysis of Composite Beams Using Wiener-Milenkovic Parameters\".","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also visualize the time history of the system using ParaView.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"dynamic-wind-turbine\", assembly, history, t)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Static-Analysis-of-a-Joined-Wing","page":"Examples","title":"Nonlinear Static Analysis of a Joined-Wing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we analyze joined-wing model proposed by Blair in \"An Equivalent Beam Formulation for Joined-Wings in a Post-Buckled State\" and optimized by Green et al. in \"Structural Optimization of Joined-Wing Beam Model with Bend-Twist Coupling using Equivalent Static Loads\".","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\n# Set endpoints of each beam\np1 = [-7.1726, -12, -3.21539]\np2 = [-5.37945, -9, -2.41154]\np3 = [-3.5863, -6, -1.6077]\np4 = [-1.79315, -3, -0.803848]\np5 = [0, 0, 0]\np6 = [7.1726, -12, 3.21539]\n\n# get transformation matrix for left beams\n\n# transformation from intermediate frame to global frame\ntmp1 = sqrt(p1[1]^2 + p1[2]^2)\nc1, s1 = -p1[1]/tmp1, -p1[2]/tmp1\nrot1 = [c1 -s1 0; s1 c1 0; 0 0 1]\n\n# transformation from local beam frame to intermediate frame\ntmp2 = sqrt(p1[1]^2 + p1[2]^2 + p1[3]^2)\nc2, s2 = tmp1/tmp2, -p1[3]/tmp2\nrot2 = [c2 0 -s2; 0 1 0; s2 0 c2]\n\nCab_1 = rot1*rot2\n\n# get transformation matrix for right beam\n\n# transformation from intermediate frame to global frame\ntmp1 = sqrt(p6[1]^2 + p6[2]^2)\nc1, s1 = p6[1]/tmp1, p6[2]/tmp1\nrot1 = [c1 -s1 0; s1 c1 0; 0 0 1]\n\n# transformation from local beam frame to intermediate frame\ntmp2 = sqrt(p6[1]^2 + p6[2]^2 + p6[3]^2)\nc2, s2 = tmp1/tmp2, p6[3]/tmp2\nrot2 = [c2 0 -s2; 0 1 0; s2 0 c2]\n\nCab_2 = rot1*rot2\n\n# beam 1\nL_b1 = norm(p2-p1)\nr_b1 = p1\nnelem_b1 = 5\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1;\n    frame = Cab_1)\ncompliance_b1 = fill(Diagonal([1.05204e-9, 3.19659e-9, 2.13106e-8, 1.15475e-7,\n    1.52885e-7, 7.1672e-9]), nelem_b1)\n\n# beam 2\nL_b2 = norm(p3-p2)\nr_b2 = p2\nnelem_b2 = 5\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2;\n    frame = Cab_1)\ncompliance_b2 = fill(Diagonal([1.24467e-9, 3.77682e-9, 2.51788e-8, 1.90461e-7,\n    2.55034e-7, 1.18646e-8]), nelem_b2)\n\n# beam 3\nL_b3 = norm(p4-p3)\nr_b3 = p3\nnelem_b3 = 5\nlengths_b3, xp_b3, xm_b3, Cab_b3 = discretize_beam(L_b3, r_b3, nelem_b3;\n    frame = Cab_1)\ncompliance_b3 = fill(Diagonal([1.60806e-9, 4.86724e-9, 3.24482e-8, 4.07637e-7,\n    5.57611e-7, 2.55684e-8]), nelem_b3)\n\n# beam 4\nL_b4 = norm(p5-p4)\nr_b4 = p4\nnelem_b4 = 5\nlengths_b4, xp_b4, xm_b4, Cab_b4 = discretize_beam(L_b4, r_b4, nelem_b4;\n    frame = Cab_1)\ncompliance_b4 = fill(Diagonal([2.56482e-9, 7.60456e-9, 5.67609e-8, 1.92171e-6,\n    2.8757e-6, 1.02718e-7]), nelem_b4)\n\n# beam 5\nL_b5 = norm(p6-p5)\nr_b5 = p5\nnelem_b5 = 20\nlengths_b5, xp_b5, xm_b5, Cab_b5 = discretize_beam(L_b5, r_b5, nelem_b5;\n    frame = Cab_2)\ncompliance_b5 = fill(Diagonal([2.77393e-9, 7.60456e-9, 1.52091e-7, 1.27757e-5,\n    2.7835e-5, 1.26026e-7]), nelem_b5)\n\n# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + nelem_b5\npoints = vcat(xp_b1, xp_b2[2:end], xp_b3[2:end], xp_b4[2:end], xp_b5[2:end])\nstart = 1:nelem\nstop = 2:nelem + 1\nlengths = vcat(lengths_b1, lengths_b2, lengths_b3, lengths_b4, lengths_b5)\nmidpoints = vcat(xm_b1, xm_b2, xm_b3, xm_b4, xm_b5)\nCab = vcat(Cab_b1, Cab_b2, Cab_b3, Cab_b4, Cab_b5)\ncompliance = vcat(compliance_b1, compliance_b2, compliance_b3, compliance_b4,\n    compliance_b5)\n\n# create assembly\nassembly = Assembly(points, start, stop;\n    compliance = compliance,\n    frames = Cab,\n    lengths = lengths,\n    midpoints = midpoints)\n\nFz = range(0, 70e3, length=141)\n\n# pre-allocate memory to reduce run-time\nijoint = nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1\npoints_to_keep = [1, ijoint, nelem+1]\nstatic = true\nsystem = System(assembly, points_to_keep, static)\n\nlinear_states = Vector{AssemblyState{Float64}}(undef, length(Fz))\nfor i = 1:length(Fz)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed endpoint on beam 1\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force applied on point 4\n        nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1 => PrescribedConditions(Fz = Fz[i]),\n        # fixed endpoint on last beam\n        nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    )\n\n    static_analysis!(system, assembly;\n        prescribed_conditions = prescribed_conditions,\n        linear = true)\n\n    linear_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\n\nend\n\nreset_state!(system)\nnonlinear_states = Vector{AssemblyState{Float64}}(undef, length(Fz))\nfor i = 1:length(Fz)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed endpoint on beam 1\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force applied on point 4\n        nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1 => PrescribedConditions(Fz = Fz[i]),\n        # fixed endpoint on last beam\n        nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    )\n\n    static_analysis!(system, assembly;\n        prescribed_conditions=prescribed_conditions, reset_state=false)\n\n    nonlinear_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\n\nend\n\nreset_state!(system)\nnonlinear_follower_states = Vector{AssemblyState{Float64}}(undef, length(Fz))\nfor i = 1:length(Fz)\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed endpoint on beam 1\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force applied on point 4\n        nelem_b1 + nelem_b2 + nelem_b3 + nelem_b4 + 1 =>\n            PrescribedConditions(Fz_follower = Fz[i]),\n        # fixed endpoint on last beam\n        nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    )\n\n    static_analysis!(system, assembly;\n        prescribed_conditions=prescribed_conditions, reset_state=false)\n\n    nonlinear_follower_states[i] = AssemblyState(system, assembly;\n        prescribed_conditions = prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that we incrementally increased the load from 0 to 70 kN in order to ensure that we obtained converged solutions.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To visualize the differences between the different types of analyses we can plot the load deflection curve.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nglobal x #hide\n\nusing Plots\npyplot()\n\nplot(\n    xlim = (0, 7),\n    xticks = 0:1:7,\n    xlabel = \"Vertical Displacement at the Joint (m)\",\n    yticks = 0:10:70,\n    ylim = (0, 70),\n    ylabel = \"Load (kN)\",\n    grid = false,\n    overwrite_figure=false\n    )\nuz_l = [linear_states[i].points[ijoint].u[3] for i = 1:length(Fz)]\nuz_nl = [nonlinear_states[i].points[ijoint].u[3] for i = 1:length(Fz)]\nuz_fnl = [nonlinear_follower_states[i].points[ijoint].u[3] for i = 1:length(Fz)]\n\nplot!(uz_l, Fz./1e3, label=\"Linear\")\nplot!(uz_nl, Fz./1e3, label=\"Nonlinear with Dead Force\")\nplot!(uz_fnl, Fz./1e3, label=\"Nonlinear with Follower Force\")\n\nsavefig(\"static-joined-wing.svg\"); nothing #hide\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This plot matches the plot provided by Wenbin Yu in \"GEBT: A general-purpose nonlinear analysis tool for composite beams\".","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also visualize the deformed geometry and inspect the associated point and element data for any of these operating conditions conditions using ParaView.  To demonstrate we will visualize the 70kN follower force condition and set the color gradient to match the magnitude of the deflections.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"static-joined-wing\", assembly, nonlinear_follower_states[end])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Dynamic-Analysis-of-a-Joined-Wing","page":"Examples","title":"Nonlinear Dynamic Analysis of a Joined-Wing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we use the same joined-wing model as used in the previous example, but with the following time varying loads applied at the wingtip:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A piecewise-linear load F_L in the x and y-directions defined as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"F_L(t) = begincases\n    t10^6 text N  0 leq t leq 001 \n    (002-t)10^6  001 leq t leq 002 \n    0  textotherwise\nendcases","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A sinusoidal load F_S applied in the z-direction defined as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"F_S(t) = begincases\n    0  t lt 0 \n    5 times 10^3 (1-cos(pi t 002)) text N  0 leq t lt 002 \n    10^4 text N  002 leq t\nendcases","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We will also use the same compliance and mass matrix for all beams, in order to simplify the problem definition.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GXBeam, LinearAlgebra\n\n# Set endpoints of each beam\np1 = [0, 0, 0]\np2 = [-7.1726, -12, -3.21539]\np3 = [7.1726, -12,  3.21539]\n\nCab_1 = [\n0.5         0.866025  0.0   \n0.836516    -0.482963  0.258819\n0.224144     -0.12941   -0.965926\n]\n\nCab_2 = [\n0.5         0.866025  0.0   \n-0.836516    0.482963 0.258819\n0.224144    -0.12941   0.965926\n]\n\n# beam 1\nL_b1 = norm(p1-p2)\nr_b1 = p2\nnelem_b1 = 8\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1, frame=Cab_1)\n\n# beam 2\nL_b2 = norm(p3-p1)\nr_b2 = p1\nnelem_b2 = 8\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, frame=Cab_2)\n\n# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2\npoints = vcat(xp_b1, xp_b2[2:end])\nstart = 1:nelem\nstop = 2:nelem + 1\nlengths = vcat(lengths_b1, lengths_b2)\nmidpoints = vcat(xm_b1, xm_b2)\nCab = vcat(Cab_b1, Cab_b2)\n\n# assign all beams the same compliance and mass matrix\ncompliance = fill(Diagonal([2.93944738387698e-10, 8.42991725049126e-10,\n    3.38313996669689e-08, 4.69246721094557e-08, 6.79584100559513e-08,\n    1.37068861370898e-09]), nelem)\nmass = fill(Diagonal([4.86e-2, 4.86e-2, 4.86e-2, 1.0632465e-2, 2.10195e-4,\n    1.042227e-2]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop;\n    compliance = compliance,\n    mass = mass,\n    frames = Cab,\n    lengths = lengths,\n    midpoints = midpoints)\n\nF_L = (t) -> begin\n    if 0.0 <= t < 0.01\n        1e6*t\n    elseif 0.01 <= t < 0.02\n        -1e6*(t-0.02)\n    else\n        zero(t)\n    end\nend\n\nF_S = (t) -> begin\n    if t < 0.0\n        zero(t)\n    elseif 0.0 <= t < 0.02\n        5e3*(1-cos(pi*t/0.02))\n    else\n        1e4\n    end\nend\n\n# assign boundary conditions and point load\nprescribed_conditions = (t) -> begin\n    Dict(\n        # fixed endpoint on beam 1\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force applied on point 4\n        nelem_b1 + 1 => PrescribedConditions(Fx=F_L(t), Fy=F_L(t), Fz=F_S(t)),\n        # fixed endpoint on last beam\n        nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    )\nend\n\n# time\nt = range(0, 0.04, length=1001)\n\nsystem, history, converged = time_domain_analysis(assembly, t;\n    prescribed_conditions=prescribed_conditions)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can visualize tip displacements and the resultant forces accessing the post-processed results for each time step contained in the variable history.  Note that the fore-root and rear-root resultant forces for this case are equal to the external forces/moments, but with opposite sign.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing Suppressor #hide\n\n@suppress_err begin #hide\n\nglobal x #hide\n\nusing Plots\npyplot()\n\npoint = vcat(fill(nelem_b1+1, 6), fill(1, 6))\nfield = [:u, :u, :u, :theta, :theta, :theta, :F, :F, :F, :M, :M, :M]\ndirection = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\nylabel = [\"\\$u_x\\$ (\\$m\\$)\", \"\\$u_y\\$ (\\$m\\$)\", \"\\$u_z\\$ (\\$m\\$)\",\n    \"Rodriguez Parameter \\$\\\\theta_x\\$\", \"Rodriguez Parameter \\$\\\\theta_y\\$\",\n    \"Rodriguez Parameter \\$\\\\theta_z\\$\", \"\\$F_x\\$ at the forewing root (\\$N\\$)\",\n    \"\\$F_y\\$ at the forewing root (\\$N\\$)\", \"\\$F_z\\$ at the forewing root (\\$N\\$)\",\n    \"\\$M_x\\$ at the forewing root (\\$Nm\\$)\", \"\\$M_y\\$ at the forewing root (\\$Nm\\$)\",\n    \"\\$M_z\\$ at the forewing root (\\$N\\$)\"]\n\nfor i = 1:12\n    local y #hide\n    plot(\n        xlim = (0, 0.04),\n        xticks = 0:0.01:0.04,\n        xlabel = \"Time (s)\",\n        ylabel = ylabel[i],\n        grid = false,\n        overwrite_figure=false\n        )\n    y = [getproperty(state.points[point[i]], field[i])[direction[i]] for state in history]\n\n    if field[i] == :theta\n        # convert to angle\n        @. y = 4*atan(y/4)\n    end\n\n    if field[i] == :F || field[i] == :M\n        y = -y\n    end\n\n    plot!(t, y, label=\"\")\n    plot!(show=true)\n    savefig(\"dynamic-joined-wing-\"*string(field[i])*string(direction[i])*\".svg\"); nothing #hide\nend\n\nend #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These graphs are identical to those presented in \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and Maxwell Blair.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also visualize the time history of the system using ParaView.  In order to view the small deflections we'll scale all the deflections up by a couple orders of magnitude.  We'll also set the color gradient to match the magnitude of the deflections at each point.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"dynamic-joined-wing\", assembly, history, t, scaling=1e2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"#GXBeam","page":"Home","title":"GXBeam","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pure Julia Implementation of Geometrically Exact Beam Theory","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Taylor McDonnell","category":"page"},{"location":"","page":"Home","title":"Home","text":"GXBeam is a pure Julia implementation of Geometrically Exact Beam Theory, based on the open source code GEBT and its associated papers[1][2].","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a sample of one of the many things this package can do, here's a time domain simulation of the dynamic response of a joined wing subjected to a simulated gust, scaled up in order to visualize the deflections: (Image: )","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Performs multiple types of analyses including:\nLinear/Nonlinear static analyses\nLinear/Nonlinear steady-state dynamic analyses\nLinear/Nonlinear eigenvalue analyses (by linearizing about a steady state condition)\nLinear/Nonlinear time-marching dynamic analyses\nAccurately models arbitrary systems of interconnected highly flexible composite beams.\nCaptures all geometric nonlinearities due to large deflections and rotations\nCapable of using the full 6x6 Timoshenko beam stiffness matrix\nSingularity-free rotational deflections of any magnitude using only 3 rotational parameters\nModels arbitrary time-varying distributed forces/moments on beam elements using:\nDead forces/moments (which do not rotate as the beam element rotates)\nFollower forces/moments (which rotate as the beam element rotates)\nModels arbitrary time-varying prescribed forces/moments and/or displacements/rotations at the connection points between beam elements using:\nDead forces/moments (which do not rotate as the point rotates)\nFollower forces/moments (which rotate as the point rotates)\nCapable of using arbitrary units (as long as they are compatible)\nSimple result visualization using WriteVTK\nBuilt-in DifferentialEquations interface for time domain simulations. \nExtensively validated against published analytical and computational results. See the examples.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the package manager by typing ] and then run the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add GXBeam","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This code has been optimized to be highly performant, primarily by maintaining type stability and minimizing allocations.  As a result the performance of this package rivals (or even outperforms) that of the Fortran implementation in GEBT.  At this point, differences in performance between the two codes can be primarily attributed to the performance of the sparse linear system solver in each.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the examples","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that while the theoretical basis for this code is identical to Wenbin Yu's code, some of the implementation details vary.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Yu, W., & Blair, M. (2012). GEBT: A general-purpose nonlinear analysis tool for composite beams. Composite Structures, 94(9), 2677-2689.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Wang, Q., & Yu, W. (2017). Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters. Journal of Renewable and Sustainable Energy, 9(3), 033306.","category":"page"},{"location":"diffeq/#Using-GXBeam-with-DifferentialEquations.jl","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"","category":"section"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"While the capabilities provided by GXBeam are probably sufficient for most users, advanced users may wish to make use of some of the features of the DifferentialEquations package.  For this reason, we have created an interface in GXBeam to allow users to model the differential algebraic equations encountered in GXBeam in DifferentialEquations.","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"Pages = [\"diffeq.md\"]\nDepth = 3","category":"page"},{"location":"diffeq/#Interface-Functions","page":"Using GXBeam with DifferentialEquations.jl","title":"Interface Functions","text":"","category":"section"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"The following constructors are available for modeling the differential algebraic equations from GXBeam in DifferentialEquations.","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"GXBeam.ODEFunction(system::System, assembly; kwargs...)\nGXBeam.ODEProblem(system::System, assembly; kwargs...)\nGXBeam.DAEFunction(system::System, assembly; kwargs...)\nGXBeam.DAEProblem(system::System, assembly, tspan; kwargs...)","category":"page"},{"location":"diffeq/#SciMLBase.ODEFunction-Tuple{System, Any}","page":"Using GXBeam with DifferentialEquations.jl","title":"SciMLBase.ODEFunction","text":"ODEFunction(system::GXBeam.System, assembly)\n\nConstruct a ODEFunction for the system of nonlinear beams contained in assembly which may be used with the DifferentialEquations package.\n\nThe parameters associated with the resulting ODEFunction are defined by the tuple (prescribed_conditions, distributed_loads, origin, linear_velocity, angular_velocity) where each parameter is defined as follows:\n\nprescribed_conditions: A dictionary with keys corresponding to the points at      which prescribed conditions are applied and elements of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads: A dictionary with keys corresponding to the elements to      which distributed loads are applied and elements of type      DistributedLoads which describe the distributed loads at those      points.  If time varying, this input may be provided as a function of      time.\norigin: Global frame origin vector. If time varying, this input      may be provided as a function of time.\nlinear_velocity: Global frame linear velocity vector. If time      varying, this vector may be provided as a function of time.\nangular_velocity: Global frame angular velocity vector. If time      varying, this vector may be provided as a function of time.\n\n\n\n\n\n","category":"method"},{"location":"diffeq/#SciMLBase.DAEFunction-Tuple{System, Any}","page":"Using GXBeam with DifferentialEquations.jl","title":"SciMLBase.DAEFunction","text":"DAEFunction(system::GXBeam.System, assembly)\n\nConstruct a DAEFunction for the system of nonlinear beams contained in assembly which may be used with the DifferentialEquations package.\n\nThe parameters associated with the resulting DAEFunction are defined by the tuple (prescribed_conditions, distributed_loads, origin, linear_velocity, angular_velocity) where each parameter is defined as follows:\n\nprescribed_conditions: A dictionary with keys corresponding to the points at      which prescribed conditions are applied and elements of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads: A dictionary with keys corresponding to the elements to      which distributed loads are applied and elements of type      DistributedLoads which describe the distributed loads at those      points.  If time varying, this input may be provided as a function of      time.\norigin: Global frame origin vector. If time varying, this input      may be provided as a function of time.\nlinear_velocity: Global frame linear velocity vector. If time      varying, this vector may be provided as a function of time.\nangular_velocity: Global frame angular velocity vector. If time      varying, this vector may be provided as a function of time.\n\n\n\n\n\n","category":"method"},{"location":"diffeq/#SciMLBase.DAEProblem-Tuple{System, Any, Any}","page":"Using GXBeam with DifferentialEquations.jl","title":"SciMLBase.DAEProblem","text":"DAEProblem(system::GXBeam.System, assembly, tspan; kwargs...)\n\nConstruct a DAEProblem for the system of nonlinear beams contained in assembly which may be used with the DifferentialEquations package.\n\nA consistent set of initial conditions may be obtained prior to constructing the DAEProblem using initial_condition_analysis! or by constructing a DAEProblem after a time domain analysis.\n\nKeyword Arguments:\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}():      A dictionary with keys corresponding to the points at      which prescribed conditions are applied and elements of type      PrescribedConditions which describe the prescribed conditions      at those points.  If time varying, this input may be provided as a      function of time.\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): A dictionary      with keys corresponding to the elements to which distributed loads are      applied and elements of type DistributedLoads which describe      the distributed loads at those points.  If time varying, this input may      be provided as a function of time.\norigin = zeros(3): Global frame origin vector. If time varying, this input      may be provided as a function of time.\nlinear_velocity = zeros(3): Global frame linear velocity vector. If time      varying, this vector may be provided as a function of time.\nangular_velocity = zeros(3): Global frame angular velocity vector. If time      varying, this vector may be provided as a function of time.\n\n\n\n\n\n","category":"method"},{"location":"diffeq/#Example-Usage","page":"Using GXBeam with DifferentialEquations.jl","title":"Example Usage","text":"","category":"section"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"For this example we demonstrate how to solve the Nonlinear Dynamic Analysis of a Wind Turbine Blade problem using DifferentialEquations.","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"We start by setting up the problem as if we were solving the problem using GXBeam's internal solver.","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"# this is placed here to pre-install matplotlib so the documentation doesn't get cluttered with the installation print statements.\nusing Plots\npyplot()","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"using GXBeam, LinearAlgebra\n\nL = 60 # m\n\n# create points\nnelem = 10\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# stiffness matrix for each beam element\nstiffness = fill(\n    [2.389e9  1.524e6  6.734e6 -3.382e7 -2.627e7 -4.736e8\n     1.524e6  4.334e8 -3.741e6 -2.935e5  1.527e7  3.835e5\n     6.734e6 -3.741e6  2.743e7 -4.592e5 -6.869e5 -4.742e6\n    -3.382e7 -2.935e5 -4.592e5  2.167e7 -6.279e5  1.430e6\n    -2.627e7  1.527e7 -6.869e5 -6.279e5  1.970e7  1.209e7\n    -4.736e8  3.835e5 -4.742e6  1.430e6  1.209e7  4.406e8],\n    nelem)\n\n# mass matrix for each beam element\nmass = fill(\n    [258.053      0.0        0.0      0.0      7.07839  -71.6871\n       0.0      258.053      0.0     -7.07839  0.0        0.0\n       0.0        0.0      258.053   71.6871   0.0        0.0\n       0.0       -7.07839   71.6871  48.59     0.0        0.0\n       7.07839    0.0        0.0      0.0      2.172      0.0\n     -71.6871     0.0        0.0      0.0      0.0       46.418],\n     nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop; stiffness=stiffness, mass=mass)\n\n# prescribed conditions\nprescribed_conditions = (t) -> begin\n    Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # force on right side\n        nelem+1 => PrescribedConditions(Fz = 1e5*sin(20*t))\n    )\nend\n\nnothing #hide","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"At this point if we wanted to use GXBeam's internal solver, we would choose a time discretization and call the time_domain_analysis function.","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"# simulation time\nt = 0:0.001:2.0\n\nsystem, gxbeam_history, converged = time_domain_analysis(assembly, t;\n    prescribed_conditions = prescribed_conditions)\n\nnothing #hide","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"To instead use the capabilities of the DifferentialEquations package we can do the following.","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"using DifferentialEquations\n\n# define simulation time\ntspan = (0.0, 2.0)\n\n# run initial condition analysis to get consistent set of initial conditions\nsystem, converged = initial_condition_analysis(assembly, tspan[1]; prescribed_conditions)\n\n# construct DAE as ODEProblem with non-constant mass matrix\nprob = ODEProblem(system, assembly, tspan; prescribed_conditions)\n\n# solve ODEProblem\nsol = solve(prob, Rodas4())\n\nnothing #hide","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"We can extract the outputs from the solution in a easy to understand format using the AssemblyState constructor.","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"\ndiffeq_history = [AssemblyState(system, assembly, sol[it]; prescribed_conditions)\n    for it in eachindex(sol)]\n\nnothing #hide","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"Let's now compare the solutions from GXBeam's internal solver and the Rodas4 solver from DifferentialEquations.","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"using Plots\npyplot()\n\npoint = vcat(fill(nelem+1, 6), fill(1, 6))\nfield = [:u, :u, :u, :theta, :theta, :theta, :F, :F, :F, :M, :M, :M]\ndirection = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\nylabel = [\"\\$u_x\\$ (\\$m\\$)\", \"\\$u_y\\$ (\\$m\\$)\", \"\\$u_z\\$ (\\$m\\$)\",\n    \"Rodriguez Parameter \\$\\\\theta_x\\$ (degree)\",\n    \"Rodriguez Parameter \\$\\\\theta_y\\$ (degree)\",\n    \"Rodriguez Parameter \\$\\\\theta_z\\$ (degree)\",\n    \"\\$F_x\\$ (\\$N\\$)\", \"\\$F_y\\$ (\\$N\\$)\", \"\\$F_z\\$ (\\$N\\$)\",\n    \"\\$M_x\\$ (\\$Nm\\$)\", \"\\$M_y\\$ (\\$Nm\\$)\", \"\\$M_z\\$ (\\$N\\$)\"]\n\nfor i = 1:12\n    local y #hide\n    plot(\n        xlim = (0, 2.0),\n        xticks = 0:0.5:2.0,\n        xlabel = \"Time (s)\",\n        ylabel = ylabel[i],\n        grid = false,\n        overwrite_figure=false\n        )\n    y_gxbeam = [getproperty(state.points[point[i]], field[i])[direction[i]]\n        for state in gxbeam_history]\n\n    y_diffeq = [getproperty(state.points[point[i]], field[i])[direction[i]]\n        for state in diffeq_history]\n\n    if field[i] == :theta\n        # convert to Rodriguez parameter\n        @. y_gxbeam = 4*atan(y_gxbeam/4)\n        @. y_diffeq = 4*atan(y_diffeq/4)\n        # convert to degrees\n        @. y_gxbeam = rad2deg(y_gxbeam)\n        @. y_diffeq = rad2deg(y_diffeq)\n    end\n\n    if field[i] == :F || field[i] == :M\n        y_gxbeam = -y_gxbeam\n        y_diffeq = -y_diffeq\n    end\n\n    plot!(t, y_gxbeam, label=\"GXBeam\")\n    plot!(sol.t, y_diffeq, label=\"DifferentialEquations\")\n    plot!(show=true)\n    savefig(\"dynamic-wind-turbine-diffeq-\"*string(field[i])*string(direction[i])*\".svg\"); nothing #hide\nend","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"As can be seen, the solutions provided by GXBeam and DifferentialEquations track closely with each other.","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"write_vtk(\"dynamic-wind-turbine\", assembly, gxbeam_history, sol.t)","category":"page"},{"location":"diffeq/","page":"Using GXBeam with DifferentialEquations.jl","title":"Using GXBeam with DifferentialEquations.jl","text":"(Image: )","category":"page"}]
}
