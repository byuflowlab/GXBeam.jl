<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · GXBeam.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GXBeam.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Getting Started</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Private-API"><span>Private API</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/GXBeam.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><ul><li><a href="#Library">Library</a></li><ul><li><a href="#Public-API">Public API</a></li><ul><li><a href="#Creating-an-Assembly">Creating an Assembly</a></li><li><a href="#Defining-Distributed-Loads">Defining Distributed Loads</a></li><li><a href="#Defining-Prescribed-Conditions">Defining Prescribed Conditions</a></li><li><a href="#Pre-Initializing-Memory-for-an-Analysis">Pre-Initializing Memory for an Analysis</a></li><li><a href="#Performing-an-Analysis">Performing an Analysis</a></li><li><a href="#Post-Processing">Post-Processing</a></li></ul><li><a href="#Private-API">Private API</a></li><ul><li><a href="#Math">Math</a></li><li><a href="#Points">Points</a></li><li><a href="#Elements">Elements</a></li><li><a href="#Loads">Loads</a></li><li><a href="#System">System</a></li></ul><li><a href="#Index">Index</a></li></ul></ul><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><h3 id="Creating-an-Assembly"><a class="docs-heading-anchor" href="#Creating-an-Assembly">Creating an Assembly</a><a id="Creating-an-Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-Assembly" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.curve_length" href="#GXBeam.curve_length"><code>GXBeam.curve_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">curve_length(start, stop, curvature)</code></pre><p>Calculate the length of a curve given its endpoints and its curvature vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/assembly.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.discretize_beam" href="#GXBeam.discretize_beam"><code>GXBeam.discretize_beam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">discretize_beam(L, start, discretization; frame = Matrix(I,3,3)), curvature = zeros(3))</code></pre><p>Discretize a beam according to the discretization provided in <code>discretization</code> given the beam length (<code>L</code>), and starting point (<code>start</code>).</p><p>Return the lengths, endpoints, midpoints, and rotation matrices of the beam elements.</p><p><strong>Arguments</strong></p><ul><li><code>L</code>: Beam length</li><li><code>start</code>: Beam starting point</li><li><code>discretization</code>: May be either an integer, representing the number of      elements that the beam should be discretized into, or a vector containing      the normalized endpoints of each beam element, where 0 is the beginning      of the beam and 1 is the end of the beam.</li><li><code>frame</code>: 3x3 beam rotation matrix which transforms from the local beam      coordinate frame at the start of the beam to the global coordinate frame.</li><li><code>curvature</code>: curvature vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/assembly.jl#L89-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.Assembly-Tuple{Any,Any,Any}" href="#GXBeam.Assembly-Tuple{Any,Any,Any}"><code>GXBeam.Assembly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Assembly(points, start, stop; kwargs...)</code></pre><p>Construct an assembly of connected nonlinear beam elements for analysis.  Beam lengths and midpoints may be manually specified in case beam elements are curved rather than straight.</p><p><strong>Arguments</strong></p><ul><li><code>points</code>: Array of all beam element endpoints</li><li><code>start</code>: Array containing point indices where each beam element starts</li><li><code>stop</code>: Array containing point indices where each beam element stops</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>stiffness</code>: Array of (6 x 6) stiffness matrices for each beam element, alternative to providing <code>compliance</code></li><li><code>compliance</code>: Array of (6 x 6) compliance matrices for each beam element, defaults to <code>zeros(6,6)</code> for each beam element</li><li><code>mass</code>: Array of (6 x 6) mass matrices for each beam element, alternative to providing <code>minv</code></li><li><code>minv</code>: Array of (6 x 6) mass matrices for each beam element, defaults to the identity matrix for each beam element</li><li><code>frames</code>: Array of (3 x 3) rotation matrices for each beam element (to transform      to the global frame), defaults to the identity matrix for each beam element</li><li><code>lengths</code>: Array containing the length of each beam, defaults to the distance between beam endpoints</li><li><code>midpoints</code>: Array containing the midpoint of each beam element, defaults to the average of the beam element endpoints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/assembly.jl#L21-L42">source</a></section></article><h3 id="Defining-Distributed-Loads"><a class="docs-heading-anchor" href="#Defining-Distributed-Loads">Defining Distributed Loads</a><a id="Defining-Distributed-Loads-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Distributed-Loads" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.DistributedLoads-Tuple{Any,Any}" href="#GXBeam.DistributedLoads-Tuple{Any,Any}"><code>GXBeam.DistributedLoads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DistributedLoads(assembly, ibeam[, dt]; kwargs...)</code></pre><p>Integrates the specified distributed loads over the element for each time step.</p><p><strong>Arguments</strong></p><ul><li><code>assembly</code>: The beam element assembly</li><li><code>ibeam</code>: The index of the beam element which the distributed load is assigned to</li><li><code>dt</code>: Time step size.  If omitted a single time step is assumed and specified   functions become a function of <code>s</code> only.</li><li><code>s1 = 0.0</code>: Start of beam element (used for integrating the distributed loads)</li><li><code>s2 = 1.0</code>: End of beam element (used for integrating the distributed loads)</li><li><code>nstep</code>: The total length of the time vector</li><li><code>method = (f, a, b) -&gt; gauss_quadrature(f, a, b)</code>: Method which integrates function  <code>f</code> from <code>a</code> to <code>b</code>. Defaults to the Gauss-Legendre quadrature with 4 points on each element.</li><li><code>fx = (s, t) -&gt; 0.0</code>: Distributed non-follower force on beam element in x-direction</li><li><code>fy = (s, t) -&gt; 0.0</code>: Distributed non-follower force on beam element in y-direction</li><li><code>fz = (s, t) -&gt; 0.0</code>: Distributed non-follower force on beam element in z-direction</li><li><code>mx = (s, t) -&gt; 0.0</code>: Distributed non-follower moment on beam element in x-direction</li><li><code>my = (s, t) -&gt; 0.0</code>: Distributed non-follower moment on beam element in y-direction</li><li><code>mz = (s, t) -&gt; 0.0</code>: Distributed non-follower moment on beam element in z-direction</li><li><code>fx_follower = (s, t) -&gt; 0.0</code>: Distributed follower force on beam element in x-direction</li><li><code>fy_follower = (s, t) -&gt; 0.0</code>: Distributed follower force on beam element in y-direction</li><li><code>fz_follower = (s, t) -&gt; 0.0</code>: Distributed follower force on beam element in z-direction</li><li><code>mx_follower = (s, t) -&gt; 0.0</code>: Distributed follower moment on beam element in x-direction</li><li><code>my_follower = (s, t) -&gt; 0.0</code>: Distributed follower moment on beam element in y-direction</li><li><code>mz_follower = (s, t) -&gt; 0.0</code>: Distributed follower moment on beam element in z-direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/loads.jl#L197-L224">source</a></section></article><h3 id="Defining-Prescribed-Conditions"><a class="docs-heading-anchor" href="#Defining-Prescribed-Conditions">Defining Prescribed Conditions</a><a id="Defining-Prescribed-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Prescribed-Conditions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PrescribedConditions-Tuple{}" href="#GXBeam.PrescribedConditions-Tuple{}"><code>GXBeam.PrescribedConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PrescribedConditions(dt=0.0; kwargs...)</code></pre><p>Construct an object of type PrescribedConditions which stores the prescribed conditions for a point at each time step.</p><p>Prescribed conditions may be assigned as either a scalar parameter or as a function of time.</p><p>Prescribed Wiener-Milenkovic parameters must satisfy the following inequality: sqrt(theta<em>x^2 + theta</em>y^2 + theta_z^2) &lt;= 4.  Note that this restriction still allows all possible rotations to be represented.</p><p><strong>Arguments</strong></p><ul><li><code>dt</code>: Time step size.</li><li><code>nstep</code>: The total length of the time vector</li><li><code>ux</code>: Prescribed x-direction displacement of the point</li><li><code>uy</code>: Prescribed y-direction displacement of the point</li><li><code>uz</code>: Prescribed z-direction displacement of the point</li><li><code>theta_x</code>: Prescribed first Wiener-Milenkovic parameter of the point</li><li><code>theta_y</code>: Prescribed second Wiener-Milenkovic parameter of the point</li><li><code>theta_z</code>: Prescribed third Wiener-Milenkovic parameter of the point</li><li><code>Fx</code>: Prescribed force in x-direction applied on the point</li><li><code>Fy</code>: Prescribed force in y-direction applied on the point</li><li><code>Fz</code>: Prescribed force in z-direction applied on the point</li><li><code>Mx</code>: Prescribed moment about x-axis applied on the point</li><li><code>My</code>: Prescribed moment about y-axis applied on the point</li><li><code>Mz</code>: Prescribed moment about z-axis applied on the point</li><li><code>Fx_follower</code>: Prescribed follower force in x-direction applied on the point</li><li><code>Fy_follower</code>: Prescribed follower force in y-direction applied on the point</li><li><code>Fz_follower</code>: Prescribed follower force in z-direction applied on the point</li><li><code>Mx_follower</code>: Prescribed follower moment about x-axis applied on the point</li><li><code>My_follower</code>: Prescribed follower moment about y-axis applied on the point</li><li><code>Mz_follower</code>: Prescribed follower moment about z-axis applied on the point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/loads.jl#L14-L48">source</a></section></article><h3 id="Pre-Initializing-Memory-for-an-Analysis"><a class="docs-heading-anchor" href="#Pre-Initializing-Memory-for-an-Analysis">Pre-Initializing Memory for an Analysis</a><a id="Pre-Initializing-Memory-for-an-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-Initializing-Memory-for-an-Analysis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.System-Tuple{Any,Any,Any}" href="#GXBeam.System-Tuple{Any,Any,Any}"><code>GXBeam.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System([TF=eltype(assembly),] assembly, points, static)</code></pre><p>Initialize an object of type <code>System</code> which stores the system state, residual vector, current time function values,and jacobian matrices as well as pointers to be able to access their contents.</p><p><strong>Arguments:</strong></p><ul><li><code>TF:</code> (optional) Used to specify floating point type used by resulting <code>System</code> object</li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li><li><code>points</code>: Point indices which should be preserved in the system of equations.      All points with prescribed conditions should be included.</li><li><code>static</code>: Flag indicating whether system matrices will be used for static simulations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/system.jl#L46-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.reset_state!" href="#GXBeam.reset_state!"><code>GXBeam.reset_state!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>reset_state!(system)</p><p>Reset the state variables in <code>system</code> (stored in <code>system.x</code>) to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/system.jl#L94-L98">source</a></section></article><h3 id="Performing-an-Analysis"><a class="docs-heading-anchor" href="#Performing-an-Analysis">Performing an Analysis</a><a id="Performing-an-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-an-Analysis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_analysis" href="#GXBeam.static_analysis"><code>GXBeam.static_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">static_analysis(assembly; kwargs...)</code></pre><p>Perform a static analysis of the system of nonlinear beams contained in <code>assembly</code>. Return the resulting system and a flag indicating whether the iteration procedure converged.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>: Dictionary   holding PrescribedConditions composite types for the points in <code>keys(prescribed_conditions)</code></li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: Dictionary holding   DistributedLoads composite types for the beam elements in <code>keys(distributed_loads)</code></li><li><code>linear = false</code>: Set to <code>true</code> for a linear analysis</li><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>nstep = 1</code>: Number of time steps. May be used in conjunction with time varying   prescribed conditions and distributed loads to gradually increase  displacements/loads.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/analyses.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.static_analysis!" href="#GXBeam.static_analysis!"><code>GXBeam.static_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">static_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <code>static_analysis</code>.  Uses the state variables stored in <code>system</code> as an initial guess for iterating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/analyses.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_analysis" href="#GXBeam.steady_state_analysis"><code>GXBeam.steady_state_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">steady_state_analysis(assembly; kwargs...)</code></pre><p>Perform a steady-state analysis for the system of nonlinear beams contained in <code>assembly</code>.  Return the resulting system and a flag indicating whether the iteration procedure converged.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>: Dictionary   holding PrescribedConditions composite types for the points in <code>keys(prescribed_conditions)</code></li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: Dictionary holding   DistributedLoads composite types for the beam elements in <code>keys(distributed_loads)</code></li><li><code>linear = false</code>: Set to <code>true</code> for a linear analysis</li><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>nstep = 1</code>: Number of time steps. May be used in conjunction with time varying   prescribed conditions, distributed loads, and global motion to gradually   increase displacements/loads.</li><li><code>origin = zeros(3)</code>: Global frame origin</li><li><code>linear_velocity = fill(zeros(3), nstep)</code>: Global frame linear velocity for each time step.</li><li><code>angular_velocity = fill(zeros(3), nstep)</code>: Global frame angular velocity for each time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/analyses.jl#L122-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.steady_state_analysis!" href="#GXBeam.steady_state_analysis!"><code>GXBeam.steady_state_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">steady_state_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <code>steady_state_analysis</code>.  Uses the state variables stored in <code>system</code> as an initial guess for iterating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/analyses.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.eigenvalue_analysis" href="#GXBeam.eigenvalue_analysis"><code>GXBeam.eigenvalue_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eigenvalue_analysis(assembly; kwargs...)</code></pre><p>Compute the eigenvalues and eigenvectors of the system of nonlinear beams contained in <code>assembly</code>.  Return the modified system, eigenvalues, eigenvectors, and a convergence flag indicating whether the corresponding steady-state analysis converged.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>: Dictionary   holding PrescribedConditions composite types for the points in <code>keys(prescribed_conditions)</code></li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: Dictionary holding   DistributedLoads composite types for the beam elements in <code>keys(distributed_loads)</code></li><li><code>linear = false</code>: Set to <code>true</code> for a linear analysis</li><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>nstep = 1</code>: Number of time steps. May be used in conjunction with time varying   prescribed conditions, distributed loads, and global motion to gradually   increase displacements/loads.</li><li><code>origin = zeros(3)</code>: Global frame origin</li><li><code>linear_velocity = fill(zeros(3), nstep)</code>: Global frame linear velocity for each time step.</li><li><code>angular_velocity = fill(zeros(3), nstep)</code>: Global frame angular velocity for each time step</li><li><code>nev = 6</code>: Number of eigenvalues to compute</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/analyses.jl#L270-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.eigenvalue_analysis!" href="#GXBeam.eigenvalue_analysis!"><code>GXBeam.eigenvalue_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eigenvalue_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <code>eigenvalue_analysis</code>.  Uses the state variables stored in <code>system</code> as an initial guess for iterating to find the steady state solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/analyses.jl#L331-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.time_domain_analysis" href="#GXBeam.time_domain_analysis"><code>GXBeam.time_domain_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_domain_analysis(assembly, dt; kwargs...)</code></pre><p>Perform a time-domain analysis for the system of nonlinear beams contained in <code>assembly</code>.  Return the final system, a post-processed solution history, and a convergence flag indicating whether the iterations converged for each time step.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>: Dictionary   holding PrescribedConditions composite types for the points in <code>keys(prescribed_conditions)</code></li><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: Dictionary holding   DistributedLoads composite types for the beam elements in <code>keys(distributed_loads)</code></li><li><code>linear = false</code>: Set to <code>true</code> for a linear analysis</li><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.LineSearches.BackTracking(maxstep=1e6)</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol = 1e-9</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>nstep = 1</code>: The total length of the time vector</li><li><code>origin = zeros(3)</code>: Global frame origin</li><li><code>linear_velocity = fill(zeros(3), nstep)</code>: Global frame linear velocity for each time step.</li><li><code>angular_velocity = fill(zeros(3), nstep)</code>: Global frame angular velocity for each time step.</li><li><code>u0=fill(zeros(3), length(assembly.elements))</code>: initial displacment of each beam element,</li><li><code>theta0=fill(zeros(3), length(assembly.elements))</code>: initial angular displacement of each beam element,</li><li><code>udot0=fill(zeros(3), length(assembly.elements))</code>: initial time derivative with respect to <code>u</code></li><li><code>thetadot0=fill(zeros(3), length(assembly.elements))</code>: initial time derivative with respect to <code>theta</code></li><li><code>save=1:nstep</code>: Steps at which to save the time history</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/analyses.jl#L432-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.time_domain_analysis!" href="#GXBeam.time_domain_analysis!"><code>GXBeam.time_domain_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_domain_analysis!(system, assembly, dt; kwargs...)</code></pre><p>Pre-allocated version of <code>time_domain_analysis</code>.  Uses the state variables stored in <code>system</code> as an initial guess for iterating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/analyses.jl#L502-L507">source</a></section></article><h3 id="Post-Processing"><a class="docs-heading-anchor" href="#Post-Processing">Post-Processing</a><a id="Post-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Processing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.AssemblyState-Tuple{Any,Any}" href="#GXBeam.AssemblyState-Tuple{Any,Any}"><code>GXBeam.AssemblyState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AssemblyState(system, assembly, x = system.x;
    prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())</code></pre><p>Post-process the system state given the solution vector <code>x</code>.  Return an object of type <code>AssemblyState</code> that defines the state of the assembly for the time step.</p><p>If <code>prescribed_conditions</code> is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/postprocess.jl#L56-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.AssemblyState" href="#GXBeam.AssemblyState"><code>GXBeam.AssemblyState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AssemblyState{TF, TP&lt;:AbstractVector{PointState{TF}}, TE&lt;:AbstractVector{ElementState{TF}}}</code></pre><p>Struct for storing state variables for the points and elements in an assembly.</p><p><strong>Fields:</strong></p><ul><li><code>points::TP</code>: Array of <code>PointState</code>s for each point in the assembly</li><li><code>elements::TE</code>: Array of <code>ElementState</code>s for each element in the assembly</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/postprocess.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.left_eigenvectors" href="#GXBeam.left_eigenvectors"><code>GXBeam.left_eigenvectors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">left_eigenvectors(system, λ, V)
left_eigenvectors(K, M, λ, V)</code></pre><p>Compute the left eigenvector matrix <code>U</code> for the <code>system</code> using inverse power iteration given the eigenvalues <code>λ</code> and the corresponding right eigenvector matrix <code>V</code>.</p><p>The complex conjugate of each left eigenvector is stored in each row of the matrix <code>U</code></p><p>Left and right eigenvectors satisfy the following M-orthogonality condition:</p><ul><li>u&#39;<em>M</em>v = 1 if u and v correspond to the same eigenvalue</li><li>u&#39;<em>M</em>v = 0 if u and v correspond to different eigenvalues</li></ul><p>This means that U<em>M</em>V = I</p><p>This function assumes that <code>system</code> has not been modified since the eigenvalues and right eigenvectors were computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/postprocess.jl#L456-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.correlate_eigenmodes" href="#GXBeam.correlate_eigenmodes"><code>GXBeam.correlate_eigenmodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">correlate_eigenmodes(C)</code></pre><p>Return the permutation and the associated corruption index vector which associates eigenmodes from the current iteration with those of the previous iteration given the correlation matrix <code>C</code>.</p><p>The correlation matrix can take one of the following forms (in order of preference):</p><ul><li><code>C = U_p*M*V</code></li><li><code>C = U*M_p*V_p</code></li><li><code>C = V_p&#39;*V</code></li><li><code>C = V&#39;*V_p</code></li></ul><p>where <code>U</code> is a matrix of conjugated left eigenvectors, <code>M</code> is the system mass matrix, <code>V</code> is a matrix of right eigenvectors, and <code>()_p</code> indicates a variable from the previous iteration.</p><p>Note that the following two forms of the correlation matrix seem to be significantly inferior to their counterparts listed above: <code>C = U*M*V_p</code> and <code>C = U_p*M_p*V</code>. This is likely due to the way in which the left eigenvector matrix is calculated.</p><p>The corruption index is the largest magnitude in a given row of <code>C</code> that was not chosen divided by the magnitude of the chosen eigenmode.  It is most meaningful when using one of the forms of the correlation matrix that uses left eigenvectors since correct eigenmodes will have magnitudes close to 1 and incorrect eigenmodes will have magnitudes close to 0.</p><p>If the new mode number is already assigned, the next highest unassigned mode number is used.  In this case a corruption index higher than 1 will be returned, otherwise the values of the corruption index will always be bounded by 0 and 1.</p><p>See &quot;New Mode Tracking Methods in Aeroelastic Analysis&quot; by Eldred, Vankayya, and Anderson.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/postprocess.jl#L525-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.wiener_milenkovic" href="#GXBeam.wiener_milenkovic"><code>GXBeam.wiener_milenkovic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wiener_milenkovic(c)</code></pre><p>Construct a Wiener-Milenkovic rotation matrix, given the three Wiener-Milenkovic parameters in <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.write_vtk" href="#GXBeam.write_vtk"><code>GXBeam.write_vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_vtk(name, assembly::Assembly; kwargs...)
write_vtk(name, assembly::Assembly, state::AssemblyState; kwargs...)
write_vtk(name, assembly::Assembly, history::Vector{&lt;:AssemblyState}], dt; kwargs...)</code></pre><p>Write the deformed geometry (and associated data) to a VTK file for visualization using ParaView.</p><p>The <code>state</code> parameter may be omitted to write the original geometry to a VTK file without any associated data.</p><p>If the solution time <code>history</code> is provided, the time step must also be provided</p><p><strong>Keyword Arguments</strong></p><ul><li><code>scaling=1.0</code>: Parameter to scale the deflections (only valid if state is provided)</li><li><code>metadata=Dict()</code>: Dictionary of metadata for the file(s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/postprocess.jl#L160-L176">source</a></section><section><div><pre><code class="language-none">write_vtk(name, assembly::Assembly, [state::AssemblyState, ]λ::Number, eigenstate::AssemblyState;
scaling=1.0, mode_scaling=1.0, cycles=1, steps=100)</code></pre><p>Write a series of files corresponding to the elastic motion of the <code>assembly</code> about the deformed state encoded in <code>state</code> defined by the eigenvalue <code>λ</code> and the eigenvector encoded in <code>eigenstate</code> over the time period specified by <code>time</code>.</p><p>The steady-state deflections can be scaled with <code>scaling</code> and the eigenmode deflections can be scaled using <code>mode_scaling</code>.</p><p>The current time is encoded in the metadata tag &quot;time&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/postprocess.jl#L355-L367">source</a></section></article><h2 id="Private-API"><a class="docs-heading-anchor" href="#Private-API">Private API</a><a id="Private-API-1"></a><a class="docs-heading-anchor-permalink" href="#Private-API" title="Permalink"></a></h2><h3 id="Math"><a class="docs-heading-anchor" href="#Math">Math</a><a id="Math-1"></a><a class="docs-heading-anchor-permalink" href="#Math" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.tilde" href="#GXBeam.tilde"><code>GXBeam.tilde</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tilde(x)</code></pre><p>Construct the cross product operator matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.rotation_parameter_scaling" href="#GXBeam.rotation_parameter_scaling"><code>GXBeam.rotation_parameter_scaling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotation_parameter_scaling(θ)</code></pre><p>Extract a scaling parameter which may be multiplied by the angular parameters to yield the Wiener-Milenkovic rotation parameters.  Use of this scaling parameter allows deflections greater than 360 degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_C" href="#GXBeam.get_C"><code>GXBeam.get_C</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_C(θ)</code></pre><p>Returns the rotation matrix <code>C</code> given the three angular parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_C_t" href="#GXBeam.get_C_t"><code>GXBeam.get_C_t</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_C_t([C, ] θ, θ_t)</code></pre><p>Calculate the derivative of the Wiener-Milenkovic rotation matrix <code>C</code> with respect to the scalar parameter <code>t</code>. <code>θ_t</code> is the derivative of the angular parameter <code>θ</code> with respect to <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L76-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_C_θ" href="#GXBeam.get_C_θ"><code>GXBeam.get_C_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_C_θ([C, ] θ)</code></pre><p>Calculate the derivative of the Wiener-Milenkovic rotation matrix <code>C</code> with respect to each of the rotation parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_C_θdot" href="#GXBeam.get_C_θdot"><code>GXBeam.get_C_θdot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_C_θdot([C, ] θ)</code></pre><p>Calculate the derivative of the time derivative of the Wiener-Milenkovic rotation matrix <code>C</code> with respect to each of the time derivatives of <code>θ</code>. Used for constructing the &quot;mass&quot; matrix for eigenvalue computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L156-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Q" href="#GXBeam.get_Q"><code>GXBeam.get_Q</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_Q(θ)</code></pre><p>Calculate the matrix Q as defined in the paper &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu given the rotational parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L199-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Q_θ" href="#GXBeam.get_Q_θ"><code>GXBeam.get_Q_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_Q_θ(θ)
get_Q_θ(Q, θ)</code></pre><p>Calculate the derivative of the matrix <code>Q</code> with respect to each of the rotation parameters in <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L217-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Qinv" href="#GXBeam.get_Qinv"><code>GXBeam.get_Qinv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_Qinv(θ)</code></pre><p>Calculate the matrix inverse <code>Qinv</code> as defined in the paper &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu given the rotational parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L247-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.get_Qinv_θ" href="#GXBeam.get_Qinv_θ"><code>GXBeam.get_Qinv_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_Qinv_θ(θ)</code></pre><p>Calculate the derivative of the matrix inverse <code>Qinv</code> with respect to each of the rotation parameters in <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L265-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.mul3" href="#GXBeam.mul3"><code>GXBeam.mul3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mul3(A_1, A_2, A_3, b)</code></pre><p>Return the product of a 3x3x3 tensor represented by <code>A_1</code>, <code>A_2</code>, and <code>A_3</code> with the vector <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L284-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.gauss_quadrature" href="#GXBeam.gauss_quadrature"><code>GXBeam.gauss_quadrature</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gauss_quadrature(f, a, b)</code></pre><p>Default gauss-quadrature function used for integrating distributed loads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/math.jl#L292-L296">source</a></section></article><h3 id="Points"><a class="docs-heading-anchor" href="#Points">Points</a><a id="Points-1"></a><a class="docs-heading-anchor-permalink" href="#Points" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_variables" href="#GXBeam.point_variables"><code>GXBeam.point_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">point_variables(x, icol)
point_variables(x, icol, prescribed_conditions, istep)</code></pre><p>Extract u, θ, F, M for the point described by the point state variables at <code>icol</code> in x after incorporating the prescribed conditions in <code>prescribed_conditions</code></p><p>Note that the degrees of freedom that are not specified in <code>prescribed_conditions</code> are used as state variables (e.g. prescribing F[2] would mean u[2] = x[icol+1])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/point.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_point_residual!" href="#GXBeam.insert_point_residual!"><code>GXBeam.insert_point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_point_residual!(resid, irow_b, irow_p, u, θ, F, M, side)</code></pre><p>Modify the equilibrium and constitutive equations to account for the point variables given by u, θ, F, M</p><p>If irow<em>b != irow</em>p, assume that the equilibrium equations have already been modified</p><p><strong>Arguments</strong></p><ul><li>resid: Residual vector</li><li>irow_b: Row index of the first equilibrium/compatability equation for one side of the beam element</li><li>irow_p: Row index of the first equilibrium equation for the point</li><li>u: Displacement of the point</li><li>θ: Rotation of the point</li><li>F: External forces imposed on the point</li><li>M: External moments imposed on the point</li><li>side: Side of beam (-1 (left) or 1 (right))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/point.jl#L72-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_residual!" href="#GXBeam.point_residual!"><code>GXBeam.point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">point_residual!(resid, x, ipoint, assembly, prescribed_conditions, icol,
    irow_p, irow_beam1, irow_beam2)</code></pre><p>Adds a points contributions to the residual vector</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: residual vector</li><li><code>x</code>: current state vector</li><li><code>ipoint</code>: index of point</li><li><code>assembly</code>: assembly of interconnected beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>icol</code>: starting index for the point&#39;s state variables</li><li><code>irow_p</code>: Row index of the first equilibrium equation for the point</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/point.jl#L111-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_follower_jacobians" href="#GXBeam.point_follower_jacobians"><code>GXBeam.point_follower_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">point_follower_jacobians(x, icol, prescribed_conditions)</code></pre><p>Calculate the jacobians of the follower forces/moments with respect to θ</p><p><strong>Arguments</strong></p><ul><li>x: Current state variable vector</li><li>icol: Row/Column index of the first state variable for the point</li><li>prescribed_conditions: Prescribed conditions for the point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/point.jl#L162-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_point_jacobian!" href="#GXBeam.insert_point_jacobian!"><code>GXBeam.insert_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_point_jacobian!(jacob, irow_b, irow_p, icol, prescribed_conditions, side, F_θ, M_θ)</code></pre><p>Modify the jacobian entries for the equilibrium and constitutive equations to account for the point variables at icol</p><p>If irow<em>b != irow</em>p, assume that the equilibrium equations have already been modified</p><p><strong>Arguments</strong></p><ul><li>jacob: Jacobian of residual vector with respect to state vectors</li><li>irow_b: Row index of the first equilibrium/compatability equation for one side of the beam element</li><li>irow_p: Row index of the first equilibrium equation for the point</li><li>icol: Row/Column index of the first state variable for the point</li><li>prescribed_conditions: Prescribed force/displacement and moment/rotation on point</li><li>side: Side of beam (-1 (left) or 1 (right))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/point.jl#L229-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_jacobian!" href="#GXBeam.point_jacobian!"><code>GXBeam.point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">point_jacobian!(jacob, x, ipoint, assembly, prescribed_conditions, icol,
    irow_p, irow_beam1, irow_beam2)</code></pre><p>Adds a points contributions to the residual vector</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: residual vector</li><li><code>x</code>: current state vector</li><li><code>ipoint</code>: index of point</li><li><code>assembly</code>: assembly of interconnected beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>istep</code>: current time step</li><li><code>icol</code>: starting index for the point&#39;s state variables</li><li><code>irow_p</code>: Row index of the first equilibrium equation for the point</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/point.jl#L307-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PointState" href="#GXBeam.PointState"><code>GXBeam.PointState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointState</code></pre><p>Holds the state variables for a point</p><p><strong>Fields:</strong></p><ul><li><code>u</code>: Displacement variables for the point (in the global coordinate frame)</li><li><code>theta</code>: Wiener-Milenkovic rotational displacement variables for the point</li><li><code>F</code>: Externally applied forces on the point (in the global coordinate frame)</li><li><code>M</code>: Externally applied moments on the point (in the global coordinate frame)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/postprocess.jl#L1-L11">source</a></section></article><h3 id="Elements"><a class="docs-heading-anchor" href="#Elements">Elements</a><a id="Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Elements" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.Element" href="#GXBeam.Element"><code>GXBeam.Element</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Element{TF}</code></pre><p>Composite type that defines a beam element&#39;s properties</p><p><strong>Fields</strong></p><ul><li><code>L</code>: Length of the beam element</li><li><code>x</code>: Location of the beam element (the midpoint of the beam element)</li><li><code>C11</code>: Upper left portion of the beam element&#39;s compliance matrix</li><li><code>C12</code>: Upper right portion of the beam element&#39;s compliance matrix</li><li><code>C22</code>: Lower right portion of the beam element&#39;s compliance matrix</li><li><code>minv11</code>: Upper left portion of the inverse of the beam element&#39;s mass matrix</li><li><code>minv12</code>: Upper right portion of the inverse of the beam element&#39;s mass matrix</li><li><code>minv22</code>: Lower right portion of the inverse of the beam element&#39;s mass matrix</li><li><code>Cab</code>: Rotation matrix from the global frame to beam element&#39;s frame</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_strain" href="#GXBeam.element_strain"><code>GXBeam.element_strain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_strain(element, F, M)</code></pre><p>Calculate the strain of a beam element given the resultant force and moments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_curvature" href="#GXBeam.element_curvature"><code>GXBeam.element_curvature</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_curvature(element, F, M)</code></pre><p>Calculate the curvature of a beam element given the resultant force and moments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_linear_velocity" href="#GXBeam.element_linear_velocity"><code>GXBeam.element_linear_velocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_linear_velocity(element, P, H)</code></pre><p>Calculate the linear velocity of a beam element given the linear and angular momenta</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_angular_velocity" href="#GXBeam.element_angular_velocity"><code>GXBeam.element_angular_velocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_angular_velocity(element, P, H)</code></pre><p>Calculate the angular velocity of a beam element given the linear and angular momenta</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_properties" href="#GXBeam.element_properties"><code>GXBeam.element_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_properties(x, icol, beam)
element_properties(x, icol, beam, x0, v0, ω0)
element_properties(x, icol, ibeam, beam, x0, v0, ω0, u, θ, udot, θdot)
element_properties(x, icol, ibeam, beam, x0, v0, ω0, udot, θdot_init, CtCabPdot, CtCabHdot, dt)</code></pre><p>Extract/calculate the properties of a specific beam element.</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: current state vector</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>ibeam</code>: beam element index</li><li><code>beam</code>: beam element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>x0</code>: Global frame origin (for the current time step)</li><li><code>v0</code>: Global frame linear velocity (for the current time step)</li><li><code>ω0</code>: Global frame angular velocity (for the current time step)</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>u</code>: deflection variables for each beam element</li><li><code>θ</code>: rotation variables for each beam element</li><li><code>udot</code>: time derivative of u for each beam element</li><li><code>θdot</code>: time derivative of θ for each beam element</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot_init</code>: <code>2/dt*u + udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot_init</code>: <code>2/dt*C&#39;*Cab*P + C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot_init</code>: <code>2/dt*C&#39;*Cab*H + C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L82-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.dynamic_element_properties" href="#GXBeam.dynamic_element_properties"><code>GXBeam.dynamic_element_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dynamic_element_properties(x, icol, beam, x0, v0, ω0)</code></pre><p>Extract/Compute <code>v</code>, <code>ω</code>, <code>P</code>, <code>H</code>, <code>V</code>, and <code>Ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L197-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_equations" href="#GXBeam.element_equations"><code>GXBeam.element_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ)
element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, v, ω, P, H, V, Ω)
element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, v, ω, P, H, V, Ω,
    udot, θdot, CtCabPdot, CtCabHdot)</code></pre><p>Evaluate the nonlinear equations for a beam element.</p><p>There are three implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step or Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: Length of the beam element</li><li><code>Ct</code>: Rotation tensor of the beam deformation in the &quot;a&quot; frame, transposed</li><li><code>Cab</code>: Direction cosine matrix from &quot;a&quot; to &quot;b&quot; frame for the element</li><li><code>CtCab</code>: <code>C&#39;*Cab</code>, precomputed for efficiency</li><li><code>u</code>: Displacement variables for the element [u1, u2, u3]</li><li><code>θ</code>: Rotation variables for the element [θ1, θ2, θ3]</li><li><code>F</code>: Force variables for the element [F1, F2, F3]</li><li><code>M</code>: Moment variables for the element [M1, M2, M3]</li><li><code>γ</code>: Engineering strains in the element [γ11, 2γ12, 2γ13]</li><li><code>κ</code>: Curvatures in the element [κ1, κ2, κ3]</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>v</code>: Linear velocity of element in global frame &quot;a&quot; [v1, v2, v3]</li><li><code>ω</code>: Angular velocity of element in global frame &quot;a&quot; [ω1, ω2, ω3]</li><li><code>P</code>: Linear momenta for the element [P1, P2, P3]</li><li><code>H</code>: Angular momenta for the element [H1, H2, H3]</li><li><code>V</code>: Velocity of the element</li><li><code>Ω</code>: Rotational velocity of the element</li></ul><p><strong>Additional Arguments for Initial Step Analysis</strong></p><ul><li><code>udot</code>: user-specified time derivative of u</li><li><code>θdot</code>: user-specified time derivative of θ</li><li><code>CtCabPdot</code>: C&#39;<em>Cab</em>Pdot state variable</li><li><code>CtCabHdot</code>: C&#39;<em>Cab</em>Hdot state variable</li></ul><p><strong>Additional Arguments for Time Marching Analysis</strong></p><ul><li><code>udot</code>: <code>2/dt*(u-u_p) - udot_p</code> for this beam element where <code>_p</code> denotes values   taken from the previous time step</li><li><code>θdot</code>: <code>2/dt*(θ-θ_p) - θdot_p</code> for this beam element where <code>_p</code> denotes values   taken from the previous time step</li><li><code>CtCabPdot</code>: <code>2/dt*(C&#39;*Cab*P - (C&#39;*Cab*P)_p) - (C&#39;*Cab*Pdot)_p</code> for this beam   element where <code>_p</code> denotes values taken from the previous time step</li><li><code>CtCabHdot</code>: <code>2/dt*(C&#39;*Cab*H - (C&#39;*Cab*H)_p) - (C&#39;*Cab*Hdot)_p</code> for this beam   element where <code>_p</code> denotes values taken from the previous time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L216-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_element_residual!" href="#GXBeam.insert_element_residual!"><code>GXBeam.insert_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_element_residual!(resid, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, f_u1, f_u2, f_ψ1,
    f_ψ2, f_F1, f_F2, f_M1, f_M2)
insert_element_residual!(resid, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, f_u1, f_u2, f_ψ1,
    f_ψ2, f_F1, f_F2, f_M1, f_M2, f_P, f_H)</code></pre><p>Insert beam element resultants into the residual equation.  Initialize equilibrium and constitutive equations if they are not yet initialized.</p><p>If <code>irow_b1 != irow_p1</code> and/or <code>irow_b2 != irow_p2</code>, assume the equilibrium equations for the left and/or right side are already initialized</p><p>There are two implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State, Initial Step, or Time Marching</li></ul><p><strong>Arguments</strong></p><ul><li><code>resid</code>: System residual vector</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam element</li><li><code>irow_b1</code>: Row index of the first equation for the right side of the beam element   (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam element</li><li><code>f_u1</code>, <code>f_u2</code>: Resultant displacements for the left and right side of the beam element, respectively</li><li><code>f_ψ1</code>, <code>f_ψ2</code>: Resultant rotations for the left and right side of the beam element, respectively</li><li><code>f_F1</code>, <code>f_F2</code>: Resultant forces for the left and right side of the beam element, respectively</li><li><code>f_M1</code>, <code>f_M2</code>: Resultant moments for the left and right side of the beam element, respectively</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>f_P</code>: Resultant linear momenta of the beam element</li><li><code>f_H</code>: Resultant angular momenta of the beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L339-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_residual!" href="#GXBeam.element_residual!"><code>GXBeam.element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,
    irow_b1, irow_p1, irow_b2, irow_p2)
element_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,
    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0)
element_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,
    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, u0, θ0, udot0, θdot0)
element_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,
    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, udot_init, θdot_init,
    CtCabPdot_init, CtCabHdot_init, dt)</code></pre><p>Compute and add a beam element&#39;s contributions to the residual vector</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: System residual vector</li><li><code>x</code>: current state vector</li><li><code>ibeam</code>: beam element index</li><li><code>beam</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>istep</code>: current time step</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam element</li><li><code>irow_b2</code>: Row index of the first equation for the right side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>x0</code>: Global frame origin (for the current time step)</li><li><code>v0</code>: Global frame linear velocity (for the current time step)</li><li><code>ω0</code>: Global frame angular velocity (for the current time step)</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>u0</code>: initial deflection variables for each beam element</li><li><code>θ0</code>: initial rotation variables for each beam element</li><li><code>udot0</code>: initial time derivative of u for each beam element</li><li><code>θdot0</code>: initial time derivative of θ for each beam element</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot_init</code>: <code>2/dt*u + udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot_init</code>: <code>2/dt*C&#39;*Cab*P + C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot_init</code>: <code>2/dt*C&#39;*Cab*H + C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L457-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_jacobian_equations" href="#GXBeam.element_jacobian_equations"><code>GXBeam.element_jacobian_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_jacobian_equations(beam, ΔL, Ct, Cab, CtCab, θ, F, M, γ, κ, Ct_θ1,
    Ct_θ2, Ct_θ3)
element_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, M, γ, κ, ω, P, H, V,
    Ct_θ1, Ct_θ2, Ct_θ3)
element_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, γ, ω, P, V, θdot)
element_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, M, γ, κ, ω, P, H, V,
    θdot, dt, Ct_θ1, Ct_θ2, Ct_θ3)</code></pre><p>Find the jacobians of the nonlinear equations for a beam element with respect to the state variables given the distributed loads on the beam element and the beam element&#39;s properties.</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments:</strong></p><ul><li><code>beam</code>: Beam element</li><li><code>ΔL</code>: Length of the beam element</li><li><code>Ct</code>: Rotation tensor of the beam deformation in the &quot;a&quot; frame, transposed</li><li><code>Cab</code>: Direction cosine matrix from &quot;a&quot; to &quot;b&quot; frame for the element</li><li><code>CtCab</code>: <code>C&#39;*Cab</code>, precomputed for efficiency</li><li><code>u</code>: Displacement variables for the element [u1, u2, u3]</li><li><code>θ</code>: Rotation variables for the element [θ1, θ2, θ3]</li><li><code>F</code>: Force variables for the element [F1, F2, F3]</li><li><code>M</code>: Moment variables for the element [M1, M2, M3]</li><li><code>γ</code>: Engineering strains in the element [γ11, 2γ12, 2γ13]</li><li><code>κ</code>: Curvatures in the element [κ1, κ2, κ3]</li><li><code>Ct_θ1</code>: Gradient of <code>Ct</code> w.r.t. <code>θ[1]</code></li><li><code>Ct_θ2</code>: Gradient of <code>Ct</code> w.r.t. <code>θ[2]</code></li><li><code>Ct_θ3</code>: Gradient of <code>Ct</code> w.r.t. <code>θ[3]</code></li><li><code>f1_θ</code>: Gradient w.r.t. θ of integrated distributed force for left side of element</li><li><code>m1_θ</code>: Gradient w.r.t. θ of integrated distributed moment for left side of element</li><li><code>f2_θ</code>: Gradient w.r.t. θ of integrated distributed force for right side of element</li><li><code>m2_θ</code>: Gradient w.r.t. θ of integrated distributed moment for right side of element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>v</code>: Linear velocity of element in global frame &quot;a&quot; [v1, v2, v3]</li><li><code>ω</code>: Angular velocity of element in global frame &quot;a&quot; [ω1, ω2, ω3]</li><li><code>P</code>: Linear momenta for the element [P1, P2, P3]</li><li><code>H</code>: Angular momenta for the element [H1, H2, H3]</li><li><code>V</code>: Velocity of the element</li><li><code>Ω</code>: Rotational velocity of the element</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>udot</code>: user-specified time derivative of u for this beam element</li><li><code>θdot</code>: user-specified time derivative of θ for this beam element</li><li><code>CtCabPdot</code>: <code>C&#39;*Cab*Pdot</code> (which is a state variable for the initial step analysis)</li><li><code>CtCabHdot</code>: <code>C&#39;*Cab*Hdot</code> (which is a state variable for the initial step analysis)</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot</code>: <code>-2/dt*u - udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>-2/dt*θ - θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot</code>: <code>-2/dt*C&#39;*Cab*P - C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot</code>: <code>-2/dt*C&#39;*Cab*H - C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L626-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_element_jacobian!" href="#GXBeam.insert_element_jacobian!"><code>GXBeam.insert_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,
    f_u1_θ, f_u2_θ, f_u1_F, f_u2_F,
    f_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M,
    f_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,
    f_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M)
insert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,
    f_u1_θ, f_u2_θ, f_u1_F, f_u2_F, f_u1_P, f_u2_P,
    f_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, f_ψ1_P, f_ψ2_P, f_ψ1_H, f_ψ2_H,
    f_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,
    f_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M,
    f_P_u, f_P_θ, f_P_P, f_P_H,
    f_H_θ, f_H_P, f_H_H)
insert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,
    f_u1_CtCabPdot, f_u2_CtCabPdot, f_u1_F, f_u2_F, f_u1_P, f_u2_P,
    f_ψ1_CtCabHdot, f_ψ2_CtCabHdot, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, f_ψ1_P, f_ψ2_P, f_ψ1_H, f_ψ2_H,
    f_F1_F, f_F2_F, f_F1_M, f_F2_M,
    f_M1_F, f_M2_F, f_M1_M, f_M2_M,
    f_P_P, f_P_H,
    f_H_P, f_H_H)</code></pre><p>Insert the the beam element jacobian entries into the jacobian matrix</p><p>There are three implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State or Time Marching</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li></ul><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>icol_p1</code>: Row/column index of the first unknown for the left endpoint (a value &lt;= 0 indicates the unknowns have been eliminated from the system of equations)</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam</li><li><code>icol_p2</code>: Row/column index of the first unknown for the right endpoint   (a value &lt;= 0 indicates the unknowns have been eliminated from the system of equations)</li><li><code>irow_b2</code>: Row index of the first equation for the right side of the beam</li><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam</li><li><code>icol</code>: Row/Column index corresponding to the first beam state variable</li></ul><p>All other arguments use the following naming convention:</p><ul><li><code>f_y_x</code>: Jacobian of element equation &quot;y&quot; with respect to state variable &quot;x&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L995-L1038">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_jacobian!" href="#GXBeam.element_jacobian!"><code>GXBeam.element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,
    irow_b1, irow_p1, irow_b2, irow_p2)
element_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,
    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0)
element_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,
    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, u0, θ0, udot0, θdot0)
element_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,
    irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, udot_init, θdot_init,
    CtCabPdot_init, CtCabHdot_init, dt)</code></pre><p>Adds a beam element&#39;s contributions to the jacobian matrix</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>x</code>: current state vector</li><li><code>ibeam</code>: beam element index</li><li><code>beam</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>istep</code>: current time step</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam element</li><li><code>irow_b2</code>: Row index of the first equation for the right side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>x0</code>: Global frame origin (for the current time step)</li><li><code>v0</code>: Global frame linear velocity (for the current time step)</li><li><code>ω0</code>: Global frame angular velocity (for the current time step)</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>u0</code>: initial deflection variables for each beam element</li><li><code>θ0</code>: initial rotation variables for each beam element</li><li><code>udot0</code>: initial time derivative of u for each beam element</li><li><code>θdot0</code>: initial time derivative of θ for each beam element</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot_init</code>: <code>2/dt*u + udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot_init</code>: <code>2/dt*C&#39;*Cab*P + C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot_init</code>: <code>2/dt*C&#39;*Cab*H + C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L1200-L1255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_mass_matrix_properties" href="#GXBeam.element_mass_matrix_properties"><code>GXBeam.element_mass_matrix_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_mass_matrix_properties(x, icol, beam)</code></pre><p>Extract/Compute the properties needed for mass matrix construction: <code>ΔL</code>, <code>Ct</code>, <code>Cab</code>, <code>CtCab</code>, <code>θ</code>, <code>P</code>, <code>H</code>, <code>Ctdot_cdot1</code>, <code>Ctdot_cdot2</code>, and Ctdot_cdot3</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L1407-L1412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_mass_matrix_equations" href="#GXBeam.element_mass_matrix_equations"><code>GXBeam.element_mass_matrix_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_mass_matrix_equations(ΔL, Ct, Cab, CtCab, θ, P, H)</code></pre><p>Calculates the jacobians of the nonlinear equations for a beam element with respect to the time derivatives of the state variables.</p><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: Length of the beam element</li><li><code>Ct</code>: Rotation tensor of the beam deformation in the &quot;a&quot; frame, transposed</li><li><code>Cab</code>: Direction cosine matrix from &quot;a&quot; to &quot;b&quot; frame for the element</li><li><code>θ</code>: Rotation variables for the element [θ1, θ2, θ3]</li><li><code>P</code>: Linear momenta for the element [P1, P2, P3]</li><li><code>H</code>: Angular momenta for the element [H1, H2, H3]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L1429-L1446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.insert_element_mass_matrix!" href="#GXBeam.insert_element_mass_matrix!"><code>GXBeam.insert_element_mass_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_element_mass_matrix!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,
    f_u1_θdot, f_u2_θdot, f_u1_Pdot, f_u2_Pdot, f_ψ1_θdot, f_ψ2_θdot,
    f_ψ1_Hdot, f_ψ2_Hdot, f_P_udot, f_H_θdot)</code></pre><p>Insert the beam element&#39;s contributions into the &quot;mass matrix&quot;: the jacobian of the residual equations with respect to the time derivatives of the state variables</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix (mass matrix)</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam</li><li><code>irow_b2</code>: Row index of the first equation for the right side of the beam</li><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam</li><li><code>icol</code>: Row/Column index corresponding to the first beam state variable</li></ul><p>All other arguments use the following naming convention:</p><ul><li><code>f_y_x</code>: Jacobian of element equation &quot;y&quot; with respect to state variable &quot;x&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L1476-L1494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.element_mass_matrix!" href="#GXBeam.element_mass_matrix!"><code>GXBeam.element_mass_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_mass_matrix!(jacob, x, beam, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2)</code></pre><p>Add the beam element&#39;s contributions to the &quot;mass matrix&quot;: the jacobian of the residual equations with respect to the time derivatives of the state variables</p><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>x</code>: current state vector</li><li><code>beam</code>: beam element</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam element</li><li><code>irow_b2</code>: Row index of the first equation for the right side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/element.jl#L1518-L1539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.ElementState" href="#GXBeam.ElementState"><code>GXBeam.ElementState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementState</code></pre><p>Holds the state variables for an element</p><p><strong>Fields:</strong></p><ul><li><code>u</code>: Displacement variables for the element (in the global coordinate frame)</li><li>theta: Wiener-Milenkovic rotational displacement variables for the element</li><li><code>F</code>: Resultant forces for the element (in the deformed beam coordinate frame)</li><li><code>M</code>: Resultant moments for the element (in the deformed beam coordinate frame)</li><li><code>P</code>: Linear momenta of the element (in the deformed beam coordinate frame)</li><li><code>H</code>: Angular momenta of the element (in the deformed beam coordinate frame)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/postprocess.jl#L19-L31">source</a></section></article><h3 id="Loads"><a class="docs-heading-anchor" href="#Loads">Loads</a><a id="Loads-1"></a><a class="docs-heading-anchor-permalink" href="#Loads" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.PrescribedConditions" href="#GXBeam.PrescribedConditions"><code>GXBeam.PrescribedConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrescribedConditions{T}</code></pre><p>Describes the forces, moments, displacements, and/or rotations prescribed at a point for each time step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/loads.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.DistributedLoads" href="#GXBeam.DistributedLoads"><code>GXBeam.DistributedLoads</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DistributedLoads{T}</code></pre><p>Contains the integrated distributed forces and moments for each beam element for each time step.</p><p><strong>Fields</strong></p><ul><li>f1: Integrated non-follower distributed force for the beam element&#39;s left endpoint for each time step</li><li>f2: Integrated non-follower distributed force for the beam element&#39;s right endpoint for each time step</li><li>m1: Integrated non-follower distributed moment for the beam element&#39;s left endpoint for each time step</li><li>m2: Integrated non-follower distributed moment for the beam element&#39;s right endpoint for each time step</li><li>f1_follower: Integrated follower distributed force for the beam element&#39;s left endpoint for each time step</li><li>f2_follower: Integrated follower distributed force for the beam element&#39;s right endpoint for each time step</li><li>m1_follower: Integrated follower distributed moment for the beam element&#39;s left endpoint for each time step</li><li>m2_follower: Integrated follower distributed moment for the beam element&#39;s right endpoint for each time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/loads.jl#L170-L184">source</a></section></article><h3 id="System"><a class="docs-heading-anchor" href="#System">System</a><a id="System-1"></a><a class="docs-heading-anchor-permalink" href="#System" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GXBeam.Assembly" href="#GXBeam.Assembly"><code>GXBeam.Assembly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Assembly{TF, TP&lt;:AbstractVector{&lt;:AbstractVector{TF}}, TC&lt;:AbstractVector{&lt;:Integer}, TE&lt;:AbstractVector{Element{TF}}}</code></pre><p>Composite type that defines an assembly of connected nonlinear beam elements for analysis.</p><p><strong>Fields</strong></p><ul><li><code>points</code>: Array of all beam element endpoints</li><li><code>start</code>: Array containing point index where each beam element starts</li><li><code>stop</code>: Array containing point index where each beam element stops</li><li><code>element</code>: Array of <code>Element</code>s</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/assembly.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.curve_triad" href="#GXBeam.curve_triad"><code>GXBeam.curve_triad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">curve_triad(Cab, k, s)
curve_triad(Cab, kkt, ktilde, kn, s)</code></pre><p>Return the rotation matrix at <code>s</code> along the length of the beam given the curvature vector <code>k</code> and the initial rotation matrix <code>Cab</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/assembly.jl#L166-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.curve_coordinates" href="#GXBeam.curve_coordinates"><code>GXBeam.curve_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">curve_coordiantes(r, Cab, k, s)
curve_coordinates(r, Cab, kkt, ktilde, kn, s)</code></pre><p>Return the coordinates at <code>s</code> along the length of the beam given the starting point <code>r</code>, initial rotation matrix <code>Cab</code>, and curvature vector <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/assembly.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.System" href="#GXBeam.System"><code>GXBeam.System</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">System{TF, TV&lt;:AbstractVector{TF}, TM&lt;:AbstractMatrix{TF}, TTF&lt;:AbstractVector{TF}}</code></pre><p>Contains the system state, residual vector, and jacobian matrices as well as pointers to be able to access their contents.  Also contains additional storage needed for time domain simulations.</p><p><strong>Fields:</strong></p><ul><li><code>static</code>: Flag indicating whether system matrices are only valid for static analyses</li><li><code>x</code>: State vector</li><li><code>r</code>: Residual vector</li><li><code>K</code>: System jacobian matrix with respect to the state variables</li><li><code>M</code>: System jacobian matrix with respect to the time derivative of the state variables</li><li><code>irow_pt</code>: Row index of first equilibrium equation for each point</li><li><code>irow_beam</code>: Row index of first equation for just this beam element</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li><li><code>icol_pt</code>: Row/Column index of first state variable for each point</li><li><code>icol_beam</code>: Row/Column index of first state variable for each beam element</li><li><code>current_step</code>: Current time step</li><li><code>udot_init</code>: <code>2/dt*u + udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot_init</code>: <code>2/dt*C&#39;*Cab*P + C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot_init</code>: <code>2/dt*C&#39;*Cab*H + C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/system.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.point_connections" href="#GXBeam.point_connections"><code>GXBeam.point_connections</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">point_connections(assembly)</code></pre><p>Count the number of beams connected to each point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/system.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.system_indices" href="#GXBeam.system_indices"><code>GXBeam.system_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">system_indices(assembly, points, n_connections, static)</code></pre><p>Solve for the row indices of the first equilibrium or compatability equations for each point and side of each beam element.  Also solve for the row/column index of each point and beam state variable.</p><p>Note that this function includes the following logic which reduces the size of the system of equations where possible (without sacrificing any accuracy):</p><p>If only two beams meet at a point, the 6 unknowns associated with that point as well as the 6 compatability equations are eliminated from the system, except if specified in the array <code>points</code>.  Points for which unknowns have been eliminated are assigned a column index of -1.  Beams for which the compatability equations have been eliminated are also assigned an index of -1</p><p><strong>Arguments:</strong></p><ul><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li><li><code>points</code>: Point indices which should be preserved in the system matrices</li><li><code>n_connections</code>: Number of connections to each point</li><li><code>static</code>: flag indicating whether analysis is static</li></ul><p><strong>Return Arguments:</strong></p><ul><li><code>n</code>: total number of equations/unknowns in the system</li><li><code>irow_pt</code>: Row index of first equilibrium equation for each point</li><li><code>irow_beam</code>: Row index of first equation for just this beam element</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li><li><code>icol_pt</code>: Column index of first state variable for each point</li><li><code>icol_beam</code>: Column index of first state variable for each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/system.jl#L122-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.system_residual!" href="#GXBeam.system_residual!"><code>GXBeam.system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,
    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam)
system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,
    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0)
system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,
    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0,
    u, θ, udot, θdot)
system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,
    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0,
    udot, θdot_init, CtCabPdot, CtCabHdot, dt)</code></pre><p>Populate the residual vector <code>resid</code> with the results of the residual equations for the system.</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by  Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using  Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: System residual vector</li><li><code>x</code>: Current state variables of the system</li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li><li><code>prescribed_conditions</code>: Dictionary of prescribed conditions at all time steps</li><li><code>distributed_loads</code>: Dictionary of distributed loads at all time steps</li><li><code>istep</code>: Current time step</li><li><code>irow_pt</code>: Row index of first equilibrium equation for each point</li><li><code>irow_beam</code>: Row index of first equation for just this beam element</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li><li><code>icol_pt</code>: Column index of first state variable for each point</li><li><code>icol_beam</code>: Column index of first state variable for each beam element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>x0</code>: Global frame origin (for the current time step)</li><li><code>v0</code>: Global frame linear velocity (for the current time step)</li><li><code>ω0</code>: Global frame angular velocity (for the current time step)</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>u</code>: deflection variables for each beam element</li><li><code>θ</code>: rotation variables for each beam element</li><li><code>udot</code>: time derivative of u for each beam element</li><li><code>θdot</code>: time derivative of θ for each beam element</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot</code>: <code>-2/dt*u - udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>-2/dt*θ - θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot</code>: <code>-2/dt*C&#39;*Cab*P - C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot</code>: <code>-2/dt*C&#39;*Cab*H - C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/system.jl#L247-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.system_jacobian!" href="#GXBeam.system_jacobian!"><code>GXBeam.system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,
    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam)
system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,
    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,
    x0, v0, ω0)
system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,
    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,
    x0, v0, ω0, u, θ, udot, θdot)
system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,
    istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,
    x0, v0, ω0, udot_init, θdot_init, CtCabPdot_init, CtCabHdot_init, dt)</code></pre><p>Populate the jacobian matrix <code>jacob</code> with the jacobian of the residual vector with respect to the state variables.</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by  Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using  Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: Jacobian matrix</li><li><code>x</code>: Vector containing current state variables of the system</li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li><li><code>prescribed_conditions</code>: Dictionary of prescribed conditions at all time steps</li><li><code>distributed_loads</code>: Dictionary of distributed loads at all time steps</li><li><code>istep</code>: Current time step</li><li><code>irow_pt</code>: Row index of first equilibrium equation for each point</li><li><code>irow_beam</code>: Row index of first equation for just this beam element</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li><li><code>icol_pt</code>: Column index of first state variable for each point</li><li><code>icol_beam</code>: Column index of first state variable for each beam element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>x0</code>: Global frame origin (for the current time step)</li><li><code>v0</code>: Global frame linear velocity (for the current time step)</li><li><code>ω0</code>: Global frame angular velocity (for the current time step)</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>u</code>: deflection variables for each beam element</li><li><code>θ</code>: rotation variables for each beam element</li><li><code>udot</code>: time derivative of u for each beam element</li><li><code>θdot</code>: time derivative of θ for each beam element</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot</code>: <code>-2/dt*u - udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>-2/dt*θ - θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot</code>: <code>-2/dt*C&#39;*Cab*P - C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot</code>: <code>-2/dt*C&#39;*Cab*H - C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/system.jl#L474-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GXBeam.system_mass_matrix!" href="#GXBeam.system_mass_matrix!"><code>GXBeam.system_mass_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">system_mass_matrix!(jacob, x, assembly, irow_pt, irow_beam, irow_beam1,
    irow_beam2, icol_pt, icol_beam)</code></pre><p>Populate the system &quot;mass matrix&quot;, the jacobian of the residual vector with respect to the time derivatives of the state variables.</p><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: Jacobian matrix</li><li><code>x</code>: Vector containing current state variables of the system</li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li><li><code>irow_pt</code>: Row index of first equilibrium equation for each point</li><li><code>irow_beam</code>: Row index of first equation for just this beam element</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li><li><code>icol_pt</code>: Column index of first state variable for each point</li><li><code>icol_beam</code>: Column index of first state variable for each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GXBeam.jl/blob/d07b8bf49ac2186bbefc2ddf4a58b1c15866b2f8/src/system.jl#L702-L723">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#GXBeam.Assembly-Tuple{Any,Any,Any}"><code>GXBeam.Assembly</code></a></li><li><a href="#GXBeam.Assembly"><code>GXBeam.Assembly</code></a></li><li><a href="#GXBeam.AssemblyState"><code>GXBeam.AssemblyState</code></a></li><li><a href="#GXBeam.AssemblyState-Tuple{Any,Any}"><code>GXBeam.AssemblyState</code></a></li><li><a href="#GXBeam.DistributedLoads"><code>GXBeam.DistributedLoads</code></a></li><li><a href="#GXBeam.DistributedLoads-Tuple{Any,Any}"><code>GXBeam.DistributedLoads</code></a></li><li><a href="#GXBeam.Element"><code>GXBeam.Element</code></a></li><li><a href="#GXBeam.ElementState"><code>GXBeam.ElementState</code></a></li><li><a href="#GXBeam.PointState"><code>GXBeam.PointState</code></a></li><li><a href="#GXBeam.PrescribedConditions-Tuple{}"><code>GXBeam.PrescribedConditions</code></a></li><li><a href="#GXBeam.PrescribedConditions"><code>GXBeam.PrescribedConditions</code></a></li><li><a href="#GXBeam.System-Tuple{Any,Any,Any}"><code>GXBeam.System</code></a></li><li><a href="#GXBeam.System"><code>GXBeam.System</code></a></li><li><a href="#GXBeam.correlate_eigenmodes"><code>GXBeam.correlate_eigenmodes</code></a></li><li><a href="#GXBeam.curve_coordinates"><code>GXBeam.curve_coordinates</code></a></li><li><a href="#GXBeam.curve_length"><code>GXBeam.curve_length</code></a></li><li><a href="#GXBeam.curve_triad"><code>GXBeam.curve_triad</code></a></li><li><a href="#GXBeam.discretize_beam"><code>GXBeam.discretize_beam</code></a></li><li><a href="#GXBeam.dynamic_element_properties"><code>GXBeam.dynamic_element_properties</code></a></li><li><a href="#GXBeam.eigenvalue_analysis"><code>GXBeam.eigenvalue_analysis</code></a></li><li><a href="#GXBeam.eigenvalue_analysis!"><code>GXBeam.eigenvalue_analysis!</code></a></li><li><a href="#GXBeam.element_angular_velocity"><code>GXBeam.element_angular_velocity</code></a></li><li><a href="#GXBeam.element_curvature"><code>GXBeam.element_curvature</code></a></li><li><a href="#GXBeam.element_equations"><code>GXBeam.element_equations</code></a></li><li><a href="#GXBeam.element_jacobian!"><code>GXBeam.element_jacobian!</code></a></li><li><a href="#GXBeam.element_jacobian_equations"><code>GXBeam.element_jacobian_equations</code></a></li><li><a href="#GXBeam.element_linear_velocity"><code>GXBeam.element_linear_velocity</code></a></li><li><a href="#GXBeam.element_mass_matrix!"><code>GXBeam.element_mass_matrix!</code></a></li><li><a href="#GXBeam.element_mass_matrix_equations"><code>GXBeam.element_mass_matrix_equations</code></a></li><li><a href="#GXBeam.element_mass_matrix_properties"><code>GXBeam.element_mass_matrix_properties</code></a></li><li><a href="#GXBeam.element_properties"><code>GXBeam.element_properties</code></a></li><li><a href="#GXBeam.element_residual!"><code>GXBeam.element_residual!</code></a></li><li><a href="#GXBeam.element_strain"><code>GXBeam.element_strain</code></a></li><li><a href="#GXBeam.gauss_quadrature"><code>GXBeam.gauss_quadrature</code></a></li><li><a href="#GXBeam.get_C"><code>GXBeam.get_C</code></a></li><li><a href="#GXBeam.get_C_t"><code>GXBeam.get_C_t</code></a></li><li><a href="#GXBeam.get_C_θ"><code>GXBeam.get_C_θ</code></a></li><li><a href="#GXBeam.get_C_θdot"><code>GXBeam.get_C_θdot</code></a></li><li><a href="#GXBeam.get_Q"><code>GXBeam.get_Q</code></a></li><li><a href="#GXBeam.get_Q_θ"><code>GXBeam.get_Q_θ</code></a></li><li><a href="#GXBeam.get_Qinv"><code>GXBeam.get_Qinv</code></a></li><li><a href="#GXBeam.get_Qinv_θ"><code>GXBeam.get_Qinv_θ</code></a></li><li><a href="#GXBeam.insert_element_jacobian!"><code>GXBeam.insert_element_jacobian!</code></a></li><li><a href="#GXBeam.insert_element_mass_matrix!"><code>GXBeam.insert_element_mass_matrix!</code></a></li><li><a href="#GXBeam.insert_element_residual!"><code>GXBeam.insert_element_residual!</code></a></li><li><a href="#GXBeam.insert_point_jacobian!"><code>GXBeam.insert_point_jacobian!</code></a></li><li><a href="#GXBeam.insert_point_residual!"><code>GXBeam.insert_point_residual!</code></a></li><li><a href="#GXBeam.left_eigenvectors"><code>GXBeam.left_eigenvectors</code></a></li><li><a href="#GXBeam.mul3"><code>GXBeam.mul3</code></a></li><li><a href="#GXBeam.point_connections"><code>GXBeam.point_connections</code></a></li><li><a href="#GXBeam.point_follower_jacobians"><code>GXBeam.point_follower_jacobians</code></a></li><li><a href="#GXBeam.point_jacobian!"><code>GXBeam.point_jacobian!</code></a></li><li><a href="#GXBeam.point_residual!"><code>GXBeam.point_residual!</code></a></li><li><a href="#GXBeam.point_variables"><code>GXBeam.point_variables</code></a></li><li><a href="#GXBeam.reset_state!"><code>GXBeam.reset_state!</code></a></li><li><a href="#GXBeam.rotation_parameter_scaling"><code>GXBeam.rotation_parameter_scaling</code></a></li><li><a href="#GXBeam.static_analysis"><code>GXBeam.static_analysis</code></a></li><li><a href="#GXBeam.static_analysis!"><code>GXBeam.static_analysis!</code></a></li><li><a href="#GXBeam.steady_state_analysis"><code>GXBeam.steady_state_analysis</code></a></li><li><a href="#GXBeam.steady_state_analysis!"><code>GXBeam.steady_state_analysis!</code></a></li><li><a href="#GXBeam.system_indices"><code>GXBeam.system_indices</code></a></li><li><a href="#GXBeam.system_jacobian!"><code>GXBeam.system_jacobian!</code></a></li><li><a href="#GXBeam.system_mass_matrix!"><code>GXBeam.system_mass_matrix!</code></a></li><li><a href="#GXBeam.system_residual!"><code>GXBeam.system_residual!</code></a></li><li><a href="#GXBeam.tilde"><code>GXBeam.tilde</code></a></li><li><a href="#GXBeam.time_domain_analysis"><code>GXBeam.time_domain_analysis</code></a></li><li><a href="#GXBeam.time_domain_analysis!"><code>GXBeam.time_domain_analysis!</code></a></li><li><a href="#GXBeam.wiener_milenkovic"><code>GXBeam.wiener_milenkovic</code></a></li><li><a href="#GXBeam.write_vtk"><code>GXBeam.write_vtk</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 9 March 2021 04:26">Tuesday 9 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
